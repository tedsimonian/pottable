
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Garden
 * 
 */
export type Garden = $Result.DefaultSelection<Prisma.$GardenPayload>
/**
 * Model GardenCondition
 * 
 */
export type GardenCondition = $Result.DefaultSelection<Prisma.$GardenConditionPayload>
/**
 * Model ContainerType
 * 
 */
export type ContainerType = $Result.DefaultSelection<Prisma.$ContainerTypePayload>
/**
 * Model Container
 * 
 */
export type Container = $Result.DefaultSelection<Prisma.$ContainerPayload>
/**
 * Model PlantCatalog
 * 
 */
export type PlantCatalog = $Result.DefaultSelection<Prisma.$PlantCatalogPayload>
/**
 * Model PlantGrowingCondition
 * 
 */
export type PlantGrowingCondition = $Result.DefaultSelection<Prisma.$PlantGrowingConditionPayload>
/**
 * Model PlantClimateZone
 * 
 */
export type PlantClimateZone = $Result.DefaultSelection<Prisma.$PlantClimateZonePayload>
/**
 * Model PlantVariety
 * 
 */
export type PlantVariety = $Result.DefaultSelection<Prisma.$PlantVarietyPayload>
/**
 * Model PlantCompanion
 * 
 */
export type PlantCompanion = $Result.DefaultSelection<Prisma.$PlantCompanionPayload>
/**
 * Model ContainerPlant
 * 
 */
export type ContainerPlant = $Result.DefaultSelection<Prisma.$ContainerPlantPayload>
/**
 * Model PlantGrowthStage
 * 
 */
export type PlantGrowthStage = $Result.DefaultSelection<Prisma.$PlantGrowthStagePayload>
/**
 * Model ActionType
 * 
 */
export type ActionType = $Result.DefaultSelection<Prisma.$ActionTypePayload>
/**
 * Model GardenAction
 * 
 */
export type GardenAction = $Result.DefaultSelection<Prisma.$GardenActionPayload>
/**
 * Model Harvest
 * 
 */
export type Harvest = $Result.DefaultSelection<Prisma.$HarvestPayload>
/**
 * Model ContainerHistory
 * 
 */
export type ContainerHistory = $Result.DefaultSelection<Prisma.$ContainerHistoryPayload>
/**
 * Model PlantMovementHistory
 * 
 */
export type PlantMovementHistory = $Result.DefaultSelection<Prisma.$PlantMovementHistoryPayload>
/**
 * Model SeasonalPlan
 * 
 */
export type SeasonalPlan = $Result.DefaultSelection<Prisma.$SeasonalPlanPayload>
/**
 * Model PlannedPlanting
 * 
 */
export type PlannedPlanting = $Result.DefaultSelection<Prisma.$PlannedPlantingPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskPrerequisite
 * 
 */
export type TaskPrerequisite = $Result.DefaultSelection<Prisma.$TaskPrerequisitePayload>
/**
 * Model TaskNote
 * 
 */
export type TaskNote = $Result.DefaultSelection<Prisma.$TaskNotePayload>
/**
 * Model TaskCompletionLog
 * 
 */
export type TaskCompletionLog = $Result.DefaultSelection<Prisma.$TaskCompletionLogPayload>
/**
 * Model RecurringTaskPattern
 * 
 */
export type RecurringTaskPattern = $Result.DefaultSelection<Prisma.$RecurringTaskPatternPayload>
/**
 * Model TaskNotification
 * 
 */
export type TaskNotification = $Result.DefaultSelection<Prisma.$TaskNotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.garden`: Exposes CRUD operations for the **Garden** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gardens
    * const gardens = await prisma.garden.findMany()
    * ```
    */
  get garden(): Prisma.GardenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gardenCondition`: Exposes CRUD operations for the **GardenCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GardenConditions
    * const gardenConditions = await prisma.gardenCondition.findMany()
    * ```
    */
  get gardenCondition(): Prisma.GardenConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.containerType`: Exposes CRUD operations for the **ContainerType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContainerTypes
    * const containerTypes = await prisma.containerType.findMany()
    * ```
    */
  get containerType(): Prisma.ContainerTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.container`: Exposes CRUD operations for the **Container** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Containers
    * const containers = await prisma.container.findMany()
    * ```
    */
  get container(): Prisma.ContainerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantCatalog`: Exposes CRUD operations for the **PlantCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantCatalogs
    * const plantCatalogs = await prisma.plantCatalog.findMany()
    * ```
    */
  get plantCatalog(): Prisma.PlantCatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantGrowingCondition`: Exposes CRUD operations for the **PlantGrowingCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantGrowingConditions
    * const plantGrowingConditions = await prisma.plantGrowingCondition.findMany()
    * ```
    */
  get plantGrowingCondition(): Prisma.PlantGrowingConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantClimateZone`: Exposes CRUD operations for the **PlantClimateZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantClimateZones
    * const plantClimateZones = await prisma.plantClimateZone.findMany()
    * ```
    */
  get plantClimateZone(): Prisma.PlantClimateZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantVariety`: Exposes CRUD operations for the **PlantVariety** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantVarieties
    * const plantVarieties = await prisma.plantVariety.findMany()
    * ```
    */
  get plantVariety(): Prisma.PlantVarietyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantCompanion`: Exposes CRUD operations for the **PlantCompanion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantCompanions
    * const plantCompanions = await prisma.plantCompanion.findMany()
    * ```
    */
  get plantCompanion(): Prisma.PlantCompanionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.containerPlant`: Exposes CRUD operations for the **ContainerPlant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContainerPlants
    * const containerPlants = await prisma.containerPlant.findMany()
    * ```
    */
  get containerPlant(): Prisma.ContainerPlantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantGrowthStage`: Exposes CRUD operations for the **PlantGrowthStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantGrowthStages
    * const plantGrowthStages = await prisma.plantGrowthStage.findMany()
    * ```
    */
  get plantGrowthStage(): Prisma.PlantGrowthStageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionType`: Exposes CRUD operations for the **ActionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionTypes
    * const actionTypes = await prisma.actionType.findMany()
    * ```
    */
  get actionType(): Prisma.ActionTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gardenAction`: Exposes CRUD operations for the **GardenAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GardenActions
    * const gardenActions = await prisma.gardenAction.findMany()
    * ```
    */
  get gardenAction(): Prisma.GardenActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.harvest`: Exposes CRUD operations for the **Harvest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Harvests
    * const harvests = await prisma.harvest.findMany()
    * ```
    */
  get harvest(): Prisma.HarvestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.containerHistory`: Exposes CRUD operations for the **ContainerHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContainerHistories
    * const containerHistories = await prisma.containerHistory.findMany()
    * ```
    */
  get containerHistory(): Prisma.ContainerHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantMovementHistory`: Exposes CRUD operations for the **PlantMovementHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantMovementHistories
    * const plantMovementHistories = await prisma.plantMovementHistory.findMany()
    * ```
    */
  get plantMovementHistory(): Prisma.PlantMovementHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seasonalPlan`: Exposes CRUD operations for the **SeasonalPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeasonalPlans
    * const seasonalPlans = await prisma.seasonalPlan.findMany()
    * ```
    */
  get seasonalPlan(): Prisma.SeasonalPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plannedPlanting`: Exposes CRUD operations for the **PlannedPlanting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlannedPlantings
    * const plannedPlantings = await prisma.plannedPlanting.findMany()
    * ```
    */
  get plannedPlanting(): Prisma.PlannedPlantingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskPrerequisite`: Exposes CRUD operations for the **TaskPrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskPrerequisites
    * const taskPrerequisites = await prisma.taskPrerequisite.findMany()
    * ```
    */
  get taskPrerequisite(): Prisma.TaskPrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskNote`: Exposes CRUD operations for the **TaskNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskNotes
    * const taskNotes = await prisma.taskNote.findMany()
    * ```
    */
  get taskNote(): Prisma.TaskNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskCompletionLog`: Exposes CRUD operations for the **TaskCompletionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCompletionLogs
    * const taskCompletionLogs = await prisma.taskCompletionLog.findMany()
    * ```
    */
  get taskCompletionLog(): Prisma.TaskCompletionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringTaskPattern`: Exposes CRUD operations for the **RecurringTaskPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringTaskPatterns
    * const recurringTaskPatterns = await prisma.recurringTaskPattern.findMany()
    * ```
    */
  get recurringTaskPattern(): Prisma.RecurringTaskPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskNotification`: Exposes CRUD operations for the **TaskNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskNotifications
    * const taskNotifications = await prisma.taskNotification.findMany()
    * ```
    */
  get taskNotification(): Prisma.TaskNotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Garden: 'Garden',
    GardenCondition: 'GardenCondition',
    ContainerType: 'ContainerType',
    Container: 'Container',
    PlantCatalog: 'PlantCatalog',
    PlantGrowingCondition: 'PlantGrowingCondition',
    PlantClimateZone: 'PlantClimateZone',
    PlantVariety: 'PlantVariety',
    PlantCompanion: 'PlantCompanion',
    ContainerPlant: 'ContainerPlant',
    PlantGrowthStage: 'PlantGrowthStage',
    ActionType: 'ActionType',
    GardenAction: 'GardenAction',
    Harvest: 'Harvest',
    ContainerHistory: 'ContainerHistory',
    PlantMovementHistory: 'PlantMovementHistory',
    SeasonalPlan: 'SeasonalPlan',
    PlannedPlanting: 'PlannedPlanting',
    Task: 'Task',
    TaskPrerequisite: 'TaskPrerequisite',
    TaskNote: 'TaskNote',
    TaskCompletionLog: 'TaskCompletionLog',
    RecurringTaskPattern: 'RecurringTaskPattern',
    TaskNotification: 'TaskNotification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "garden" | "gardenCondition" | "containerType" | "container" | "plantCatalog" | "plantGrowingCondition" | "plantClimateZone" | "plantVariety" | "plantCompanion" | "containerPlant" | "plantGrowthStage" | "actionType" | "gardenAction" | "harvest" | "containerHistory" | "plantMovementHistory" | "seasonalPlan" | "plannedPlanting" | "task" | "taskPrerequisite" | "taskNote" | "taskCompletionLog" | "recurringTaskPattern" | "taskNotification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Garden: {
        payload: Prisma.$GardenPayload<ExtArgs>
        fields: Prisma.GardenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GardenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GardenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          findFirst: {
            args: Prisma.GardenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GardenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          findMany: {
            args: Prisma.GardenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>[]
          }
          create: {
            args: Prisma.GardenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          createMany: {
            args: Prisma.GardenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GardenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>[]
          }
          delete: {
            args: Prisma.GardenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          update: {
            args: Prisma.GardenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          deleteMany: {
            args: Prisma.GardenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GardenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GardenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>[]
          }
          upsert: {
            args: Prisma.GardenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenPayload>
          }
          aggregate: {
            args: Prisma.GardenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGarden>
          }
          groupBy: {
            args: Prisma.GardenGroupByArgs<ExtArgs>
            result: $Utils.Optional<GardenGroupByOutputType>[]
          }
          count: {
            args: Prisma.GardenCountArgs<ExtArgs>
            result: $Utils.Optional<GardenCountAggregateOutputType> | number
          }
        }
      }
      GardenCondition: {
        payload: Prisma.$GardenConditionPayload<ExtArgs>
        fields: Prisma.GardenConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GardenConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GardenConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          findFirst: {
            args: Prisma.GardenConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GardenConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          findMany: {
            args: Prisma.GardenConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>[]
          }
          create: {
            args: Prisma.GardenConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          createMany: {
            args: Prisma.GardenConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GardenConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>[]
          }
          delete: {
            args: Prisma.GardenConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          update: {
            args: Prisma.GardenConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          deleteMany: {
            args: Prisma.GardenConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GardenConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GardenConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>[]
          }
          upsert: {
            args: Prisma.GardenConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenConditionPayload>
          }
          aggregate: {
            args: Prisma.GardenConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGardenCondition>
          }
          groupBy: {
            args: Prisma.GardenConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GardenConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GardenConditionCountArgs<ExtArgs>
            result: $Utils.Optional<GardenConditionCountAggregateOutputType> | number
          }
        }
      }
      ContainerType: {
        payload: Prisma.$ContainerTypePayload<ExtArgs>
        fields: Prisma.ContainerTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          findFirst: {
            args: Prisma.ContainerTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          findMany: {
            args: Prisma.ContainerTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>[]
          }
          create: {
            args: Prisma.ContainerTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          createMany: {
            args: Prisma.ContainerTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>[]
          }
          delete: {
            args: Prisma.ContainerTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          update: {
            args: Prisma.ContainerTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          deleteMany: {
            args: Prisma.ContainerTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContainerTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>[]
          }
          upsert: {
            args: Prisma.ContainerTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerTypePayload>
          }
          aggregate: {
            args: Prisma.ContainerTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainerType>
          }
          groupBy: {
            args: Prisma.ContainerTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerTypeCountAggregateOutputType> | number
          }
        }
      }
      Container: {
        payload: Prisma.$ContainerPayload<ExtArgs>
        fields: Prisma.ContainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findFirst: {
            args: Prisma.ContainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findMany: {
            args: Prisma.ContainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          create: {
            args: Prisma.ContainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          createMany: {
            args: Prisma.ContainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          delete: {
            args: Prisma.ContainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          update: {
            args: Prisma.ContainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          deleteMany: {
            args: Prisma.ContainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContainerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          upsert: {
            args: Prisma.ContainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          aggregate: {
            args: Prisma.ContainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainer>
          }
          groupBy: {
            args: Prisma.ContainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerCountAggregateOutputType> | number
          }
        }
      }
      PlantCatalog: {
        payload: Prisma.$PlantCatalogPayload<ExtArgs>
        fields: Prisma.PlantCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          findFirst: {
            args: Prisma.PlantCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          findMany: {
            args: Prisma.PlantCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>[]
          }
          create: {
            args: Prisma.PlantCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          createMany: {
            args: Prisma.PlantCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>[]
          }
          delete: {
            args: Prisma.PlantCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          update: {
            args: Prisma.PlantCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          deleteMany: {
            args: Prisma.PlantCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantCatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>[]
          }
          upsert: {
            args: Prisma.PlantCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCatalogPayload>
          }
          aggregate: {
            args: Prisma.PlantCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantCatalog>
          }
          groupBy: {
            args: Prisma.PlantCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<PlantCatalogCountAggregateOutputType> | number
          }
        }
      }
      PlantGrowingCondition: {
        payload: Prisma.$PlantGrowingConditionPayload<ExtArgs>
        fields: Prisma.PlantGrowingConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantGrowingConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantGrowingConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          findFirst: {
            args: Prisma.PlantGrowingConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantGrowingConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          findMany: {
            args: Prisma.PlantGrowingConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>[]
          }
          create: {
            args: Prisma.PlantGrowingConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          createMany: {
            args: Prisma.PlantGrowingConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantGrowingConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>[]
          }
          delete: {
            args: Prisma.PlantGrowingConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          update: {
            args: Prisma.PlantGrowingConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          deleteMany: {
            args: Prisma.PlantGrowingConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantGrowingConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantGrowingConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>[]
          }
          upsert: {
            args: Prisma.PlantGrowingConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowingConditionPayload>
          }
          aggregate: {
            args: Prisma.PlantGrowingConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantGrowingCondition>
          }
          groupBy: {
            args: Prisma.PlantGrowingConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantGrowingConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantGrowingConditionCountArgs<ExtArgs>
            result: $Utils.Optional<PlantGrowingConditionCountAggregateOutputType> | number
          }
        }
      }
      PlantClimateZone: {
        payload: Prisma.$PlantClimateZonePayload<ExtArgs>
        fields: Prisma.PlantClimateZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantClimateZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantClimateZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          findFirst: {
            args: Prisma.PlantClimateZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantClimateZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          findMany: {
            args: Prisma.PlantClimateZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>[]
          }
          create: {
            args: Prisma.PlantClimateZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          createMany: {
            args: Prisma.PlantClimateZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantClimateZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>[]
          }
          delete: {
            args: Prisma.PlantClimateZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          update: {
            args: Prisma.PlantClimateZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          deleteMany: {
            args: Prisma.PlantClimateZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantClimateZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantClimateZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>[]
          }
          upsert: {
            args: Prisma.PlantClimateZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantClimateZonePayload>
          }
          aggregate: {
            args: Prisma.PlantClimateZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantClimateZone>
          }
          groupBy: {
            args: Prisma.PlantClimateZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantClimateZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantClimateZoneCountArgs<ExtArgs>
            result: $Utils.Optional<PlantClimateZoneCountAggregateOutputType> | number
          }
        }
      }
      PlantVariety: {
        payload: Prisma.$PlantVarietyPayload<ExtArgs>
        fields: Prisma.PlantVarietyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantVarietyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantVarietyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          findFirst: {
            args: Prisma.PlantVarietyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantVarietyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          findMany: {
            args: Prisma.PlantVarietyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>[]
          }
          create: {
            args: Prisma.PlantVarietyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          createMany: {
            args: Prisma.PlantVarietyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantVarietyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>[]
          }
          delete: {
            args: Prisma.PlantVarietyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          update: {
            args: Prisma.PlantVarietyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          deleteMany: {
            args: Prisma.PlantVarietyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantVarietyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantVarietyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>[]
          }
          upsert: {
            args: Prisma.PlantVarietyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantVarietyPayload>
          }
          aggregate: {
            args: Prisma.PlantVarietyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantVariety>
          }
          groupBy: {
            args: Prisma.PlantVarietyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantVarietyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantVarietyCountArgs<ExtArgs>
            result: $Utils.Optional<PlantVarietyCountAggregateOutputType> | number
          }
        }
      }
      PlantCompanion: {
        payload: Prisma.$PlantCompanionPayload<ExtArgs>
        fields: Prisma.PlantCompanionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantCompanionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantCompanionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          findFirst: {
            args: Prisma.PlantCompanionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantCompanionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          findMany: {
            args: Prisma.PlantCompanionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>[]
          }
          create: {
            args: Prisma.PlantCompanionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          createMany: {
            args: Prisma.PlantCompanionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantCompanionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>[]
          }
          delete: {
            args: Prisma.PlantCompanionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          update: {
            args: Prisma.PlantCompanionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          deleteMany: {
            args: Prisma.PlantCompanionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantCompanionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantCompanionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>[]
          }
          upsert: {
            args: Prisma.PlantCompanionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantCompanionPayload>
          }
          aggregate: {
            args: Prisma.PlantCompanionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantCompanion>
          }
          groupBy: {
            args: Prisma.PlantCompanionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantCompanionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantCompanionCountArgs<ExtArgs>
            result: $Utils.Optional<PlantCompanionCountAggregateOutputType> | number
          }
        }
      }
      ContainerPlant: {
        payload: Prisma.$ContainerPlantPayload<ExtArgs>
        fields: Prisma.ContainerPlantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerPlantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerPlantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          findFirst: {
            args: Prisma.ContainerPlantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerPlantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          findMany: {
            args: Prisma.ContainerPlantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>[]
          }
          create: {
            args: Prisma.ContainerPlantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          createMany: {
            args: Prisma.ContainerPlantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerPlantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>[]
          }
          delete: {
            args: Prisma.ContainerPlantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          update: {
            args: Prisma.ContainerPlantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          deleteMany: {
            args: Prisma.ContainerPlantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerPlantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContainerPlantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>[]
          }
          upsert: {
            args: Prisma.ContainerPlantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPlantPayload>
          }
          aggregate: {
            args: Prisma.ContainerPlantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainerPlant>
          }
          groupBy: {
            args: Prisma.ContainerPlantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerPlantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerPlantCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerPlantCountAggregateOutputType> | number
          }
        }
      }
      PlantGrowthStage: {
        payload: Prisma.$PlantGrowthStagePayload<ExtArgs>
        fields: Prisma.PlantGrowthStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantGrowthStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantGrowthStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          findFirst: {
            args: Prisma.PlantGrowthStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantGrowthStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          findMany: {
            args: Prisma.PlantGrowthStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>[]
          }
          create: {
            args: Prisma.PlantGrowthStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          createMany: {
            args: Prisma.PlantGrowthStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantGrowthStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>[]
          }
          delete: {
            args: Prisma.PlantGrowthStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          update: {
            args: Prisma.PlantGrowthStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          deleteMany: {
            args: Prisma.PlantGrowthStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantGrowthStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantGrowthStageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>[]
          }
          upsert: {
            args: Prisma.PlantGrowthStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantGrowthStagePayload>
          }
          aggregate: {
            args: Prisma.PlantGrowthStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantGrowthStage>
          }
          groupBy: {
            args: Prisma.PlantGrowthStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantGrowthStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantGrowthStageCountArgs<ExtArgs>
            result: $Utils.Optional<PlantGrowthStageCountAggregateOutputType> | number
          }
        }
      }
      ActionType: {
        payload: Prisma.$ActionTypePayload<ExtArgs>
        fields: Prisma.ActionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          findFirst: {
            args: Prisma.ActionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          findMany: {
            args: Prisma.ActionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>[]
          }
          create: {
            args: Prisma.ActionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          createMany: {
            args: Prisma.ActionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>[]
          }
          delete: {
            args: Prisma.ActionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          update: {
            args: Prisma.ActionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          deleteMany: {
            args: Prisma.ActionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>[]
          }
          upsert: {
            args: Prisma.ActionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionTypePayload>
          }
          aggregate: {
            args: Prisma.ActionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionType>
          }
          groupBy: {
            args: Prisma.ActionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ActionTypeCountAggregateOutputType> | number
          }
        }
      }
      GardenAction: {
        payload: Prisma.$GardenActionPayload<ExtArgs>
        fields: Prisma.GardenActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GardenActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GardenActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          findFirst: {
            args: Prisma.GardenActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GardenActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          findMany: {
            args: Prisma.GardenActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>[]
          }
          create: {
            args: Prisma.GardenActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          createMany: {
            args: Prisma.GardenActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GardenActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>[]
          }
          delete: {
            args: Prisma.GardenActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          update: {
            args: Prisma.GardenActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          deleteMany: {
            args: Prisma.GardenActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GardenActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GardenActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>[]
          }
          upsert: {
            args: Prisma.GardenActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GardenActionPayload>
          }
          aggregate: {
            args: Prisma.GardenActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGardenAction>
          }
          groupBy: {
            args: Prisma.GardenActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GardenActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GardenActionCountArgs<ExtArgs>
            result: $Utils.Optional<GardenActionCountAggregateOutputType> | number
          }
        }
      }
      Harvest: {
        payload: Prisma.$HarvestPayload<ExtArgs>
        fields: Prisma.HarvestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HarvestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HarvestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          findFirst: {
            args: Prisma.HarvestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HarvestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          findMany: {
            args: Prisma.HarvestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>[]
          }
          create: {
            args: Prisma.HarvestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          createMany: {
            args: Prisma.HarvestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HarvestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>[]
          }
          delete: {
            args: Prisma.HarvestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          update: {
            args: Prisma.HarvestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          deleteMany: {
            args: Prisma.HarvestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HarvestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HarvestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>[]
          }
          upsert: {
            args: Prisma.HarvestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HarvestPayload>
          }
          aggregate: {
            args: Prisma.HarvestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHarvest>
          }
          groupBy: {
            args: Prisma.HarvestGroupByArgs<ExtArgs>
            result: $Utils.Optional<HarvestGroupByOutputType>[]
          }
          count: {
            args: Prisma.HarvestCountArgs<ExtArgs>
            result: $Utils.Optional<HarvestCountAggregateOutputType> | number
          }
        }
      }
      ContainerHistory: {
        payload: Prisma.$ContainerHistoryPayload<ExtArgs>
        fields: Prisma.ContainerHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          findFirst: {
            args: Prisma.ContainerHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          findMany: {
            args: Prisma.ContainerHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>[]
          }
          create: {
            args: Prisma.ContainerHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          createMany: {
            args: Prisma.ContainerHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>[]
          }
          delete: {
            args: Prisma.ContainerHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          update: {
            args: Prisma.ContainerHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ContainerHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContainerHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ContainerHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerHistoryPayload>
          }
          aggregate: {
            args: Prisma.ContainerHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainerHistory>
          }
          groupBy: {
            args: Prisma.ContainerHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerHistoryCountAggregateOutputType> | number
          }
        }
      }
      PlantMovementHistory: {
        payload: Prisma.$PlantMovementHistoryPayload<ExtArgs>
        fields: Prisma.PlantMovementHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantMovementHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantMovementHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          findFirst: {
            args: Prisma.PlantMovementHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantMovementHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          findMany: {
            args: Prisma.PlantMovementHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>[]
          }
          create: {
            args: Prisma.PlantMovementHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          createMany: {
            args: Prisma.PlantMovementHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantMovementHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>[]
          }
          delete: {
            args: Prisma.PlantMovementHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          update: {
            args: Prisma.PlantMovementHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PlantMovementHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantMovementHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantMovementHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PlantMovementHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantMovementHistoryPayload>
          }
          aggregate: {
            args: Prisma.PlantMovementHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantMovementHistory>
          }
          groupBy: {
            args: Prisma.PlantMovementHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantMovementHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantMovementHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PlantMovementHistoryCountAggregateOutputType> | number
          }
        }
      }
      SeasonalPlan: {
        payload: Prisma.$SeasonalPlanPayload<ExtArgs>
        fields: Prisma.SeasonalPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonalPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonalPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          findFirst: {
            args: Prisma.SeasonalPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonalPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          findMany: {
            args: Prisma.SeasonalPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>[]
          }
          create: {
            args: Prisma.SeasonalPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          createMany: {
            args: Prisma.SeasonalPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonalPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>[]
          }
          delete: {
            args: Prisma.SeasonalPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          update: {
            args: Prisma.SeasonalPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          deleteMany: {
            args: Prisma.SeasonalPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonalPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonalPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>[]
          }
          upsert: {
            args: Prisma.SeasonalPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPlanPayload>
          }
          aggregate: {
            args: Prisma.SeasonalPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeasonalPlan>
          }
          groupBy: {
            args: Prisma.SeasonalPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonalPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonalPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonalPlanCountAggregateOutputType> | number
          }
        }
      }
      PlannedPlanting: {
        payload: Prisma.$PlannedPlantingPayload<ExtArgs>
        fields: Prisma.PlannedPlantingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlannedPlantingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlannedPlantingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          findFirst: {
            args: Prisma.PlannedPlantingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlannedPlantingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          findMany: {
            args: Prisma.PlannedPlantingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>[]
          }
          create: {
            args: Prisma.PlannedPlantingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          createMany: {
            args: Prisma.PlannedPlantingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlannedPlantingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>[]
          }
          delete: {
            args: Prisma.PlannedPlantingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          update: {
            args: Prisma.PlannedPlantingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          deleteMany: {
            args: Prisma.PlannedPlantingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlannedPlantingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlannedPlantingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>[]
          }
          upsert: {
            args: Prisma.PlannedPlantingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannedPlantingPayload>
          }
          aggregate: {
            args: Prisma.PlannedPlantingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlannedPlanting>
          }
          groupBy: {
            args: Prisma.PlannedPlantingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlannedPlantingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlannedPlantingCountArgs<ExtArgs>
            result: $Utils.Optional<PlannedPlantingCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskPrerequisite: {
        payload: Prisma.$TaskPrerequisitePayload<ExtArgs>
        fields: Prisma.TaskPrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskPrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskPrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          findFirst: {
            args: Prisma.TaskPrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskPrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          findMany: {
            args: Prisma.TaskPrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>[]
          }
          create: {
            args: Prisma.TaskPrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          createMany: {
            args: Prisma.TaskPrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskPrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>[]
          }
          delete: {
            args: Prisma.TaskPrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          update: {
            args: Prisma.TaskPrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.TaskPrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskPrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskPrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.TaskPrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPrerequisitePayload>
          }
          aggregate: {
            args: Prisma.TaskPrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskPrerequisite>
          }
          groupBy: {
            args: Prisma.TaskPrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskPrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskPrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<TaskPrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      TaskNote: {
        payload: Prisma.$TaskNotePayload<ExtArgs>
        fields: Prisma.TaskNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          findFirst: {
            args: Prisma.TaskNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          findMany: {
            args: Prisma.TaskNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          create: {
            args: Prisma.TaskNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          createMany: {
            args: Prisma.TaskNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          delete: {
            args: Prisma.TaskNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          update: {
            args: Prisma.TaskNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          deleteMany: {
            args: Prisma.TaskNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>[]
          }
          upsert: {
            args: Prisma.TaskNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotePayload>
          }
          aggregate: {
            args: Prisma.TaskNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskNote>
          }
          groupBy: {
            args: Prisma.TaskNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskNoteCountArgs<ExtArgs>
            result: $Utils.Optional<TaskNoteCountAggregateOutputType> | number
          }
        }
      }
      TaskCompletionLog: {
        payload: Prisma.$TaskCompletionLogPayload<ExtArgs>
        fields: Prisma.TaskCompletionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCompletionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCompletionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          findFirst: {
            args: Prisma.TaskCompletionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCompletionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          findMany: {
            args: Prisma.TaskCompletionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>[]
          }
          create: {
            args: Prisma.TaskCompletionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          createMany: {
            args: Prisma.TaskCompletionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCompletionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>[]
          }
          delete: {
            args: Prisma.TaskCompletionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          update: {
            args: Prisma.TaskCompletionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          deleteMany: {
            args: Prisma.TaskCompletionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCompletionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCompletionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>[]
          }
          upsert: {
            args: Prisma.TaskCompletionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionLogPayload>
          }
          aggregate: {
            args: Prisma.TaskCompletionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCompletionLog>
          }
          groupBy: {
            args: Prisma.TaskCompletionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCompletionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCompletionLogCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCompletionLogCountAggregateOutputType> | number
          }
        }
      }
      RecurringTaskPattern: {
        payload: Prisma.$RecurringTaskPatternPayload<ExtArgs>
        fields: Prisma.RecurringTaskPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringTaskPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringTaskPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          findFirst: {
            args: Prisma.RecurringTaskPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringTaskPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          findMany: {
            args: Prisma.RecurringTaskPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>[]
          }
          create: {
            args: Prisma.RecurringTaskPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          createMany: {
            args: Prisma.RecurringTaskPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringTaskPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>[]
          }
          delete: {
            args: Prisma.RecurringTaskPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          update: {
            args: Prisma.RecurringTaskPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          deleteMany: {
            args: Prisma.RecurringTaskPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringTaskPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringTaskPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>[]
          }
          upsert: {
            args: Prisma.RecurringTaskPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTaskPatternPayload>
          }
          aggregate: {
            args: Prisma.RecurringTaskPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringTaskPattern>
          }
          groupBy: {
            args: Prisma.RecurringTaskPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringTaskPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringTaskPatternCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringTaskPatternCountAggregateOutputType> | number
          }
        }
      }
      TaskNotification: {
        payload: Prisma.$TaskNotificationPayload<ExtArgs>
        fields: Prisma.TaskNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          findFirst: {
            args: Prisma.TaskNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          findMany: {
            args: Prisma.TaskNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
          }
          create: {
            args: Prisma.TaskNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          createMany: {
            args: Prisma.TaskNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
          }
          delete: {
            args: Prisma.TaskNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          update: {
            args: Prisma.TaskNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          deleteMany: {
            args: Prisma.TaskNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
          }
          upsert: {
            args: Prisma.TaskNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
          }
          aggregate: {
            args: Prisma.TaskNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskNotification>
          }
          groupBy: {
            args: Prisma.TaskNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<TaskNotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    garden?: GardenOmit
    gardenCondition?: GardenConditionOmit
    containerType?: ContainerTypeOmit
    container?: ContainerOmit
    plantCatalog?: PlantCatalogOmit
    plantGrowingCondition?: PlantGrowingConditionOmit
    plantClimateZone?: PlantClimateZoneOmit
    plantVariety?: PlantVarietyOmit
    plantCompanion?: PlantCompanionOmit
    containerPlant?: ContainerPlantOmit
    plantGrowthStage?: PlantGrowthStageOmit
    actionType?: ActionTypeOmit
    gardenAction?: GardenActionOmit
    harvest?: HarvestOmit
    containerHistory?: ContainerHistoryOmit
    plantMovementHistory?: PlantMovementHistoryOmit
    seasonalPlan?: SeasonalPlanOmit
    plannedPlanting?: PlannedPlantingOmit
    task?: TaskOmit
    taskPrerequisite?: TaskPrerequisiteOmit
    taskNote?: TaskNoteOmit
    taskCompletionLog?: TaskCompletionLogOmit
    recurringTaskPattern?: RecurringTaskPatternOmit
    taskNotification?: TaskNotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    gardens: number
    gardenActions: number
    tasks: number
    taskNotes: number
    taskCompletionLogs: number
    taskNotifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    gardens?: boolean | UserCountOutputTypeCountGardensArgs
    gardenActions?: boolean | UserCountOutputTypeCountGardenActionsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    taskNotes?: boolean | UserCountOutputTypeCountTaskNotesArgs
    taskCompletionLogs?: boolean | UserCountOutputTypeCountTaskCompletionLogsArgs
    taskNotifications?: boolean | UserCountOutputTypeCountTaskNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGardensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskCompletionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNotificationWhereInput
  }


  /**
   * Count Type GardenCountOutputType
   */

  export type GardenCountOutputType = {
    conditions: number
    containers: number
    gardenActions: number
    seasonalPlans: number
    previousContainers: number
    newContainers: number
    tasks: number
  }

  export type GardenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditions?: boolean | GardenCountOutputTypeCountConditionsArgs
    containers?: boolean | GardenCountOutputTypeCountContainersArgs
    gardenActions?: boolean | GardenCountOutputTypeCountGardenActionsArgs
    seasonalPlans?: boolean | GardenCountOutputTypeCountSeasonalPlansArgs
    previousContainers?: boolean | GardenCountOutputTypeCountPreviousContainersArgs
    newContainers?: boolean | GardenCountOutputTypeCountNewContainersArgs
    tasks?: boolean | GardenCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCountOutputType
     */
    select?: GardenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenConditionWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountGardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountSeasonalPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonalPlanWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountPreviousContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerHistoryWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountNewContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerHistoryWhereInput
  }

  /**
   * GardenCountOutputType without action
   */
  export type GardenCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ContainerTypeCountOutputType
   */

  export type ContainerTypeCountOutputType = {
    containers: number
  }

  export type ContainerTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containers?: boolean | ContainerTypeCountOutputTypeCountContainersArgs
  }

  // Custom InputTypes
  /**
   * ContainerTypeCountOutputType without action
   */
  export type ContainerTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerTypeCountOutputType
     */
    select?: ContainerTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContainerTypeCountOutputType without action
   */
  export type ContainerTypeCountOutputTypeCountContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
  }


  /**
   * Count Type ContainerCountOutputType
   */

  export type ContainerCountOutputType = {
    containerPlants: number
    gardenActions: number
    containerHistory: number
    previousContainers: number
    plannedPlantings: number
    tasks: number
  }

  export type ContainerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlants?: boolean | ContainerCountOutputTypeCountContainerPlantsArgs
    gardenActions?: boolean | ContainerCountOutputTypeCountGardenActionsArgs
    containerHistory?: boolean | ContainerCountOutputTypeCountContainerHistoryArgs
    previousContainers?: boolean | ContainerCountOutputTypeCountPreviousContainersArgs
    plannedPlantings?: boolean | ContainerCountOutputTypeCountPlannedPlantingsArgs
    tasks?: boolean | ContainerCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerCountOutputType
     */
    select?: ContainerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountContainerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerPlantWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountGardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountContainerHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerHistoryWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountPreviousContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerHistoryWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountPlannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannedPlantingWhereInput
  }

  /**
   * ContainerCountOutputType without action
   */
  export type ContainerCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type PlantCatalogCountOutputType
   */

  export type PlantCatalogCountOutputType = {
    climateZones: number
    varieties: number
    companions: number
    companionTo: number
    containerPlants: number
    plannedPlantings: number
  }

  export type PlantCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    climateZones?: boolean | PlantCatalogCountOutputTypeCountClimateZonesArgs
    varieties?: boolean | PlantCatalogCountOutputTypeCountVarietiesArgs
    companions?: boolean | PlantCatalogCountOutputTypeCountCompanionsArgs
    companionTo?: boolean | PlantCatalogCountOutputTypeCountCompanionToArgs
    containerPlants?: boolean | PlantCatalogCountOutputTypeCountContainerPlantsArgs
    plannedPlantings?: boolean | PlantCatalogCountOutputTypeCountPlannedPlantingsArgs
  }

  // Custom InputTypes
  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalogCountOutputType
     */
    select?: PlantCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountClimateZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantClimateZoneWhereInput
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountVarietiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantVarietyWhereInput
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountCompanionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantCompanionWhereInput
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountCompanionToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantCompanionWhereInput
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountContainerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerPlantWhereInput
  }

  /**
   * PlantCatalogCountOutputType without action
   */
  export type PlantCatalogCountOutputTypeCountPlannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannedPlantingWhereInput
  }


  /**
   * Count Type PlantVarietyCountOutputType
   */

  export type PlantVarietyCountOutputType = {
    containerPlants: number
    plannedPlantings: number
  }

  export type PlantVarietyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlants?: boolean | PlantVarietyCountOutputTypeCountContainerPlantsArgs
    plannedPlantings?: boolean | PlantVarietyCountOutputTypeCountPlannedPlantingsArgs
  }

  // Custom InputTypes
  /**
   * PlantVarietyCountOutputType without action
   */
  export type PlantVarietyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVarietyCountOutputType
     */
    select?: PlantVarietyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlantVarietyCountOutputType without action
   */
  export type PlantVarietyCountOutputTypeCountContainerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerPlantWhereInput
  }

  /**
   * PlantVarietyCountOutputType without action
   */
  export type PlantVarietyCountOutputTypeCountPlannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannedPlantingWhereInput
  }


  /**
   * Count Type ContainerPlantCountOutputType
   */

  export type ContainerPlantCountOutputType = {
    growthStages: number
    gardenActions: number
    harvests: number
    movementHistory: number
    tasks: number
  }

  export type ContainerPlantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    growthStages?: boolean | ContainerPlantCountOutputTypeCountGrowthStagesArgs
    gardenActions?: boolean | ContainerPlantCountOutputTypeCountGardenActionsArgs
    harvests?: boolean | ContainerPlantCountOutputTypeCountHarvestsArgs
    movementHistory?: boolean | ContainerPlantCountOutputTypeCountMovementHistoryArgs
    tasks?: boolean | ContainerPlantCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlantCountOutputType
     */
    select?: ContainerPlantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeCountGrowthStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantGrowthStageWhereInput
  }

  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeCountGardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
  }

  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeCountHarvestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HarvestWhereInput
  }

  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeCountMovementHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantMovementHistoryWhereInput
  }

  /**
   * ContainerPlantCountOutputType without action
   */
  export type ContainerPlantCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ActionTypeCountOutputType
   */

  export type ActionTypeCountOutputType = {
    actions: number
  }

  export type ActionTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | ActionTypeCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * ActionTypeCountOutputType without action
   */
  export type ActionTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionTypeCountOutputType
     */
    select?: ActionTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionTypeCountOutputType without action
   */
  export type ActionTypeCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
  }


  /**
   * Count Type SeasonalPlanCountOutputType
   */

  export type SeasonalPlanCountOutputType = {
    plantings: number
  }

  export type SeasonalPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantings?: boolean | SeasonalPlanCountOutputTypeCountPlantingsArgs
  }

  // Custom InputTypes
  /**
   * SeasonalPlanCountOutputType without action
   */
  export type SeasonalPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlanCountOutputType
     */
    select?: SeasonalPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonalPlanCountOutputType without action
   */
  export type SeasonalPlanCountOutputTypeCountPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannedPlantingWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    subtasks: number
    taskNotes: number
    taskCompletionLog: number
    notifications: number
    prerequisites: number
    dependents: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs
    taskNotes?: boolean | TaskCountOutputTypeCountTaskNotesArgs
    taskCompletionLog?: boolean | TaskCountOutputTypeCountTaskCompletionLogArgs
    notifications?: boolean | TaskCountOutputTypeCountNotificationsArgs
    prerequisites?: boolean | TaskCountOutputTypeCountPrerequisitesArgs
    dependents?: boolean | TaskCountOutputTypeCountDependentsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskCompletionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionLogWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNotificationWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskPrerequisiteWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskPrerequisiteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    gardens?: boolean | User$gardensArgs<ExtArgs>
    gardenActions?: boolean | User$gardenActionsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    taskNotes?: boolean | User$taskNotesArgs<ExtArgs>
    taskCompletionLogs?: boolean | User$taskCompletionLogsArgs<ExtArgs>
    taskNotifications?: boolean | User$taskNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    gardens?: boolean | User$gardensArgs<ExtArgs>
    gardenActions?: boolean | User$gardenActionsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    taskNotes?: boolean | User$taskNotesArgs<ExtArgs>
    taskCompletionLogs?: boolean | User$taskCompletionLogsArgs<ExtArgs>
    taskNotifications?: boolean | User$taskNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      gardens: Prisma.$GardenPayload<ExtArgs>[]
      gardenActions: Prisma.$GardenActionPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      taskNotes: Prisma.$TaskNotePayload<ExtArgs>[]
      taskCompletionLogs: Prisma.$TaskCompletionLogPayload<ExtArgs>[]
      taskNotifications: Prisma.$TaskNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gardens<T extends User$gardensArgs<ExtArgs> = {}>(args?: Subset<T, User$gardensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gardenActions<T extends User$gardenActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$gardenActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskNotes<T extends User$taskNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$taskNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskCompletionLogs<T extends User$taskCompletionLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskCompletionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskNotifications<T extends User$taskNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.gardens
   */
  export type User$gardensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    where?: GardenWhereInput
    orderBy?: GardenOrderByWithRelationInput | GardenOrderByWithRelationInput[]
    cursor?: GardenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenScalarFieldEnum | GardenScalarFieldEnum[]
  }

  /**
   * User.gardenActions
   */
  export type User$gardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    cursor?: GardenActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.taskNotes
   */
  export type User$taskNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    cursor?: TaskNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * User.taskCompletionLogs
   */
  export type User$taskCompletionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    where?: TaskCompletionLogWhereInput
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    cursor?: TaskCompletionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCompletionLogScalarFieldEnum | TaskCompletionLogScalarFieldEnum[]
  }

  /**
   * User.taskNotifications
   */
  export type User$taskNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    where?: TaskNotificationWhereInput
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    cursor?: TaskNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNotificationScalarFieldEnum | TaskNotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Garden
   */

  export type AggregateGarden = {
    _count: GardenCountAggregateOutputType | null
    _avg: GardenAvgAggregateOutputType | null
    _sum: GardenSumAggregateOutputType | null
    _min: GardenMinAggregateOutputType | null
    _max: GardenMaxAggregateOutputType | null
  }

  export type GardenAvgAggregateOutputType = {
    id: number | null
    sizeSqFeet: Decimal | null
  }

  export type GardenSumAggregateOutputType = {
    id: number | null
    sizeSqFeet: Decimal | null
  }

  export type GardenMinAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    location: string | null
    sizeSqFeet: Decimal | null
    gardenType: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GardenMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    location: string | null
    sizeSqFeet: Decimal | null
    gardenType: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GardenCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    location: number
    sizeSqFeet: number
    gardenType: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GardenAvgAggregateInputType = {
    id?: true
    sizeSqFeet?: true
  }

  export type GardenSumAggregateInputType = {
    id?: true
    sizeSqFeet?: true
  }

  export type GardenMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    location?: true
    sizeSqFeet?: true
    gardenType?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GardenMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    location?: true
    sizeSqFeet?: true
    gardenType?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GardenCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    location?: true
    sizeSqFeet?: true
    gardenType?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GardenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Garden to aggregate.
     */
    where?: GardenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardens to fetch.
     */
    orderBy?: GardenOrderByWithRelationInput | GardenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GardenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gardens
    **/
    _count?: true | GardenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GardenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GardenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GardenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GardenMaxAggregateInputType
  }

  export type GetGardenAggregateType<T extends GardenAggregateArgs> = {
        [P in keyof T & keyof AggregateGarden]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGarden[P]>
      : GetScalarType<T[P], AggregateGarden[P]>
  }




  export type GardenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenWhereInput
    orderBy?: GardenOrderByWithAggregationInput | GardenOrderByWithAggregationInput[]
    by: GardenScalarFieldEnum[] | GardenScalarFieldEnum
    having?: GardenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GardenCountAggregateInputType | true
    _avg?: GardenAvgAggregateInputType
    _sum?: GardenSumAggregateInputType
    _min?: GardenMinAggregateInputType
    _max?: GardenMaxAggregateInputType
  }

  export type GardenGroupByOutputType = {
    id: number
    userId: string
    name: string
    location: string | null
    sizeSqFeet: Decimal | null
    gardenType: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: GardenCountAggregateOutputType | null
    _avg: GardenAvgAggregateOutputType | null
    _sum: GardenSumAggregateOutputType | null
    _min: GardenMinAggregateOutputType | null
    _max: GardenMaxAggregateOutputType | null
  }

  type GetGardenGroupByPayload<T extends GardenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GardenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GardenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GardenGroupByOutputType[P]>
            : GetScalarType<T[P], GardenGroupByOutputType[P]>
        }
      >
    >


  export type GardenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    location?: boolean
    sizeSqFeet?: boolean
    gardenType?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    conditions?: boolean | Garden$conditionsArgs<ExtArgs>
    containers?: boolean | Garden$containersArgs<ExtArgs>
    gardenActions?: boolean | Garden$gardenActionsArgs<ExtArgs>
    seasonalPlans?: boolean | Garden$seasonalPlansArgs<ExtArgs>
    previousContainers?: boolean | Garden$previousContainersArgs<ExtArgs>
    newContainers?: boolean | Garden$newContainersArgs<ExtArgs>
    tasks?: boolean | Garden$tasksArgs<ExtArgs>
    _count?: boolean | GardenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["garden"]>

  export type GardenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    location?: boolean
    sizeSqFeet?: boolean
    gardenType?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["garden"]>

  export type GardenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    location?: boolean
    sizeSqFeet?: boolean
    gardenType?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["garden"]>

  export type GardenSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    location?: boolean
    sizeSqFeet?: boolean
    gardenType?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GardenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "location" | "sizeSqFeet" | "gardenType" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["garden"]>
  export type GardenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    conditions?: boolean | Garden$conditionsArgs<ExtArgs>
    containers?: boolean | Garden$containersArgs<ExtArgs>
    gardenActions?: boolean | Garden$gardenActionsArgs<ExtArgs>
    seasonalPlans?: boolean | Garden$seasonalPlansArgs<ExtArgs>
    previousContainers?: boolean | Garden$previousContainersArgs<ExtArgs>
    newContainers?: boolean | Garden$newContainersArgs<ExtArgs>
    tasks?: boolean | Garden$tasksArgs<ExtArgs>
    _count?: boolean | GardenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GardenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GardenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GardenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Garden"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      conditions: Prisma.$GardenConditionPayload<ExtArgs>[]
      containers: Prisma.$ContainerPayload<ExtArgs>[]
      gardenActions: Prisma.$GardenActionPayload<ExtArgs>[]
      seasonalPlans: Prisma.$SeasonalPlanPayload<ExtArgs>[]
      previousContainers: Prisma.$ContainerHistoryPayload<ExtArgs>[]
      newContainers: Prisma.$ContainerHistoryPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      name: string
      location: string | null
      sizeSqFeet: Prisma.Decimal | null
      gardenType: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["garden"]>
    composites: {}
  }

  type GardenGetPayload<S extends boolean | null | undefined | GardenDefaultArgs> = $Result.GetResult<Prisma.$GardenPayload, S>

  type GardenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GardenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GardenCountAggregateInputType | true
    }

  export interface GardenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Garden'], meta: { name: 'Garden' } }
    /**
     * Find zero or one Garden that matches the filter.
     * @param {GardenFindUniqueArgs} args - Arguments to find a Garden
     * @example
     * // Get one Garden
     * const garden = await prisma.garden.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GardenFindUniqueArgs>(args: SelectSubset<T, GardenFindUniqueArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Garden that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GardenFindUniqueOrThrowArgs} args - Arguments to find a Garden
     * @example
     * // Get one Garden
     * const garden = await prisma.garden.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GardenFindUniqueOrThrowArgs>(args: SelectSubset<T, GardenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Garden that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenFindFirstArgs} args - Arguments to find a Garden
     * @example
     * // Get one Garden
     * const garden = await prisma.garden.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GardenFindFirstArgs>(args?: SelectSubset<T, GardenFindFirstArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Garden that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenFindFirstOrThrowArgs} args - Arguments to find a Garden
     * @example
     * // Get one Garden
     * const garden = await prisma.garden.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GardenFindFirstOrThrowArgs>(args?: SelectSubset<T, GardenFindFirstOrThrowArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gardens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gardens
     * const gardens = await prisma.garden.findMany()
     * 
     * // Get first 10 Gardens
     * const gardens = await prisma.garden.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gardenWithIdOnly = await prisma.garden.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GardenFindManyArgs>(args?: SelectSubset<T, GardenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Garden.
     * @param {GardenCreateArgs} args - Arguments to create a Garden.
     * @example
     * // Create one Garden
     * const Garden = await prisma.garden.create({
     *   data: {
     *     // ... data to create a Garden
     *   }
     * })
     * 
     */
    create<T extends GardenCreateArgs>(args: SelectSubset<T, GardenCreateArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gardens.
     * @param {GardenCreateManyArgs} args - Arguments to create many Gardens.
     * @example
     * // Create many Gardens
     * const garden = await prisma.garden.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GardenCreateManyArgs>(args?: SelectSubset<T, GardenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gardens and returns the data saved in the database.
     * @param {GardenCreateManyAndReturnArgs} args - Arguments to create many Gardens.
     * @example
     * // Create many Gardens
     * const garden = await prisma.garden.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gardens and only return the `id`
     * const gardenWithIdOnly = await prisma.garden.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GardenCreateManyAndReturnArgs>(args?: SelectSubset<T, GardenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Garden.
     * @param {GardenDeleteArgs} args - Arguments to delete one Garden.
     * @example
     * // Delete one Garden
     * const Garden = await prisma.garden.delete({
     *   where: {
     *     // ... filter to delete one Garden
     *   }
     * })
     * 
     */
    delete<T extends GardenDeleteArgs>(args: SelectSubset<T, GardenDeleteArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Garden.
     * @param {GardenUpdateArgs} args - Arguments to update one Garden.
     * @example
     * // Update one Garden
     * const garden = await prisma.garden.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GardenUpdateArgs>(args: SelectSubset<T, GardenUpdateArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gardens.
     * @param {GardenDeleteManyArgs} args - Arguments to filter Gardens to delete.
     * @example
     * // Delete a few Gardens
     * const { count } = await prisma.garden.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GardenDeleteManyArgs>(args?: SelectSubset<T, GardenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gardens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gardens
     * const garden = await prisma.garden.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GardenUpdateManyArgs>(args: SelectSubset<T, GardenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gardens and returns the data updated in the database.
     * @param {GardenUpdateManyAndReturnArgs} args - Arguments to update many Gardens.
     * @example
     * // Update many Gardens
     * const garden = await prisma.garden.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gardens and only return the `id`
     * const gardenWithIdOnly = await prisma.garden.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GardenUpdateManyAndReturnArgs>(args: SelectSubset<T, GardenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Garden.
     * @param {GardenUpsertArgs} args - Arguments to update or create a Garden.
     * @example
     * // Update or create a Garden
     * const garden = await prisma.garden.upsert({
     *   create: {
     *     // ... data to create a Garden
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Garden we want to update
     *   }
     * })
     */
    upsert<T extends GardenUpsertArgs>(args: SelectSubset<T, GardenUpsertArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gardens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenCountArgs} args - Arguments to filter Gardens to count.
     * @example
     * // Count the number of Gardens
     * const count = await prisma.garden.count({
     *   where: {
     *     // ... the filter for the Gardens we want to count
     *   }
     * })
    **/
    count<T extends GardenCountArgs>(
      args?: Subset<T, GardenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GardenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Garden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GardenAggregateArgs>(args: Subset<T, GardenAggregateArgs>): Prisma.PrismaPromise<GetGardenAggregateType<T>>

    /**
     * Group by Garden.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GardenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GardenGroupByArgs['orderBy'] }
        : { orderBy?: GardenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GardenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGardenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Garden model
   */
  readonly fields: GardenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Garden.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GardenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conditions<T extends Garden$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, Garden$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    containers<T extends Garden$containersArgs<ExtArgs> = {}>(args?: Subset<T, Garden$containersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gardenActions<T extends Garden$gardenActionsArgs<ExtArgs> = {}>(args?: Subset<T, Garden$gardenActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seasonalPlans<T extends Garden$seasonalPlansArgs<ExtArgs> = {}>(args?: Subset<T, Garden$seasonalPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previousContainers<T extends Garden$previousContainersArgs<ExtArgs> = {}>(args?: Subset<T, Garden$previousContainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    newContainers<T extends Garden$newContainersArgs<ExtArgs> = {}>(args?: Subset<T, Garden$newContainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Garden$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Garden$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Garden model
   */
  interface GardenFieldRefs {
    readonly id: FieldRef<"Garden", 'Int'>
    readonly userId: FieldRef<"Garden", 'String'>
    readonly name: FieldRef<"Garden", 'String'>
    readonly location: FieldRef<"Garden", 'String'>
    readonly sizeSqFeet: FieldRef<"Garden", 'Decimal'>
    readonly gardenType: FieldRef<"Garden", 'String'>
    readonly description: FieldRef<"Garden", 'String'>
    readonly createdAt: FieldRef<"Garden", 'DateTime'>
    readonly updatedAt: FieldRef<"Garden", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Garden findUnique
   */
  export type GardenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter, which Garden to fetch.
     */
    where: GardenWhereUniqueInput
  }

  /**
   * Garden findUniqueOrThrow
   */
  export type GardenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter, which Garden to fetch.
     */
    where: GardenWhereUniqueInput
  }

  /**
   * Garden findFirst
   */
  export type GardenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter, which Garden to fetch.
     */
    where?: GardenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardens to fetch.
     */
    orderBy?: GardenOrderByWithRelationInput | GardenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gardens.
     */
    cursor?: GardenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gardens.
     */
    distinct?: GardenScalarFieldEnum | GardenScalarFieldEnum[]
  }

  /**
   * Garden findFirstOrThrow
   */
  export type GardenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter, which Garden to fetch.
     */
    where?: GardenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardens to fetch.
     */
    orderBy?: GardenOrderByWithRelationInput | GardenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gardens.
     */
    cursor?: GardenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gardens.
     */
    distinct?: GardenScalarFieldEnum | GardenScalarFieldEnum[]
  }

  /**
   * Garden findMany
   */
  export type GardenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter, which Gardens to fetch.
     */
    where?: GardenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardens to fetch.
     */
    orderBy?: GardenOrderByWithRelationInput | GardenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gardens.
     */
    cursor?: GardenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardens.
     */
    skip?: number
    distinct?: GardenScalarFieldEnum | GardenScalarFieldEnum[]
  }

  /**
   * Garden create
   */
  export type GardenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * The data needed to create a Garden.
     */
    data: XOR<GardenCreateInput, GardenUncheckedCreateInput>
  }

  /**
   * Garden createMany
   */
  export type GardenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gardens.
     */
    data: GardenCreateManyInput | GardenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Garden createManyAndReturn
   */
  export type GardenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * The data used to create many Gardens.
     */
    data: GardenCreateManyInput | GardenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Garden update
   */
  export type GardenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * The data needed to update a Garden.
     */
    data: XOR<GardenUpdateInput, GardenUncheckedUpdateInput>
    /**
     * Choose, which Garden to update.
     */
    where: GardenWhereUniqueInput
  }

  /**
   * Garden updateMany
   */
  export type GardenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gardens.
     */
    data: XOR<GardenUpdateManyMutationInput, GardenUncheckedUpdateManyInput>
    /**
     * Filter which Gardens to update
     */
    where?: GardenWhereInput
    /**
     * Limit how many Gardens to update.
     */
    limit?: number
  }

  /**
   * Garden updateManyAndReturn
   */
  export type GardenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * The data used to update Gardens.
     */
    data: XOR<GardenUpdateManyMutationInput, GardenUncheckedUpdateManyInput>
    /**
     * Filter which Gardens to update
     */
    where?: GardenWhereInput
    /**
     * Limit how many Gardens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Garden upsert
   */
  export type GardenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * The filter to search for the Garden to update in case it exists.
     */
    where: GardenWhereUniqueInput
    /**
     * In case the Garden found by the `where` argument doesn't exist, create a new Garden with this data.
     */
    create: XOR<GardenCreateInput, GardenUncheckedCreateInput>
    /**
     * In case the Garden was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GardenUpdateInput, GardenUncheckedUpdateInput>
  }

  /**
   * Garden delete
   */
  export type GardenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    /**
     * Filter which Garden to delete.
     */
    where: GardenWhereUniqueInput
  }

  /**
   * Garden deleteMany
   */
  export type GardenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gardens to delete
     */
    where?: GardenWhereInput
    /**
     * Limit how many Gardens to delete.
     */
    limit?: number
  }

  /**
   * Garden.conditions
   */
  export type Garden$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    where?: GardenConditionWhereInput
    orderBy?: GardenConditionOrderByWithRelationInput | GardenConditionOrderByWithRelationInput[]
    cursor?: GardenConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenConditionScalarFieldEnum | GardenConditionScalarFieldEnum[]
  }

  /**
   * Garden.containers
   */
  export type Garden$containersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    cursor?: ContainerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Garden.gardenActions
   */
  export type Garden$gardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    cursor?: GardenActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * Garden.seasonalPlans
   */
  export type Garden$seasonalPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    where?: SeasonalPlanWhereInput
    orderBy?: SeasonalPlanOrderByWithRelationInput | SeasonalPlanOrderByWithRelationInput[]
    cursor?: SeasonalPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonalPlanScalarFieldEnum | SeasonalPlanScalarFieldEnum[]
  }

  /**
   * Garden.previousContainers
   */
  export type Garden$previousContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    where?: ContainerHistoryWhereInput
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    cursor?: ContainerHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * Garden.newContainers
   */
  export type Garden$newContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    where?: ContainerHistoryWhereInput
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    cursor?: ContainerHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * Garden.tasks
   */
  export type Garden$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Garden without action
   */
  export type GardenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
  }


  /**
   * Model GardenCondition
   */

  export type AggregateGardenCondition = {
    _count: GardenConditionCountAggregateOutputType | null
    _avg: GardenConditionAvgAggregateOutputType | null
    _sum: GardenConditionSumAggregateOutputType | null
    _min: GardenConditionMinAggregateOutputType | null
    _max: GardenConditionMaxAggregateOutputType | null
  }

  export type GardenConditionAvgAggregateOutputType = {
    id: number | null
    gardenId: number | null
    avgTemperatureF: Decimal | null
    humidityPct: number | null
    annualRainfall: Decimal | null
  }

  export type GardenConditionSumAggregateOutputType = {
    id: number | null
    gardenId: number | null
    avgTemperatureF: Decimal | null
    humidityPct: number | null
    annualRainfall: Decimal | null
  }

  export type GardenConditionMinAggregateOutputType = {
    id: number | null
    gardenId: number | null
    climateZone: string | null
    sunlightExposure: string | null
    avgTemperatureF: Decimal | null
    humidityPct: number | null
    soilType: string | null
    annualRainfall: Decimal | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GardenConditionMaxAggregateOutputType = {
    id: number | null
    gardenId: number | null
    climateZone: string | null
    sunlightExposure: string | null
    avgTemperatureF: Decimal | null
    humidityPct: number | null
    soilType: string | null
    annualRainfall: Decimal | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GardenConditionCountAggregateOutputType = {
    id: number
    gardenId: number
    climateZone: number
    sunlightExposure: number
    avgTemperatureF: number
    humidityPct: number
    soilType: number
    annualRainfall: number
    additionalNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GardenConditionAvgAggregateInputType = {
    id?: true
    gardenId?: true
    avgTemperatureF?: true
    humidityPct?: true
    annualRainfall?: true
  }

  export type GardenConditionSumAggregateInputType = {
    id?: true
    gardenId?: true
    avgTemperatureF?: true
    humidityPct?: true
    annualRainfall?: true
  }

  export type GardenConditionMinAggregateInputType = {
    id?: true
    gardenId?: true
    climateZone?: true
    sunlightExposure?: true
    avgTemperatureF?: true
    humidityPct?: true
    soilType?: true
    annualRainfall?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GardenConditionMaxAggregateInputType = {
    id?: true
    gardenId?: true
    climateZone?: true
    sunlightExposure?: true
    avgTemperatureF?: true
    humidityPct?: true
    soilType?: true
    annualRainfall?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GardenConditionCountAggregateInputType = {
    id?: true
    gardenId?: true
    climateZone?: true
    sunlightExposure?: true
    avgTemperatureF?: true
    humidityPct?: true
    soilType?: true
    annualRainfall?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GardenConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GardenCondition to aggregate.
     */
    where?: GardenConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenConditions to fetch.
     */
    orderBy?: GardenConditionOrderByWithRelationInput | GardenConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GardenConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GardenConditions
    **/
    _count?: true | GardenConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GardenConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GardenConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GardenConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GardenConditionMaxAggregateInputType
  }

  export type GetGardenConditionAggregateType<T extends GardenConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateGardenCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGardenCondition[P]>
      : GetScalarType<T[P], AggregateGardenCondition[P]>
  }




  export type GardenConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenConditionWhereInput
    orderBy?: GardenConditionOrderByWithAggregationInput | GardenConditionOrderByWithAggregationInput[]
    by: GardenConditionScalarFieldEnum[] | GardenConditionScalarFieldEnum
    having?: GardenConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GardenConditionCountAggregateInputType | true
    _avg?: GardenConditionAvgAggregateInputType
    _sum?: GardenConditionSumAggregateInputType
    _min?: GardenConditionMinAggregateInputType
    _max?: GardenConditionMaxAggregateInputType
  }

  export type GardenConditionGroupByOutputType = {
    id: number
    gardenId: number
    climateZone: string | null
    sunlightExposure: string | null
    avgTemperatureF: Decimal | null
    humidityPct: number | null
    soilType: string | null
    annualRainfall: Decimal | null
    additionalNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: GardenConditionCountAggregateOutputType | null
    _avg: GardenConditionAvgAggregateOutputType | null
    _sum: GardenConditionSumAggregateOutputType | null
    _min: GardenConditionMinAggregateOutputType | null
    _max: GardenConditionMaxAggregateOutputType | null
  }

  type GetGardenConditionGroupByPayload<T extends GardenConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GardenConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GardenConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GardenConditionGroupByOutputType[P]>
            : GetScalarType<T[P], GardenConditionGroupByOutputType[P]>
        }
      >
    >


  export type GardenConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    climateZone?: boolean
    sunlightExposure?: boolean
    avgTemperatureF?: boolean
    humidityPct?: boolean
    soilType?: boolean
    annualRainfall?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gardenCondition"]>

  export type GardenConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    climateZone?: boolean
    sunlightExposure?: boolean
    avgTemperatureF?: boolean
    humidityPct?: boolean
    soilType?: boolean
    annualRainfall?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gardenCondition"]>

  export type GardenConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    climateZone?: boolean
    sunlightExposure?: boolean
    avgTemperatureF?: boolean
    humidityPct?: boolean
    soilType?: boolean
    annualRainfall?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gardenCondition"]>

  export type GardenConditionSelectScalar = {
    id?: boolean
    gardenId?: boolean
    climateZone?: boolean
    sunlightExposure?: boolean
    avgTemperatureF?: boolean
    humidityPct?: boolean
    soilType?: boolean
    annualRainfall?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GardenConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gardenId" | "climateZone" | "sunlightExposure" | "avgTemperatureF" | "humidityPct" | "soilType" | "annualRainfall" | "additionalNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["gardenCondition"]>
  export type GardenConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }
  export type GardenConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }
  export type GardenConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }

  export type $GardenConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GardenCondition"
    objects: {
      garden: Prisma.$GardenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gardenId: number
      climateZone: string | null
      sunlightExposure: string | null
      avgTemperatureF: Prisma.Decimal | null
      humidityPct: number | null
      soilType: string | null
      annualRainfall: Prisma.Decimal | null
      additionalNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gardenCondition"]>
    composites: {}
  }

  type GardenConditionGetPayload<S extends boolean | null | undefined | GardenConditionDefaultArgs> = $Result.GetResult<Prisma.$GardenConditionPayload, S>

  type GardenConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GardenConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GardenConditionCountAggregateInputType | true
    }

  export interface GardenConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GardenCondition'], meta: { name: 'GardenCondition' } }
    /**
     * Find zero or one GardenCondition that matches the filter.
     * @param {GardenConditionFindUniqueArgs} args - Arguments to find a GardenCondition
     * @example
     * // Get one GardenCondition
     * const gardenCondition = await prisma.gardenCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GardenConditionFindUniqueArgs>(args: SelectSubset<T, GardenConditionFindUniqueArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GardenCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GardenConditionFindUniqueOrThrowArgs} args - Arguments to find a GardenCondition
     * @example
     * // Get one GardenCondition
     * const gardenCondition = await prisma.gardenCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GardenConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, GardenConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GardenCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionFindFirstArgs} args - Arguments to find a GardenCondition
     * @example
     * // Get one GardenCondition
     * const gardenCondition = await prisma.gardenCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GardenConditionFindFirstArgs>(args?: SelectSubset<T, GardenConditionFindFirstArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GardenCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionFindFirstOrThrowArgs} args - Arguments to find a GardenCondition
     * @example
     * // Get one GardenCondition
     * const gardenCondition = await prisma.gardenCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GardenConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, GardenConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GardenConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GardenConditions
     * const gardenConditions = await prisma.gardenCondition.findMany()
     * 
     * // Get first 10 GardenConditions
     * const gardenConditions = await prisma.gardenCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gardenConditionWithIdOnly = await prisma.gardenCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GardenConditionFindManyArgs>(args?: SelectSubset<T, GardenConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GardenCondition.
     * @param {GardenConditionCreateArgs} args - Arguments to create a GardenCondition.
     * @example
     * // Create one GardenCondition
     * const GardenCondition = await prisma.gardenCondition.create({
     *   data: {
     *     // ... data to create a GardenCondition
     *   }
     * })
     * 
     */
    create<T extends GardenConditionCreateArgs>(args: SelectSubset<T, GardenConditionCreateArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GardenConditions.
     * @param {GardenConditionCreateManyArgs} args - Arguments to create many GardenConditions.
     * @example
     * // Create many GardenConditions
     * const gardenCondition = await prisma.gardenCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GardenConditionCreateManyArgs>(args?: SelectSubset<T, GardenConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GardenConditions and returns the data saved in the database.
     * @param {GardenConditionCreateManyAndReturnArgs} args - Arguments to create many GardenConditions.
     * @example
     * // Create many GardenConditions
     * const gardenCondition = await prisma.gardenCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GardenConditions and only return the `id`
     * const gardenConditionWithIdOnly = await prisma.gardenCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GardenConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, GardenConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GardenCondition.
     * @param {GardenConditionDeleteArgs} args - Arguments to delete one GardenCondition.
     * @example
     * // Delete one GardenCondition
     * const GardenCondition = await prisma.gardenCondition.delete({
     *   where: {
     *     // ... filter to delete one GardenCondition
     *   }
     * })
     * 
     */
    delete<T extends GardenConditionDeleteArgs>(args: SelectSubset<T, GardenConditionDeleteArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GardenCondition.
     * @param {GardenConditionUpdateArgs} args - Arguments to update one GardenCondition.
     * @example
     * // Update one GardenCondition
     * const gardenCondition = await prisma.gardenCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GardenConditionUpdateArgs>(args: SelectSubset<T, GardenConditionUpdateArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GardenConditions.
     * @param {GardenConditionDeleteManyArgs} args - Arguments to filter GardenConditions to delete.
     * @example
     * // Delete a few GardenConditions
     * const { count } = await prisma.gardenCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GardenConditionDeleteManyArgs>(args?: SelectSubset<T, GardenConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GardenConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GardenConditions
     * const gardenCondition = await prisma.gardenCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GardenConditionUpdateManyArgs>(args: SelectSubset<T, GardenConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GardenConditions and returns the data updated in the database.
     * @param {GardenConditionUpdateManyAndReturnArgs} args - Arguments to update many GardenConditions.
     * @example
     * // Update many GardenConditions
     * const gardenCondition = await prisma.gardenCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GardenConditions and only return the `id`
     * const gardenConditionWithIdOnly = await prisma.gardenCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GardenConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, GardenConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GardenCondition.
     * @param {GardenConditionUpsertArgs} args - Arguments to update or create a GardenCondition.
     * @example
     * // Update or create a GardenCondition
     * const gardenCondition = await prisma.gardenCondition.upsert({
     *   create: {
     *     // ... data to create a GardenCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GardenCondition we want to update
     *   }
     * })
     */
    upsert<T extends GardenConditionUpsertArgs>(args: SelectSubset<T, GardenConditionUpsertArgs<ExtArgs>>): Prisma__GardenConditionClient<$Result.GetResult<Prisma.$GardenConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GardenConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionCountArgs} args - Arguments to filter GardenConditions to count.
     * @example
     * // Count the number of GardenConditions
     * const count = await prisma.gardenCondition.count({
     *   where: {
     *     // ... the filter for the GardenConditions we want to count
     *   }
     * })
    **/
    count<T extends GardenConditionCountArgs>(
      args?: Subset<T, GardenConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GardenConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GardenCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GardenConditionAggregateArgs>(args: Subset<T, GardenConditionAggregateArgs>): Prisma.PrismaPromise<GetGardenConditionAggregateType<T>>

    /**
     * Group by GardenCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GardenConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GardenConditionGroupByArgs['orderBy'] }
        : { orderBy?: GardenConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GardenConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGardenConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GardenCondition model
   */
  readonly fields: GardenConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GardenCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GardenConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    garden<T extends GardenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GardenDefaultArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GardenCondition model
   */
  interface GardenConditionFieldRefs {
    readonly id: FieldRef<"GardenCondition", 'Int'>
    readonly gardenId: FieldRef<"GardenCondition", 'Int'>
    readonly climateZone: FieldRef<"GardenCondition", 'String'>
    readonly sunlightExposure: FieldRef<"GardenCondition", 'String'>
    readonly avgTemperatureF: FieldRef<"GardenCondition", 'Decimal'>
    readonly humidityPct: FieldRef<"GardenCondition", 'Int'>
    readonly soilType: FieldRef<"GardenCondition", 'String'>
    readonly annualRainfall: FieldRef<"GardenCondition", 'Decimal'>
    readonly additionalNotes: FieldRef<"GardenCondition", 'String'>
    readonly createdAt: FieldRef<"GardenCondition", 'DateTime'>
    readonly updatedAt: FieldRef<"GardenCondition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GardenCondition findUnique
   */
  export type GardenConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter, which GardenCondition to fetch.
     */
    where: GardenConditionWhereUniqueInput
  }

  /**
   * GardenCondition findUniqueOrThrow
   */
  export type GardenConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter, which GardenCondition to fetch.
     */
    where: GardenConditionWhereUniqueInput
  }

  /**
   * GardenCondition findFirst
   */
  export type GardenConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter, which GardenCondition to fetch.
     */
    where?: GardenConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenConditions to fetch.
     */
    orderBy?: GardenConditionOrderByWithRelationInput | GardenConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GardenConditions.
     */
    cursor?: GardenConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GardenConditions.
     */
    distinct?: GardenConditionScalarFieldEnum | GardenConditionScalarFieldEnum[]
  }

  /**
   * GardenCondition findFirstOrThrow
   */
  export type GardenConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter, which GardenCondition to fetch.
     */
    where?: GardenConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenConditions to fetch.
     */
    orderBy?: GardenConditionOrderByWithRelationInput | GardenConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GardenConditions.
     */
    cursor?: GardenConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GardenConditions.
     */
    distinct?: GardenConditionScalarFieldEnum | GardenConditionScalarFieldEnum[]
  }

  /**
   * GardenCondition findMany
   */
  export type GardenConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter, which GardenConditions to fetch.
     */
    where?: GardenConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenConditions to fetch.
     */
    orderBy?: GardenConditionOrderByWithRelationInput | GardenConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GardenConditions.
     */
    cursor?: GardenConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenConditions.
     */
    skip?: number
    distinct?: GardenConditionScalarFieldEnum | GardenConditionScalarFieldEnum[]
  }

  /**
   * GardenCondition create
   */
  export type GardenConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a GardenCondition.
     */
    data: XOR<GardenConditionCreateInput, GardenConditionUncheckedCreateInput>
  }

  /**
   * GardenCondition createMany
   */
  export type GardenConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GardenConditions.
     */
    data: GardenConditionCreateManyInput | GardenConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GardenCondition createManyAndReturn
   */
  export type GardenConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * The data used to create many GardenConditions.
     */
    data: GardenConditionCreateManyInput | GardenConditionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GardenCondition update
   */
  export type GardenConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a GardenCondition.
     */
    data: XOR<GardenConditionUpdateInput, GardenConditionUncheckedUpdateInput>
    /**
     * Choose, which GardenCondition to update.
     */
    where: GardenConditionWhereUniqueInput
  }

  /**
   * GardenCondition updateMany
   */
  export type GardenConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GardenConditions.
     */
    data: XOR<GardenConditionUpdateManyMutationInput, GardenConditionUncheckedUpdateManyInput>
    /**
     * Filter which GardenConditions to update
     */
    where?: GardenConditionWhereInput
    /**
     * Limit how many GardenConditions to update.
     */
    limit?: number
  }

  /**
   * GardenCondition updateManyAndReturn
   */
  export type GardenConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * The data used to update GardenConditions.
     */
    data: XOR<GardenConditionUpdateManyMutationInput, GardenConditionUncheckedUpdateManyInput>
    /**
     * Filter which GardenConditions to update
     */
    where?: GardenConditionWhereInput
    /**
     * Limit how many GardenConditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GardenCondition upsert
   */
  export type GardenConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the GardenCondition to update in case it exists.
     */
    where: GardenConditionWhereUniqueInput
    /**
     * In case the GardenCondition found by the `where` argument doesn't exist, create a new GardenCondition with this data.
     */
    create: XOR<GardenConditionCreateInput, GardenConditionUncheckedCreateInput>
    /**
     * In case the GardenCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GardenConditionUpdateInput, GardenConditionUncheckedUpdateInput>
  }

  /**
   * GardenCondition delete
   */
  export type GardenConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
    /**
     * Filter which GardenCondition to delete.
     */
    where: GardenConditionWhereUniqueInput
  }

  /**
   * GardenCondition deleteMany
   */
  export type GardenConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GardenConditions to delete
     */
    where?: GardenConditionWhereInput
    /**
     * Limit how many GardenConditions to delete.
     */
    limit?: number
  }

  /**
   * GardenCondition without action
   */
  export type GardenConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenCondition
     */
    select?: GardenConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenCondition
     */
    omit?: GardenConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenConditionInclude<ExtArgs> | null
  }


  /**
   * Model ContainerType
   */

  export type AggregateContainerType = {
    _count: ContainerTypeCountAggregateOutputType | null
    _avg: ContainerTypeAvgAggregateOutputType | null
    _sum: ContainerTypeSumAggregateOutputType | null
    _min: ContainerTypeMinAggregateOutputType | null
    _max: ContainerTypeMaxAggregateOutputType | null
  }

  export type ContainerTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ContainerTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ContainerTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    typicalDimensions: string | null
  }

  export type ContainerTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    typicalDimensions: string | null
  }

  export type ContainerTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    typicalDimensions: number
    _all: number
  }


  export type ContainerTypeAvgAggregateInputType = {
    id?: true
  }

  export type ContainerTypeSumAggregateInputType = {
    id?: true
  }

  export type ContainerTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    typicalDimensions?: true
  }

  export type ContainerTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    typicalDimensions?: true
  }

  export type ContainerTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    typicalDimensions?: true
    _all?: true
  }

  export type ContainerTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerType to aggregate.
     */
    where?: ContainerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerTypes to fetch.
     */
    orderBy?: ContainerTypeOrderByWithRelationInput | ContainerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContainerTypes
    **/
    _count?: true | ContainerTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerTypeMaxAggregateInputType
  }

  export type GetContainerTypeAggregateType<T extends ContainerTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContainerType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainerType[P]>
      : GetScalarType<T[P], AggregateContainerType[P]>
  }




  export type ContainerTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerTypeWhereInput
    orderBy?: ContainerTypeOrderByWithAggregationInput | ContainerTypeOrderByWithAggregationInput[]
    by: ContainerTypeScalarFieldEnum[] | ContainerTypeScalarFieldEnum
    having?: ContainerTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerTypeCountAggregateInputType | true
    _avg?: ContainerTypeAvgAggregateInputType
    _sum?: ContainerTypeSumAggregateInputType
    _min?: ContainerTypeMinAggregateInputType
    _max?: ContainerTypeMaxAggregateInputType
  }

  export type ContainerTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    typicalDimensions: string | null
    _count: ContainerTypeCountAggregateOutputType | null
    _avg: ContainerTypeAvgAggregateOutputType | null
    _sum: ContainerTypeSumAggregateOutputType | null
    _min: ContainerTypeMinAggregateOutputType | null
    _max: ContainerTypeMaxAggregateOutputType | null
  }

  type GetContainerTypeGroupByPayload<T extends ContainerTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContainerTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    typicalDimensions?: boolean
    containers?: boolean | ContainerType$containersArgs<ExtArgs>
    _count?: boolean | ContainerTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["containerType"]>

  export type ContainerTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    typicalDimensions?: boolean
  }, ExtArgs["result"]["containerType"]>

  export type ContainerTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    typicalDimensions?: boolean
  }, ExtArgs["result"]["containerType"]>

  export type ContainerTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    typicalDimensions?: boolean
  }

  export type ContainerTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "typicalDimensions", ExtArgs["result"]["containerType"]>
  export type ContainerTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containers?: boolean | ContainerType$containersArgs<ExtArgs>
    _count?: boolean | ContainerTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContainerTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContainerTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContainerTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContainerType"
    objects: {
      containers: Prisma.$ContainerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      typicalDimensions: string | null
    }, ExtArgs["result"]["containerType"]>
    composites: {}
  }

  type ContainerTypeGetPayload<S extends boolean | null | undefined | ContainerTypeDefaultArgs> = $Result.GetResult<Prisma.$ContainerTypePayload, S>

  type ContainerTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContainerTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContainerTypeCountAggregateInputType | true
    }

  export interface ContainerTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContainerType'], meta: { name: 'ContainerType' } }
    /**
     * Find zero or one ContainerType that matches the filter.
     * @param {ContainerTypeFindUniqueArgs} args - Arguments to find a ContainerType
     * @example
     * // Get one ContainerType
     * const containerType = await prisma.containerType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerTypeFindUniqueArgs>(args: SelectSubset<T, ContainerTypeFindUniqueArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContainerType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContainerTypeFindUniqueOrThrowArgs} args - Arguments to find a ContainerType
     * @example
     * // Get one ContainerType
     * const containerType = await prisma.containerType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeFindFirstArgs} args - Arguments to find a ContainerType
     * @example
     * // Get one ContainerType
     * const containerType = await prisma.containerType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerTypeFindFirstArgs>(args?: SelectSubset<T, ContainerTypeFindFirstArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeFindFirstOrThrowArgs} args - Arguments to find a ContainerType
     * @example
     * // Get one ContainerType
     * const containerType = await prisma.containerType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContainerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContainerTypes
     * const containerTypes = await prisma.containerType.findMany()
     * 
     * // Get first 10 ContainerTypes
     * const containerTypes = await prisma.containerType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerTypeWithIdOnly = await prisma.containerType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerTypeFindManyArgs>(args?: SelectSubset<T, ContainerTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContainerType.
     * @param {ContainerTypeCreateArgs} args - Arguments to create a ContainerType.
     * @example
     * // Create one ContainerType
     * const ContainerType = await prisma.containerType.create({
     *   data: {
     *     // ... data to create a ContainerType
     *   }
     * })
     * 
     */
    create<T extends ContainerTypeCreateArgs>(args: SelectSubset<T, ContainerTypeCreateArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContainerTypes.
     * @param {ContainerTypeCreateManyArgs} args - Arguments to create many ContainerTypes.
     * @example
     * // Create many ContainerTypes
     * const containerType = await prisma.containerType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerTypeCreateManyArgs>(args?: SelectSubset<T, ContainerTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContainerTypes and returns the data saved in the database.
     * @param {ContainerTypeCreateManyAndReturnArgs} args - Arguments to create many ContainerTypes.
     * @example
     * // Create many ContainerTypes
     * const containerType = await prisma.containerType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContainerTypes and only return the `id`
     * const containerTypeWithIdOnly = await prisma.containerType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContainerType.
     * @param {ContainerTypeDeleteArgs} args - Arguments to delete one ContainerType.
     * @example
     * // Delete one ContainerType
     * const ContainerType = await prisma.containerType.delete({
     *   where: {
     *     // ... filter to delete one ContainerType
     *   }
     * })
     * 
     */
    delete<T extends ContainerTypeDeleteArgs>(args: SelectSubset<T, ContainerTypeDeleteArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContainerType.
     * @param {ContainerTypeUpdateArgs} args - Arguments to update one ContainerType.
     * @example
     * // Update one ContainerType
     * const containerType = await prisma.containerType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerTypeUpdateArgs>(args: SelectSubset<T, ContainerTypeUpdateArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContainerTypes.
     * @param {ContainerTypeDeleteManyArgs} args - Arguments to filter ContainerTypes to delete.
     * @example
     * // Delete a few ContainerTypes
     * const { count } = await prisma.containerType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerTypeDeleteManyArgs>(args?: SelectSubset<T, ContainerTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContainerTypes
     * const containerType = await prisma.containerType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerTypeUpdateManyArgs>(args: SelectSubset<T, ContainerTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerTypes and returns the data updated in the database.
     * @param {ContainerTypeUpdateManyAndReturnArgs} args - Arguments to update many ContainerTypes.
     * @example
     * // Update many ContainerTypes
     * const containerType = await prisma.containerType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContainerTypes and only return the `id`
     * const containerTypeWithIdOnly = await prisma.containerType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContainerTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ContainerTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContainerType.
     * @param {ContainerTypeUpsertArgs} args - Arguments to update or create a ContainerType.
     * @example
     * // Update or create a ContainerType
     * const containerType = await prisma.containerType.upsert({
     *   create: {
     *     // ... data to create a ContainerType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContainerType we want to update
     *   }
     * })
     */
    upsert<T extends ContainerTypeUpsertArgs>(args: SelectSubset<T, ContainerTypeUpsertArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContainerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeCountArgs} args - Arguments to filter ContainerTypes to count.
     * @example
     * // Count the number of ContainerTypes
     * const count = await prisma.containerType.count({
     *   where: {
     *     // ... the filter for the ContainerTypes we want to count
     *   }
     * })
    **/
    count<T extends ContainerTypeCountArgs>(
      args?: Subset<T, ContainerTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContainerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerTypeAggregateArgs>(args: Subset<T, ContainerTypeAggregateArgs>): Prisma.PrismaPromise<GetContainerTypeAggregateType<T>>

    /**
     * Group by ContainerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContainerTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContainerType model
   */
  readonly fields: ContainerTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContainerType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containers<T extends ContainerType$containersArgs<ExtArgs> = {}>(args?: Subset<T, ContainerType$containersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContainerType model
   */
  interface ContainerTypeFieldRefs {
    readonly id: FieldRef<"ContainerType", 'Int'>
    readonly name: FieldRef<"ContainerType", 'String'>
    readonly description: FieldRef<"ContainerType", 'String'>
    readonly typicalDimensions: FieldRef<"ContainerType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContainerType findUnique
   */
  export type ContainerTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContainerType to fetch.
     */
    where: ContainerTypeWhereUniqueInput
  }

  /**
   * ContainerType findUniqueOrThrow
   */
  export type ContainerTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContainerType to fetch.
     */
    where: ContainerTypeWhereUniqueInput
  }

  /**
   * ContainerType findFirst
   */
  export type ContainerTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContainerType to fetch.
     */
    where?: ContainerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerTypes to fetch.
     */
    orderBy?: ContainerTypeOrderByWithRelationInput | ContainerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerTypes.
     */
    cursor?: ContainerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerTypes.
     */
    distinct?: ContainerTypeScalarFieldEnum | ContainerTypeScalarFieldEnum[]
  }

  /**
   * ContainerType findFirstOrThrow
   */
  export type ContainerTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContainerType to fetch.
     */
    where?: ContainerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerTypes to fetch.
     */
    orderBy?: ContainerTypeOrderByWithRelationInput | ContainerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerTypes.
     */
    cursor?: ContainerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerTypes.
     */
    distinct?: ContainerTypeScalarFieldEnum | ContainerTypeScalarFieldEnum[]
  }

  /**
   * ContainerType findMany
   */
  export type ContainerTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContainerTypes to fetch.
     */
    where?: ContainerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerTypes to fetch.
     */
    orderBy?: ContainerTypeOrderByWithRelationInput | ContainerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContainerTypes.
     */
    cursor?: ContainerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerTypes.
     */
    skip?: number
    distinct?: ContainerTypeScalarFieldEnum | ContainerTypeScalarFieldEnum[]
  }

  /**
   * ContainerType create
   */
  export type ContainerTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContainerType.
     */
    data: XOR<ContainerTypeCreateInput, ContainerTypeUncheckedCreateInput>
  }

  /**
   * ContainerType createMany
   */
  export type ContainerTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContainerTypes.
     */
    data: ContainerTypeCreateManyInput | ContainerTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerType createManyAndReturn
   */
  export type ContainerTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ContainerTypes.
     */
    data: ContainerTypeCreateManyInput | ContainerTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerType update
   */
  export type ContainerTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContainerType.
     */
    data: XOR<ContainerTypeUpdateInput, ContainerTypeUncheckedUpdateInput>
    /**
     * Choose, which ContainerType to update.
     */
    where: ContainerTypeWhereUniqueInput
  }

  /**
   * ContainerType updateMany
   */
  export type ContainerTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContainerTypes.
     */
    data: XOR<ContainerTypeUpdateManyMutationInput, ContainerTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContainerTypes to update
     */
    where?: ContainerTypeWhereInput
    /**
     * Limit how many ContainerTypes to update.
     */
    limit?: number
  }

  /**
   * ContainerType updateManyAndReturn
   */
  export type ContainerTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * The data used to update ContainerTypes.
     */
    data: XOR<ContainerTypeUpdateManyMutationInput, ContainerTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContainerTypes to update
     */
    where?: ContainerTypeWhereInput
    /**
     * Limit how many ContainerTypes to update.
     */
    limit?: number
  }

  /**
   * ContainerType upsert
   */
  export type ContainerTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContainerType to update in case it exists.
     */
    where: ContainerTypeWhereUniqueInput
    /**
     * In case the ContainerType found by the `where` argument doesn't exist, create a new ContainerType with this data.
     */
    create: XOR<ContainerTypeCreateInput, ContainerTypeUncheckedCreateInput>
    /**
     * In case the ContainerType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerTypeUpdateInput, ContainerTypeUncheckedUpdateInput>
  }

  /**
   * ContainerType delete
   */
  export type ContainerTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
    /**
     * Filter which ContainerType to delete.
     */
    where: ContainerTypeWhereUniqueInput
  }

  /**
   * ContainerType deleteMany
   */
  export type ContainerTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerTypes to delete
     */
    where?: ContainerTypeWhereInput
    /**
     * Limit how many ContainerTypes to delete.
     */
    limit?: number
  }

  /**
   * ContainerType.containers
   */
  export type ContainerType$containersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    cursor?: ContainerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * ContainerType without action
   */
  export type ContainerTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerType
     */
    select?: ContainerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerType
     */
    omit?: ContainerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerTypeInclude<ExtArgs> | null
  }


  /**
   * Model Container
   */

  export type AggregateContainer = {
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  export type ContainerAvgAggregateOutputType = {
    id: number | null
    gardenId: number | null
    containerTypeId: number | null
    widthInches: Decimal | null
    lengthInches: Decimal | null
    heightInches: Decimal | null
    diameterInches: Decimal | null
    volumeGallons: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
  }

  export type ContainerSumAggregateOutputType = {
    id: number | null
    gardenId: number | null
    containerTypeId: number | null
    widthInches: Decimal | null
    lengthInches: Decimal | null
    heightInches: Decimal | null
    diameterInches: Decimal | null
    volumeGallons: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
  }

  export type ContainerMinAggregateOutputType = {
    id: number | null
    gardenId: number | null
    containerTypeId: number | null
    name: string | null
    material: string | null
    widthInches: Decimal | null
    lengthInches: Decimal | null
    heightInches: Decimal | null
    diameterInches: Decimal | null
    volumeGallons: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
    soilType: string | null
    drainageQuality: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerMaxAggregateOutputType = {
    id: number | null
    gardenId: number | null
    containerTypeId: number | null
    name: string | null
    material: string | null
    widthInches: Decimal | null
    lengthInches: Decimal | null
    heightInches: Decimal | null
    diameterInches: Decimal | null
    volumeGallons: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
    soilType: string | null
    drainageQuality: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerCountAggregateOutputType = {
    id: number
    gardenId: number
    containerTypeId: number
    name: number
    material: number
    widthInches: number
    lengthInches: number
    heightInches: number
    diameterInches: number
    volumeGallons: number
    positionX: number
    positionY: number
    soilType: number
    drainageQuality: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContainerAvgAggregateInputType = {
    id?: true
    gardenId?: true
    containerTypeId?: true
    widthInches?: true
    lengthInches?: true
    heightInches?: true
    diameterInches?: true
    volumeGallons?: true
    positionX?: true
    positionY?: true
  }

  export type ContainerSumAggregateInputType = {
    id?: true
    gardenId?: true
    containerTypeId?: true
    widthInches?: true
    lengthInches?: true
    heightInches?: true
    diameterInches?: true
    volumeGallons?: true
    positionX?: true
    positionY?: true
  }

  export type ContainerMinAggregateInputType = {
    id?: true
    gardenId?: true
    containerTypeId?: true
    name?: true
    material?: true
    widthInches?: true
    lengthInches?: true
    heightInches?: true
    diameterInches?: true
    volumeGallons?: true
    positionX?: true
    positionY?: true
    soilType?: true
    drainageQuality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerMaxAggregateInputType = {
    id?: true
    gardenId?: true
    containerTypeId?: true
    name?: true
    material?: true
    widthInches?: true
    lengthInches?: true
    heightInches?: true
    diameterInches?: true
    volumeGallons?: true
    positionX?: true
    positionY?: true
    soilType?: true
    drainageQuality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerCountAggregateInputType = {
    id?: true
    gardenId?: true
    containerTypeId?: true
    name?: true
    material?: true
    widthInches?: true
    lengthInches?: true
    heightInches?: true
    diameterInches?: true
    volumeGallons?: true
    positionX?: true
    positionY?: true
    soilType?: true
    drainageQuality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Container to aggregate.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Containers
    **/
    _count?: true | ContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerMaxAggregateInputType
  }

  export type GetContainerAggregateType<T extends ContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainer[P]>
      : GetScalarType<T[P], AggregateContainer[P]>
  }




  export type ContainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithAggregationInput | ContainerOrderByWithAggregationInput[]
    by: ContainerScalarFieldEnum[] | ContainerScalarFieldEnum
    having?: ContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerCountAggregateInputType | true
    _avg?: ContainerAvgAggregateInputType
    _sum?: ContainerSumAggregateInputType
    _min?: ContainerMinAggregateInputType
    _max?: ContainerMaxAggregateInputType
  }

  export type ContainerGroupByOutputType = {
    id: number
    gardenId: number
    containerTypeId: number
    name: string | null
    material: string | null
    widthInches: Decimal | null
    lengthInches: Decimal | null
    heightInches: Decimal | null
    diameterInches: Decimal | null
    volumeGallons: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
    soilType: string | null
    drainageQuality: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  type GetContainerGroupByPayload<T extends ContainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerGroupByOutputType[P]>
        }
      >
    >


  export type ContainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    containerTypeId?: boolean
    name?: boolean
    material?: boolean
    widthInches?: boolean
    lengthInches?: boolean
    heightInches?: boolean
    diameterInches?: boolean
    volumeGallons?: boolean
    positionX?: boolean
    positionY?: boolean
    soilType?: boolean
    drainageQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
    containerPlants?: boolean | Container$containerPlantsArgs<ExtArgs>
    gardenActions?: boolean | Container$gardenActionsArgs<ExtArgs>
    containerHistory?: boolean | Container$containerHistoryArgs<ExtArgs>
    previousContainers?: boolean | Container$previousContainersArgs<ExtArgs>
    plannedPlantings?: boolean | Container$plannedPlantingsArgs<ExtArgs>
    tasks?: boolean | Container$tasksArgs<ExtArgs>
    _count?: boolean | ContainerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    containerTypeId?: boolean
    name?: boolean
    material?: boolean
    widthInches?: boolean
    lengthInches?: boolean
    heightInches?: boolean
    diameterInches?: boolean
    volumeGallons?: boolean
    positionX?: boolean
    positionY?: boolean
    soilType?: boolean
    drainageQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    containerTypeId?: boolean
    name?: boolean
    material?: boolean
    widthInches?: boolean
    lengthInches?: boolean
    heightInches?: boolean
    diameterInches?: boolean
    volumeGallons?: boolean
    positionX?: boolean
    positionY?: boolean
    soilType?: boolean
    drainageQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectScalar = {
    id?: boolean
    gardenId?: boolean
    containerTypeId?: boolean
    name?: boolean
    material?: boolean
    widthInches?: boolean
    lengthInches?: boolean
    heightInches?: boolean
    diameterInches?: boolean
    volumeGallons?: boolean
    positionX?: boolean
    positionY?: boolean
    soilType?: boolean
    drainageQuality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContainerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gardenId" | "containerTypeId" | "name" | "material" | "widthInches" | "lengthInches" | "heightInches" | "diameterInches" | "volumeGallons" | "positionX" | "positionY" | "soilType" | "drainageQuality" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["container"]>
  export type ContainerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
    containerPlants?: boolean | Container$containerPlantsArgs<ExtArgs>
    gardenActions?: boolean | Container$gardenActionsArgs<ExtArgs>
    containerHistory?: boolean | Container$containerHistoryArgs<ExtArgs>
    previousContainers?: boolean | Container$previousContainersArgs<ExtArgs>
    plannedPlantings?: boolean | Container$plannedPlantingsArgs<ExtArgs>
    tasks?: boolean | Container$tasksArgs<ExtArgs>
    _count?: boolean | ContainerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContainerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
  }
  export type ContainerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    containerType?: boolean | ContainerTypeDefaultArgs<ExtArgs>
  }

  export type $ContainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Container"
    objects: {
      garden: Prisma.$GardenPayload<ExtArgs>
      containerType: Prisma.$ContainerTypePayload<ExtArgs>
      containerPlants: Prisma.$ContainerPlantPayload<ExtArgs>[]
      gardenActions: Prisma.$GardenActionPayload<ExtArgs>[]
      containerHistory: Prisma.$ContainerHistoryPayload<ExtArgs>[]
      previousContainers: Prisma.$ContainerHistoryPayload<ExtArgs>[]
      plannedPlantings: Prisma.$PlannedPlantingPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gardenId: number
      containerTypeId: number
      name: string | null
      material: string | null
      widthInches: Prisma.Decimal | null
      lengthInches: Prisma.Decimal | null
      heightInches: Prisma.Decimal | null
      diameterInches: Prisma.Decimal | null
      volumeGallons: Prisma.Decimal | null
      positionX: Prisma.Decimal | null
      positionY: Prisma.Decimal | null
      soilType: string | null
      drainageQuality: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["container"]>
    composites: {}
  }

  type ContainerGetPayload<S extends boolean | null | undefined | ContainerDefaultArgs> = $Result.GetResult<Prisma.$ContainerPayload, S>

  type ContainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContainerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContainerCountAggregateInputType | true
    }

  export interface ContainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Container'], meta: { name: 'Container' } }
    /**
     * Find zero or one Container that matches the filter.
     * @param {ContainerFindUniqueArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerFindUniqueArgs>(args: SelectSubset<T, ContainerFindUniqueArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Container that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContainerFindUniqueOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Container that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerFindFirstArgs>(args?: SelectSubset<T, ContainerFindFirstArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Container that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Containers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Containers
     * const containers = await prisma.container.findMany()
     * 
     * // Get first 10 Containers
     * const containers = await prisma.container.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerWithIdOnly = await prisma.container.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerFindManyArgs>(args?: SelectSubset<T, ContainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Container.
     * @param {ContainerCreateArgs} args - Arguments to create a Container.
     * @example
     * // Create one Container
     * const Container = await prisma.container.create({
     *   data: {
     *     // ... data to create a Container
     *   }
     * })
     * 
     */
    create<T extends ContainerCreateArgs>(args: SelectSubset<T, ContainerCreateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Containers.
     * @param {ContainerCreateManyArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerCreateManyArgs>(args?: SelectSubset<T, ContainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Containers and returns the data saved in the database.
     * @param {ContainerCreateManyAndReturnArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Containers and only return the `id`
     * const containerWithIdOnly = await prisma.container.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Container.
     * @param {ContainerDeleteArgs} args - Arguments to delete one Container.
     * @example
     * // Delete one Container
     * const Container = await prisma.container.delete({
     *   where: {
     *     // ... filter to delete one Container
     *   }
     * })
     * 
     */
    delete<T extends ContainerDeleteArgs>(args: SelectSubset<T, ContainerDeleteArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Container.
     * @param {ContainerUpdateArgs} args - Arguments to update one Container.
     * @example
     * // Update one Container
     * const container = await prisma.container.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerUpdateArgs>(args: SelectSubset<T, ContainerUpdateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Containers.
     * @param {ContainerDeleteManyArgs} args - Arguments to filter Containers to delete.
     * @example
     * // Delete a few Containers
     * const { count } = await prisma.container.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerDeleteManyArgs>(args?: SelectSubset<T, ContainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Containers
     * const container = await prisma.container.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerUpdateManyArgs>(args: SelectSubset<T, ContainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Containers and returns the data updated in the database.
     * @param {ContainerUpdateManyAndReturnArgs} args - Arguments to update many Containers.
     * @example
     * // Update many Containers
     * const container = await prisma.container.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Containers and only return the `id`
     * const containerWithIdOnly = await prisma.container.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContainerUpdateManyAndReturnArgs>(args: SelectSubset<T, ContainerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Container.
     * @param {ContainerUpsertArgs} args - Arguments to update or create a Container.
     * @example
     * // Update or create a Container
     * const container = await prisma.container.upsert({
     *   create: {
     *     // ... data to create a Container
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Container we want to update
     *   }
     * })
     */
    upsert<T extends ContainerUpsertArgs>(args: SelectSubset<T, ContainerUpsertArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerCountArgs} args - Arguments to filter Containers to count.
     * @example
     * // Count the number of Containers
     * const count = await prisma.container.count({
     *   where: {
     *     // ... the filter for the Containers we want to count
     *   }
     * })
    **/
    count<T extends ContainerCountArgs>(
      args?: Subset<T, ContainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerAggregateArgs>(args: Subset<T, ContainerAggregateArgs>): Prisma.PrismaPromise<GetContainerAggregateType<T>>

    /**
     * Group by Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerGroupByArgs['orderBy'] }
        : { orderBy?: ContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Container model
   */
  readonly fields: ContainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Container.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    garden<T extends GardenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GardenDefaultArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    containerType<T extends ContainerTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerTypeDefaultArgs<ExtArgs>>): Prisma__ContainerTypeClient<$Result.GetResult<Prisma.$ContainerTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    containerPlants<T extends Container$containerPlantsArgs<ExtArgs> = {}>(args?: Subset<T, Container$containerPlantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gardenActions<T extends Container$gardenActionsArgs<ExtArgs> = {}>(args?: Subset<T, Container$gardenActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    containerHistory<T extends Container$containerHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Container$containerHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previousContainers<T extends Container$previousContainersArgs<ExtArgs> = {}>(args?: Subset<T, Container$previousContainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannedPlantings<T extends Container$plannedPlantingsArgs<ExtArgs> = {}>(args?: Subset<T, Container$plannedPlantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Container$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Container$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Container model
   */
  interface ContainerFieldRefs {
    readonly id: FieldRef<"Container", 'Int'>
    readonly gardenId: FieldRef<"Container", 'Int'>
    readonly containerTypeId: FieldRef<"Container", 'Int'>
    readonly name: FieldRef<"Container", 'String'>
    readonly material: FieldRef<"Container", 'String'>
    readonly widthInches: FieldRef<"Container", 'Decimal'>
    readonly lengthInches: FieldRef<"Container", 'Decimal'>
    readonly heightInches: FieldRef<"Container", 'Decimal'>
    readonly diameterInches: FieldRef<"Container", 'Decimal'>
    readonly volumeGallons: FieldRef<"Container", 'Decimal'>
    readonly positionX: FieldRef<"Container", 'Decimal'>
    readonly positionY: FieldRef<"Container", 'Decimal'>
    readonly soilType: FieldRef<"Container", 'String'>
    readonly drainageQuality: FieldRef<"Container", 'String'>
    readonly notes: FieldRef<"Container", 'String'>
    readonly createdAt: FieldRef<"Container", 'DateTime'>
    readonly updatedAt: FieldRef<"Container", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Container findUnique
   */
  export type ContainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findUniqueOrThrow
   */
  export type ContainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findFirst
   */
  export type ContainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findFirstOrThrow
   */
  export type ContainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findMany
   */
  export type ContainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter, which Containers to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container create
   */
  export type ContainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The data needed to create a Container.
     */
    data: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
  }

  /**
   * Container createMany
   */
  export type ContainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Container createManyAndReturn
   */
  export type ContainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Container update
   */
  export type ContainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The data needed to update a Container.
     */
    data: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
    /**
     * Choose, which Container to update.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container updateMany
   */
  export type ContainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Containers.
     */
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyInput>
    /**
     * Filter which Containers to update
     */
    where?: ContainerWhereInput
    /**
     * Limit how many Containers to update.
     */
    limit?: number
  }

  /**
   * Container updateManyAndReturn
   */
  export type ContainerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * The data used to update Containers.
     */
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyInput>
    /**
     * Filter which Containers to update
     */
    where?: ContainerWhereInput
    /**
     * Limit how many Containers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Container upsert
   */
  export type ContainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * The filter to search for the Container to update in case it exists.
     */
    where: ContainerWhereUniqueInput
    /**
     * In case the Container found by the `where` argument doesn't exist, create a new Container with this data.
     */
    create: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
    /**
     * In case the Container was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
  }

  /**
   * Container delete
   */
  export type ContainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    /**
     * Filter which Container to delete.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container deleteMany
   */
  export type ContainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Containers to delete
     */
    where?: ContainerWhereInput
    /**
     * Limit how many Containers to delete.
     */
    limit?: number
  }

  /**
   * Container.containerPlants
   */
  export type Container$containerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    where?: ContainerPlantWhereInput
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    cursor?: ContainerPlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * Container.gardenActions
   */
  export type Container$gardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    cursor?: GardenActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * Container.containerHistory
   */
  export type Container$containerHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    where?: ContainerHistoryWhereInput
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    cursor?: ContainerHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * Container.previousContainers
   */
  export type Container$previousContainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    where?: ContainerHistoryWhereInput
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    cursor?: ContainerHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * Container.plannedPlantings
   */
  export type Container$plannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    where?: PlannedPlantingWhereInput
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    cursor?: PlannedPlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * Container.tasks
   */
  export type Container$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Container without action
   */
  export type ContainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
  }


  /**
   * Model PlantCatalog
   */

  export type AggregatePlantCatalog = {
    _count: PlantCatalogCountAggregateOutputType | null
    _avg: PlantCatalogAvgAggregateOutputType | null
    _sum: PlantCatalogSumAggregateOutputType | null
    _min: PlantCatalogMinAggregateOutputType | null
    _max: PlantCatalogMaxAggregateOutputType | null
  }

  export type PlantCatalogAvgAggregateOutputType = {
    id: number | null
    daysToGerminationMin: number | null
    daysToGerminationMax: number | null
    daysToMaturityMin: number | null
    daysToMaturityMax: number | null
    heightInchesMin: Decimal | null
    heightInchesMax: Decimal | null
    widthInchesMin: Decimal | null
    widthInchesMax: Decimal | null
  }

  export type PlantCatalogSumAggregateOutputType = {
    id: number | null
    daysToGerminationMin: number | null
    daysToGerminationMax: number | null
    daysToMaturityMin: number | null
    daysToMaturityMax: number | null
    heightInchesMin: Decimal | null
    heightInchesMax: Decimal | null
    widthInchesMin: Decimal | null
    widthInchesMax: Decimal | null
  }

  export type PlantCatalogMinAggregateOutputType = {
    id: number | null
    commonName: string | null
    scientificName: string | null
    plantType: string | null
    lifeCycle: string | null
    growthHabit: string | null
    edible: boolean | null
    description: string | null
    plantingInstructions: string | null
    careInstructions: string | null
    daysToGerminationMin: number | null
    daysToGerminationMax: number | null
    daysToMaturityMin: number | null
    daysToMaturityMax: number | null
    harvestSeason: string | null
    heightInchesMin: Decimal | null
    heightInchesMax: Decimal | null
    widthInchesMin: Decimal | null
    widthInchesMax: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantCatalogMaxAggregateOutputType = {
    id: number | null
    commonName: string | null
    scientificName: string | null
    plantType: string | null
    lifeCycle: string | null
    growthHabit: string | null
    edible: boolean | null
    description: string | null
    plantingInstructions: string | null
    careInstructions: string | null
    daysToGerminationMin: number | null
    daysToGerminationMax: number | null
    daysToMaturityMin: number | null
    daysToMaturityMax: number | null
    harvestSeason: string | null
    heightInchesMin: Decimal | null
    heightInchesMax: Decimal | null
    widthInchesMin: Decimal | null
    widthInchesMax: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantCatalogCountAggregateOutputType = {
    id: number
    commonName: number
    scientificName: number
    plantType: number
    lifeCycle: number
    growthHabit: number
    edible: number
    description: number
    plantingInstructions: number
    careInstructions: number
    daysToGerminationMin: number
    daysToGerminationMax: number
    daysToMaturityMin: number
    daysToMaturityMax: number
    harvestSeason: number
    heightInchesMin: number
    heightInchesMax: number
    widthInchesMin: number
    widthInchesMax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlantCatalogAvgAggregateInputType = {
    id?: true
    daysToGerminationMin?: true
    daysToGerminationMax?: true
    daysToMaturityMin?: true
    daysToMaturityMax?: true
    heightInchesMin?: true
    heightInchesMax?: true
    widthInchesMin?: true
    widthInchesMax?: true
  }

  export type PlantCatalogSumAggregateInputType = {
    id?: true
    daysToGerminationMin?: true
    daysToGerminationMax?: true
    daysToMaturityMin?: true
    daysToMaturityMax?: true
    heightInchesMin?: true
    heightInchesMax?: true
    widthInchesMin?: true
    widthInchesMax?: true
  }

  export type PlantCatalogMinAggregateInputType = {
    id?: true
    commonName?: true
    scientificName?: true
    plantType?: true
    lifeCycle?: true
    growthHabit?: true
    edible?: true
    description?: true
    plantingInstructions?: true
    careInstructions?: true
    daysToGerminationMin?: true
    daysToGerminationMax?: true
    daysToMaturityMin?: true
    daysToMaturityMax?: true
    harvestSeason?: true
    heightInchesMin?: true
    heightInchesMax?: true
    widthInchesMin?: true
    widthInchesMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantCatalogMaxAggregateInputType = {
    id?: true
    commonName?: true
    scientificName?: true
    plantType?: true
    lifeCycle?: true
    growthHabit?: true
    edible?: true
    description?: true
    plantingInstructions?: true
    careInstructions?: true
    daysToGerminationMin?: true
    daysToGerminationMax?: true
    daysToMaturityMin?: true
    daysToMaturityMax?: true
    harvestSeason?: true
    heightInchesMin?: true
    heightInchesMax?: true
    widthInchesMin?: true
    widthInchesMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantCatalogCountAggregateInputType = {
    id?: true
    commonName?: true
    scientificName?: true
    plantType?: true
    lifeCycle?: true
    growthHabit?: true
    edible?: true
    description?: true
    plantingInstructions?: true
    careInstructions?: true
    daysToGerminationMin?: true
    daysToGerminationMax?: true
    daysToMaturityMin?: true
    daysToMaturityMax?: true
    harvestSeason?: true
    heightInchesMin?: true
    heightInchesMax?: true
    widthInchesMin?: true
    widthInchesMax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlantCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantCatalog to aggregate.
     */
    where?: PlantCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCatalogs to fetch.
     */
    orderBy?: PlantCatalogOrderByWithRelationInput | PlantCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantCatalogs
    **/
    _count?: true | PlantCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantCatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantCatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantCatalogMaxAggregateInputType
  }

  export type GetPlantCatalogAggregateType<T extends PlantCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantCatalog[P]>
      : GetScalarType<T[P], AggregatePlantCatalog[P]>
  }




  export type PlantCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantCatalogWhereInput
    orderBy?: PlantCatalogOrderByWithAggregationInput | PlantCatalogOrderByWithAggregationInput[]
    by: PlantCatalogScalarFieldEnum[] | PlantCatalogScalarFieldEnum
    having?: PlantCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantCatalogCountAggregateInputType | true
    _avg?: PlantCatalogAvgAggregateInputType
    _sum?: PlantCatalogSumAggregateInputType
    _min?: PlantCatalogMinAggregateInputType
    _max?: PlantCatalogMaxAggregateInputType
  }

  export type PlantCatalogGroupByOutputType = {
    id: number
    commonName: string
    scientificName: string | null
    plantType: string | null
    lifeCycle: string | null
    growthHabit: string | null
    edible: boolean
    description: string | null
    plantingInstructions: string | null
    careInstructions: string | null
    daysToGerminationMin: number | null
    daysToGerminationMax: number | null
    daysToMaturityMin: number | null
    daysToMaturityMax: number | null
    harvestSeason: string | null
    heightInchesMin: Decimal | null
    heightInchesMax: Decimal | null
    widthInchesMin: Decimal | null
    widthInchesMax: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: PlantCatalogCountAggregateOutputType | null
    _avg: PlantCatalogAvgAggregateOutputType | null
    _sum: PlantCatalogSumAggregateOutputType | null
    _min: PlantCatalogMinAggregateOutputType | null
    _max: PlantCatalogMaxAggregateOutputType | null
  }

  type GetPlantCatalogGroupByPayload<T extends PlantCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], PlantCatalogGroupByOutputType[P]>
        }
      >
    >


  export type PlantCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonName?: boolean
    scientificName?: boolean
    plantType?: boolean
    lifeCycle?: boolean
    growthHabit?: boolean
    edible?: boolean
    description?: boolean
    plantingInstructions?: boolean
    careInstructions?: boolean
    daysToGerminationMin?: boolean
    daysToGerminationMax?: boolean
    daysToMaturityMin?: boolean
    daysToMaturityMax?: boolean
    harvestSeason?: boolean
    heightInchesMin?: boolean
    heightInchesMax?: boolean
    widthInchesMin?: boolean
    widthInchesMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    growingConditions?: boolean | PlantCatalog$growingConditionsArgs<ExtArgs>
    climateZones?: boolean | PlantCatalog$climateZonesArgs<ExtArgs>
    varieties?: boolean | PlantCatalog$varietiesArgs<ExtArgs>
    companions?: boolean | PlantCatalog$companionsArgs<ExtArgs>
    companionTo?: boolean | PlantCatalog$companionToArgs<ExtArgs>
    containerPlants?: boolean | PlantCatalog$containerPlantsArgs<ExtArgs>
    plannedPlantings?: boolean | PlantCatalog$plannedPlantingsArgs<ExtArgs>
    _count?: boolean | PlantCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantCatalog"]>

  export type PlantCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonName?: boolean
    scientificName?: boolean
    plantType?: boolean
    lifeCycle?: boolean
    growthHabit?: boolean
    edible?: boolean
    description?: boolean
    plantingInstructions?: boolean
    careInstructions?: boolean
    daysToGerminationMin?: boolean
    daysToGerminationMax?: boolean
    daysToMaturityMin?: boolean
    daysToMaturityMax?: boolean
    harvestSeason?: boolean
    heightInchesMin?: boolean
    heightInchesMax?: boolean
    widthInchesMin?: boolean
    widthInchesMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plantCatalog"]>

  export type PlantCatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commonName?: boolean
    scientificName?: boolean
    plantType?: boolean
    lifeCycle?: boolean
    growthHabit?: boolean
    edible?: boolean
    description?: boolean
    plantingInstructions?: boolean
    careInstructions?: boolean
    daysToGerminationMin?: boolean
    daysToGerminationMax?: boolean
    daysToMaturityMin?: boolean
    daysToMaturityMax?: boolean
    harvestSeason?: boolean
    heightInchesMin?: boolean
    heightInchesMax?: boolean
    widthInchesMin?: boolean
    widthInchesMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plantCatalog"]>

  export type PlantCatalogSelectScalar = {
    id?: boolean
    commonName?: boolean
    scientificName?: boolean
    plantType?: boolean
    lifeCycle?: boolean
    growthHabit?: boolean
    edible?: boolean
    description?: boolean
    plantingInstructions?: boolean
    careInstructions?: boolean
    daysToGerminationMin?: boolean
    daysToGerminationMax?: boolean
    daysToMaturityMin?: boolean
    daysToMaturityMax?: boolean
    harvestSeason?: boolean
    heightInchesMin?: boolean
    heightInchesMax?: boolean
    widthInchesMin?: boolean
    widthInchesMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlantCatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commonName" | "scientificName" | "plantType" | "lifeCycle" | "growthHabit" | "edible" | "description" | "plantingInstructions" | "careInstructions" | "daysToGerminationMin" | "daysToGerminationMax" | "daysToMaturityMin" | "daysToMaturityMax" | "harvestSeason" | "heightInchesMin" | "heightInchesMax" | "widthInchesMin" | "widthInchesMax" | "createdAt" | "updatedAt", ExtArgs["result"]["plantCatalog"]>
  export type PlantCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    growingConditions?: boolean | PlantCatalog$growingConditionsArgs<ExtArgs>
    climateZones?: boolean | PlantCatalog$climateZonesArgs<ExtArgs>
    varieties?: boolean | PlantCatalog$varietiesArgs<ExtArgs>
    companions?: boolean | PlantCatalog$companionsArgs<ExtArgs>
    companionTo?: boolean | PlantCatalog$companionToArgs<ExtArgs>
    containerPlants?: boolean | PlantCatalog$containerPlantsArgs<ExtArgs>
    plannedPlantings?: boolean | PlantCatalog$plannedPlantingsArgs<ExtArgs>
    _count?: boolean | PlantCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlantCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlantCatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlantCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantCatalog"
    objects: {
      growingConditions: Prisma.$PlantGrowingConditionPayload<ExtArgs> | null
      climateZones: Prisma.$PlantClimateZonePayload<ExtArgs>[]
      varieties: Prisma.$PlantVarietyPayload<ExtArgs>[]
      companions: Prisma.$PlantCompanionPayload<ExtArgs>[]
      companionTo: Prisma.$PlantCompanionPayload<ExtArgs>[]
      containerPlants: Prisma.$ContainerPlantPayload<ExtArgs>[]
      plannedPlantings: Prisma.$PlannedPlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commonName: string
      scientificName: string | null
      plantType: string | null
      lifeCycle: string | null
      growthHabit: string | null
      edible: boolean
      description: string | null
      plantingInstructions: string | null
      careInstructions: string | null
      daysToGerminationMin: number | null
      daysToGerminationMax: number | null
      daysToMaturityMin: number | null
      daysToMaturityMax: number | null
      harvestSeason: string | null
      heightInchesMin: Prisma.Decimal | null
      heightInchesMax: Prisma.Decimal | null
      widthInchesMin: Prisma.Decimal | null
      widthInchesMax: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plantCatalog"]>
    composites: {}
  }

  type PlantCatalogGetPayload<S extends boolean | null | undefined | PlantCatalogDefaultArgs> = $Result.GetResult<Prisma.$PlantCatalogPayload, S>

  type PlantCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantCatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantCatalogCountAggregateInputType | true
    }

  export interface PlantCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantCatalog'], meta: { name: 'PlantCatalog' } }
    /**
     * Find zero or one PlantCatalog that matches the filter.
     * @param {PlantCatalogFindUniqueArgs} args - Arguments to find a PlantCatalog
     * @example
     * // Get one PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantCatalogFindUniqueArgs>(args: SelectSubset<T, PlantCatalogFindUniqueArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantCatalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantCatalogFindUniqueOrThrowArgs} args - Arguments to find a PlantCatalog
     * @example
     * // Get one PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogFindFirstArgs} args - Arguments to find a PlantCatalog
     * @example
     * // Get one PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantCatalogFindFirstArgs>(args?: SelectSubset<T, PlantCatalogFindFirstArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogFindFirstOrThrowArgs} args - Arguments to find a PlantCatalog
     * @example
     * // Get one PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantCatalogs
     * const plantCatalogs = await prisma.plantCatalog.findMany()
     * 
     * // Get first 10 PlantCatalogs
     * const plantCatalogs = await prisma.plantCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantCatalogWithIdOnly = await prisma.plantCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantCatalogFindManyArgs>(args?: SelectSubset<T, PlantCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantCatalog.
     * @param {PlantCatalogCreateArgs} args - Arguments to create a PlantCatalog.
     * @example
     * // Create one PlantCatalog
     * const PlantCatalog = await prisma.plantCatalog.create({
     *   data: {
     *     // ... data to create a PlantCatalog
     *   }
     * })
     * 
     */
    create<T extends PlantCatalogCreateArgs>(args: SelectSubset<T, PlantCatalogCreateArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantCatalogs.
     * @param {PlantCatalogCreateManyArgs} args - Arguments to create many PlantCatalogs.
     * @example
     * // Create many PlantCatalogs
     * const plantCatalog = await prisma.plantCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantCatalogCreateManyArgs>(args?: SelectSubset<T, PlantCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantCatalogs and returns the data saved in the database.
     * @param {PlantCatalogCreateManyAndReturnArgs} args - Arguments to create many PlantCatalogs.
     * @example
     * // Create many PlantCatalogs
     * const plantCatalog = await prisma.plantCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantCatalogs and only return the `id`
     * const plantCatalogWithIdOnly = await prisma.plantCatalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantCatalog.
     * @param {PlantCatalogDeleteArgs} args - Arguments to delete one PlantCatalog.
     * @example
     * // Delete one PlantCatalog
     * const PlantCatalog = await prisma.plantCatalog.delete({
     *   where: {
     *     // ... filter to delete one PlantCatalog
     *   }
     * })
     * 
     */
    delete<T extends PlantCatalogDeleteArgs>(args: SelectSubset<T, PlantCatalogDeleteArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantCatalog.
     * @param {PlantCatalogUpdateArgs} args - Arguments to update one PlantCatalog.
     * @example
     * // Update one PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantCatalogUpdateArgs>(args: SelectSubset<T, PlantCatalogUpdateArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantCatalogs.
     * @param {PlantCatalogDeleteManyArgs} args - Arguments to filter PlantCatalogs to delete.
     * @example
     * // Delete a few PlantCatalogs
     * const { count } = await prisma.plantCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantCatalogDeleteManyArgs>(args?: SelectSubset<T, PlantCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantCatalogs
     * const plantCatalog = await prisma.plantCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantCatalogUpdateManyArgs>(args: SelectSubset<T, PlantCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantCatalogs and returns the data updated in the database.
     * @param {PlantCatalogUpdateManyAndReturnArgs} args - Arguments to update many PlantCatalogs.
     * @example
     * // Update many PlantCatalogs
     * const plantCatalog = await prisma.plantCatalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantCatalogs and only return the `id`
     * const plantCatalogWithIdOnly = await prisma.plantCatalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantCatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantCatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantCatalog.
     * @param {PlantCatalogUpsertArgs} args - Arguments to update or create a PlantCatalog.
     * @example
     * // Update or create a PlantCatalog
     * const plantCatalog = await prisma.plantCatalog.upsert({
     *   create: {
     *     // ... data to create a PlantCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantCatalog we want to update
     *   }
     * })
     */
    upsert<T extends PlantCatalogUpsertArgs>(args: SelectSubset<T, PlantCatalogUpsertArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogCountArgs} args - Arguments to filter PlantCatalogs to count.
     * @example
     * // Count the number of PlantCatalogs
     * const count = await prisma.plantCatalog.count({
     *   where: {
     *     // ... the filter for the PlantCatalogs we want to count
     *   }
     * })
    **/
    count<T extends PlantCatalogCountArgs>(
      args?: Subset<T, PlantCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantCatalogAggregateArgs>(args: Subset<T, PlantCatalogAggregateArgs>): Prisma.PrismaPromise<GetPlantCatalogAggregateType<T>>

    /**
     * Group by PlantCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantCatalogGroupByArgs['orderBy'] }
        : { orderBy?: PlantCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantCatalog model
   */
  readonly fields: PlantCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    growingConditions<T extends PlantCatalog$growingConditionsArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$growingConditionsArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    climateZones<T extends PlantCatalog$climateZonesArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$climateZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    varieties<T extends PlantCatalog$varietiesArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$varietiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companions<T extends PlantCatalog$companionsArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$companionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companionTo<T extends PlantCatalog$companionToArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$companionToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    containerPlants<T extends PlantCatalog$containerPlantsArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$containerPlantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannedPlantings<T extends PlantCatalog$plannedPlantingsArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalog$plannedPlantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantCatalog model
   */
  interface PlantCatalogFieldRefs {
    readonly id: FieldRef<"PlantCatalog", 'Int'>
    readonly commonName: FieldRef<"PlantCatalog", 'String'>
    readonly scientificName: FieldRef<"PlantCatalog", 'String'>
    readonly plantType: FieldRef<"PlantCatalog", 'String'>
    readonly lifeCycle: FieldRef<"PlantCatalog", 'String'>
    readonly growthHabit: FieldRef<"PlantCatalog", 'String'>
    readonly edible: FieldRef<"PlantCatalog", 'Boolean'>
    readonly description: FieldRef<"PlantCatalog", 'String'>
    readonly plantingInstructions: FieldRef<"PlantCatalog", 'String'>
    readonly careInstructions: FieldRef<"PlantCatalog", 'String'>
    readonly daysToGerminationMin: FieldRef<"PlantCatalog", 'Int'>
    readonly daysToGerminationMax: FieldRef<"PlantCatalog", 'Int'>
    readonly daysToMaturityMin: FieldRef<"PlantCatalog", 'Int'>
    readonly daysToMaturityMax: FieldRef<"PlantCatalog", 'Int'>
    readonly harvestSeason: FieldRef<"PlantCatalog", 'String'>
    readonly heightInchesMin: FieldRef<"PlantCatalog", 'Decimal'>
    readonly heightInchesMax: FieldRef<"PlantCatalog", 'Decimal'>
    readonly widthInchesMin: FieldRef<"PlantCatalog", 'Decimal'>
    readonly widthInchesMax: FieldRef<"PlantCatalog", 'Decimal'>
    readonly createdAt: FieldRef<"PlantCatalog", 'DateTime'>
    readonly updatedAt: FieldRef<"PlantCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlantCatalog findUnique
   */
  export type PlantCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter, which PlantCatalog to fetch.
     */
    where: PlantCatalogWhereUniqueInput
  }

  /**
   * PlantCatalog findUniqueOrThrow
   */
  export type PlantCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter, which PlantCatalog to fetch.
     */
    where: PlantCatalogWhereUniqueInput
  }

  /**
   * PlantCatalog findFirst
   */
  export type PlantCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter, which PlantCatalog to fetch.
     */
    where?: PlantCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCatalogs to fetch.
     */
    orderBy?: PlantCatalogOrderByWithRelationInput | PlantCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantCatalogs.
     */
    cursor?: PlantCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantCatalogs.
     */
    distinct?: PlantCatalogScalarFieldEnum | PlantCatalogScalarFieldEnum[]
  }

  /**
   * PlantCatalog findFirstOrThrow
   */
  export type PlantCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter, which PlantCatalog to fetch.
     */
    where?: PlantCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCatalogs to fetch.
     */
    orderBy?: PlantCatalogOrderByWithRelationInput | PlantCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantCatalogs.
     */
    cursor?: PlantCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantCatalogs.
     */
    distinct?: PlantCatalogScalarFieldEnum | PlantCatalogScalarFieldEnum[]
  }

  /**
   * PlantCatalog findMany
   */
  export type PlantCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter, which PlantCatalogs to fetch.
     */
    where?: PlantCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCatalogs to fetch.
     */
    orderBy?: PlantCatalogOrderByWithRelationInput | PlantCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantCatalogs.
     */
    cursor?: PlantCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCatalogs.
     */
    skip?: number
    distinct?: PlantCatalogScalarFieldEnum | PlantCatalogScalarFieldEnum[]
  }

  /**
   * PlantCatalog create
   */
  export type PlantCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantCatalog.
     */
    data: XOR<PlantCatalogCreateInput, PlantCatalogUncheckedCreateInput>
  }

  /**
   * PlantCatalog createMany
   */
  export type PlantCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantCatalogs.
     */
    data: PlantCatalogCreateManyInput | PlantCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantCatalog createManyAndReturn
   */
  export type PlantCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * The data used to create many PlantCatalogs.
     */
    data: PlantCatalogCreateManyInput | PlantCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantCatalog update
   */
  export type PlantCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantCatalog.
     */
    data: XOR<PlantCatalogUpdateInput, PlantCatalogUncheckedUpdateInput>
    /**
     * Choose, which PlantCatalog to update.
     */
    where: PlantCatalogWhereUniqueInput
  }

  /**
   * PlantCatalog updateMany
   */
  export type PlantCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantCatalogs.
     */
    data: XOR<PlantCatalogUpdateManyMutationInput, PlantCatalogUncheckedUpdateManyInput>
    /**
     * Filter which PlantCatalogs to update
     */
    where?: PlantCatalogWhereInput
    /**
     * Limit how many PlantCatalogs to update.
     */
    limit?: number
  }

  /**
   * PlantCatalog updateManyAndReturn
   */
  export type PlantCatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * The data used to update PlantCatalogs.
     */
    data: XOR<PlantCatalogUpdateManyMutationInput, PlantCatalogUncheckedUpdateManyInput>
    /**
     * Filter which PlantCatalogs to update
     */
    where?: PlantCatalogWhereInput
    /**
     * Limit how many PlantCatalogs to update.
     */
    limit?: number
  }

  /**
   * PlantCatalog upsert
   */
  export type PlantCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantCatalog to update in case it exists.
     */
    where: PlantCatalogWhereUniqueInput
    /**
     * In case the PlantCatalog found by the `where` argument doesn't exist, create a new PlantCatalog with this data.
     */
    create: XOR<PlantCatalogCreateInput, PlantCatalogUncheckedCreateInput>
    /**
     * In case the PlantCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantCatalogUpdateInput, PlantCatalogUncheckedUpdateInput>
  }

  /**
   * PlantCatalog delete
   */
  export type PlantCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
    /**
     * Filter which PlantCatalog to delete.
     */
    where: PlantCatalogWhereUniqueInput
  }

  /**
   * PlantCatalog deleteMany
   */
  export type PlantCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantCatalogs to delete
     */
    where?: PlantCatalogWhereInput
    /**
     * Limit how many PlantCatalogs to delete.
     */
    limit?: number
  }

  /**
   * PlantCatalog.growingConditions
   */
  export type PlantCatalog$growingConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    where?: PlantGrowingConditionWhereInput
  }

  /**
   * PlantCatalog.climateZones
   */
  export type PlantCatalog$climateZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    where?: PlantClimateZoneWhereInput
    orderBy?: PlantClimateZoneOrderByWithRelationInput | PlantClimateZoneOrderByWithRelationInput[]
    cursor?: PlantClimateZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantClimateZoneScalarFieldEnum | PlantClimateZoneScalarFieldEnum[]
  }

  /**
   * PlantCatalog.varieties
   */
  export type PlantCatalog$varietiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    where?: PlantVarietyWhereInput
    orderBy?: PlantVarietyOrderByWithRelationInput | PlantVarietyOrderByWithRelationInput[]
    cursor?: PlantVarietyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantVarietyScalarFieldEnum | PlantVarietyScalarFieldEnum[]
  }

  /**
   * PlantCatalog.companions
   */
  export type PlantCatalog$companionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    where?: PlantCompanionWhereInput
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    cursor?: PlantCompanionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantCompanionScalarFieldEnum | PlantCompanionScalarFieldEnum[]
  }

  /**
   * PlantCatalog.companionTo
   */
  export type PlantCatalog$companionToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    where?: PlantCompanionWhereInput
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    cursor?: PlantCompanionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantCompanionScalarFieldEnum | PlantCompanionScalarFieldEnum[]
  }

  /**
   * PlantCatalog.containerPlants
   */
  export type PlantCatalog$containerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    where?: ContainerPlantWhereInput
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    cursor?: ContainerPlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * PlantCatalog.plannedPlantings
   */
  export type PlantCatalog$plannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    where?: PlannedPlantingWhereInput
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    cursor?: PlannedPlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * PlantCatalog without action
   */
  export type PlantCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCatalog
     */
    select?: PlantCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCatalog
     */
    omit?: PlantCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCatalogInclude<ExtArgs> | null
  }


  /**
   * Model PlantGrowingCondition
   */

  export type AggregatePlantGrowingCondition = {
    _count: PlantGrowingConditionCountAggregateOutputType | null
    _avg: PlantGrowingConditionAvgAggregateOutputType | null
    _sum: PlantGrowingConditionSumAggregateOutputType | null
    _min: PlantGrowingConditionMinAggregateOutputType | null
    _max: PlantGrowingConditionMaxAggregateOutputType | null
  }

  export type PlantGrowingConditionAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
    minTemperatureF: number | null
    maxTemperatureF: number | null
    soilPhMin: Decimal | null
    soilPhMax: Decimal | null
    spacingInches: Decimal | null
    minContainerDepthInches: Decimal | null
    minContainerVolumeGallons: Decimal | null
  }

  export type PlantGrowingConditionSumAggregateOutputType = {
    id: number | null
    plantId: number | null
    minTemperatureF: number | null
    maxTemperatureF: number | null
    soilPhMin: Decimal | null
    soilPhMax: Decimal | null
    spacingInches: Decimal | null
    minContainerDepthInches: Decimal | null
    minContainerVolumeGallons: Decimal | null
  }

  export type PlantGrowingConditionMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    minTemperatureF: number | null
    maxTemperatureF: number | null
    sunlightNeeds: string | null
    waterNeeds: string | null
    soilPhMin: Decimal | null
    soilPhMax: Decimal | null
    soilTypePreference: string | null
    fertilizerNeeds: string | null
    spacingInches: Decimal | null
    containerSuitable: boolean | null
    minContainerDepthInches: Decimal | null
    minContainerVolumeGallons: Decimal | null
  }

  export type PlantGrowingConditionMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    minTemperatureF: number | null
    maxTemperatureF: number | null
    sunlightNeeds: string | null
    waterNeeds: string | null
    soilPhMin: Decimal | null
    soilPhMax: Decimal | null
    soilTypePreference: string | null
    fertilizerNeeds: string | null
    spacingInches: Decimal | null
    containerSuitable: boolean | null
    minContainerDepthInches: Decimal | null
    minContainerVolumeGallons: Decimal | null
  }

  export type PlantGrowingConditionCountAggregateOutputType = {
    id: number
    plantId: number
    minTemperatureF: number
    maxTemperatureF: number
    sunlightNeeds: number
    waterNeeds: number
    soilPhMin: number
    soilPhMax: number
    soilTypePreference: number
    fertilizerNeeds: number
    spacingInches: number
    containerSuitable: number
    minContainerDepthInches: number
    minContainerVolumeGallons: number
    _all: number
  }


  export type PlantGrowingConditionAvgAggregateInputType = {
    id?: true
    plantId?: true
    minTemperatureF?: true
    maxTemperatureF?: true
    soilPhMin?: true
    soilPhMax?: true
    spacingInches?: true
    minContainerDepthInches?: true
    minContainerVolumeGallons?: true
  }

  export type PlantGrowingConditionSumAggregateInputType = {
    id?: true
    plantId?: true
    minTemperatureF?: true
    maxTemperatureF?: true
    soilPhMin?: true
    soilPhMax?: true
    spacingInches?: true
    minContainerDepthInches?: true
    minContainerVolumeGallons?: true
  }

  export type PlantGrowingConditionMinAggregateInputType = {
    id?: true
    plantId?: true
    minTemperatureF?: true
    maxTemperatureF?: true
    sunlightNeeds?: true
    waterNeeds?: true
    soilPhMin?: true
    soilPhMax?: true
    soilTypePreference?: true
    fertilizerNeeds?: true
    spacingInches?: true
    containerSuitable?: true
    minContainerDepthInches?: true
    minContainerVolumeGallons?: true
  }

  export type PlantGrowingConditionMaxAggregateInputType = {
    id?: true
    plantId?: true
    minTemperatureF?: true
    maxTemperatureF?: true
    sunlightNeeds?: true
    waterNeeds?: true
    soilPhMin?: true
    soilPhMax?: true
    soilTypePreference?: true
    fertilizerNeeds?: true
    spacingInches?: true
    containerSuitable?: true
    minContainerDepthInches?: true
    minContainerVolumeGallons?: true
  }

  export type PlantGrowingConditionCountAggregateInputType = {
    id?: true
    plantId?: true
    minTemperatureF?: true
    maxTemperatureF?: true
    sunlightNeeds?: true
    waterNeeds?: true
    soilPhMin?: true
    soilPhMax?: true
    soilTypePreference?: true
    fertilizerNeeds?: true
    spacingInches?: true
    containerSuitable?: true
    minContainerDepthInches?: true
    minContainerVolumeGallons?: true
    _all?: true
  }

  export type PlantGrowingConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantGrowingCondition to aggregate.
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowingConditions to fetch.
     */
    orderBy?: PlantGrowingConditionOrderByWithRelationInput | PlantGrowingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantGrowingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantGrowingConditions
    **/
    _count?: true | PlantGrowingConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantGrowingConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantGrowingConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantGrowingConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantGrowingConditionMaxAggregateInputType
  }

  export type GetPlantGrowingConditionAggregateType<T extends PlantGrowingConditionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantGrowingCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantGrowingCondition[P]>
      : GetScalarType<T[P], AggregatePlantGrowingCondition[P]>
  }




  export type PlantGrowingConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantGrowingConditionWhereInput
    orderBy?: PlantGrowingConditionOrderByWithAggregationInput | PlantGrowingConditionOrderByWithAggregationInput[]
    by: PlantGrowingConditionScalarFieldEnum[] | PlantGrowingConditionScalarFieldEnum
    having?: PlantGrowingConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantGrowingConditionCountAggregateInputType | true
    _avg?: PlantGrowingConditionAvgAggregateInputType
    _sum?: PlantGrowingConditionSumAggregateInputType
    _min?: PlantGrowingConditionMinAggregateInputType
    _max?: PlantGrowingConditionMaxAggregateInputType
  }

  export type PlantGrowingConditionGroupByOutputType = {
    id: number
    plantId: number
    minTemperatureF: number | null
    maxTemperatureF: number | null
    sunlightNeeds: string | null
    waterNeeds: string | null
    soilPhMin: Decimal | null
    soilPhMax: Decimal | null
    soilTypePreference: string | null
    fertilizerNeeds: string | null
    spacingInches: Decimal | null
    containerSuitable: boolean
    minContainerDepthInches: Decimal | null
    minContainerVolumeGallons: Decimal | null
    _count: PlantGrowingConditionCountAggregateOutputType | null
    _avg: PlantGrowingConditionAvgAggregateOutputType | null
    _sum: PlantGrowingConditionSumAggregateOutputType | null
    _min: PlantGrowingConditionMinAggregateOutputType | null
    _max: PlantGrowingConditionMaxAggregateOutputType | null
  }

  type GetPlantGrowingConditionGroupByPayload<T extends PlantGrowingConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantGrowingConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantGrowingConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantGrowingConditionGroupByOutputType[P]>
            : GetScalarType<T[P], PlantGrowingConditionGroupByOutputType[P]>
        }
      >
    >


  export type PlantGrowingConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    minTemperatureF?: boolean
    maxTemperatureF?: boolean
    sunlightNeeds?: boolean
    waterNeeds?: boolean
    soilPhMin?: boolean
    soilPhMax?: boolean
    soilTypePreference?: boolean
    fertilizerNeeds?: boolean
    spacingInches?: boolean
    containerSuitable?: boolean
    minContainerDepthInches?: boolean
    minContainerVolumeGallons?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowingCondition"]>

  export type PlantGrowingConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    minTemperatureF?: boolean
    maxTemperatureF?: boolean
    sunlightNeeds?: boolean
    waterNeeds?: boolean
    soilPhMin?: boolean
    soilPhMax?: boolean
    soilTypePreference?: boolean
    fertilizerNeeds?: boolean
    spacingInches?: boolean
    containerSuitable?: boolean
    minContainerDepthInches?: boolean
    minContainerVolumeGallons?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowingCondition"]>

  export type PlantGrowingConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    minTemperatureF?: boolean
    maxTemperatureF?: boolean
    sunlightNeeds?: boolean
    waterNeeds?: boolean
    soilPhMin?: boolean
    soilPhMax?: boolean
    soilTypePreference?: boolean
    fertilizerNeeds?: boolean
    spacingInches?: boolean
    containerSuitable?: boolean
    minContainerDepthInches?: boolean
    minContainerVolumeGallons?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowingCondition"]>

  export type PlantGrowingConditionSelectScalar = {
    id?: boolean
    plantId?: boolean
    minTemperatureF?: boolean
    maxTemperatureF?: boolean
    sunlightNeeds?: boolean
    waterNeeds?: boolean
    soilPhMin?: boolean
    soilPhMax?: boolean
    soilTypePreference?: boolean
    fertilizerNeeds?: boolean
    spacingInches?: boolean
    containerSuitable?: boolean
    minContainerDepthInches?: boolean
    minContainerVolumeGallons?: boolean
  }

  export type PlantGrowingConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantId" | "minTemperatureF" | "maxTemperatureF" | "sunlightNeeds" | "waterNeeds" | "soilPhMin" | "soilPhMax" | "soilTypePreference" | "fertilizerNeeds" | "spacingInches" | "containerSuitable" | "minContainerDepthInches" | "minContainerVolumeGallons", ExtArgs["result"]["plantGrowingCondition"]>
  export type PlantGrowingConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantGrowingConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantGrowingConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }

  export type $PlantGrowingConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantGrowingCondition"
    objects: {
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      minTemperatureF: number | null
      maxTemperatureF: number | null
      sunlightNeeds: string | null
      waterNeeds: string | null
      soilPhMin: Prisma.Decimal | null
      soilPhMax: Prisma.Decimal | null
      soilTypePreference: string | null
      fertilizerNeeds: string | null
      spacingInches: Prisma.Decimal | null
      containerSuitable: boolean
      minContainerDepthInches: Prisma.Decimal | null
      minContainerVolumeGallons: Prisma.Decimal | null
    }, ExtArgs["result"]["plantGrowingCondition"]>
    composites: {}
  }

  type PlantGrowingConditionGetPayload<S extends boolean | null | undefined | PlantGrowingConditionDefaultArgs> = $Result.GetResult<Prisma.$PlantGrowingConditionPayload, S>

  type PlantGrowingConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantGrowingConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantGrowingConditionCountAggregateInputType | true
    }

  export interface PlantGrowingConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantGrowingCondition'], meta: { name: 'PlantGrowingCondition' } }
    /**
     * Find zero or one PlantGrowingCondition that matches the filter.
     * @param {PlantGrowingConditionFindUniqueArgs} args - Arguments to find a PlantGrowingCondition
     * @example
     * // Get one PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantGrowingConditionFindUniqueArgs>(args: SelectSubset<T, PlantGrowingConditionFindUniqueArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantGrowingCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantGrowingConditionFindUniqueOrThrowArgs} args - Arguments to find a PlantGrowingCondition
     * @example
     * // Get one PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantGrowingConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantGrowingConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantGrowingCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionFindFirstArgs} args - Arguments to find a PlantGrowingCondition
     * @example
     * // Get one PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantGrowingConditionFindFirstArgs>(args?: SelectSubset<T, PlantGrowingConditionFindFirstArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantGrowingCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionFindFirstOrThrowArgs} args - Arguments to find a PlantGrowingCondition
     * @example
     * // Get one PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantGrowingConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantGrowingConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantGrowingConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantGrowingConditions
     * const plantGrowingConditions = await prisma.plantGrowingCondition.findMany()
     * 
     * // Get first 10 PlantGrowingConditions
     * const plantGrowingConditions = await prisma.plantGrowingCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantGrowingConditionWithIdOnly = await prisma.plantGrowingCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantGrowingConditionFindManyArgs>(args?: SelectSubset<T, PlantGrowingConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantGrowingCondition.
     * @param {PlantGrowingConditionCreateArgs} args - Arguments to create a PlantGrowingCondition.
     * @example
     * // Create one PlantGrowingCondition
     * const PlantGrowingCondition = await prisma.plantGrowingCondition.create({
     *   data: {
     *     // ... data to create a PlantGrowingCondition
     *   }
     * })
     * 
     */
    create<T extends PlantGrowingConditionCreateArgs>(args: SelectSubset<T, PlantGrowingConditionCreateArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantGrowingConditions.
     * @param {PlantGrowingConditionCreateManyArgs} args - Arguments to create many PlantGrowingConditions.
     * @example
     * // Create many PlantGrowingConditions
     * const plantGrowingCondition = await prisma.plantGrowingCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantGrowingConditionCreateManyArgs>(args?: SelectSubset<T, PlantGrowingConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantGrowingConditions and returns the data saved in the database.
     * @param {PlantGrowingConditionCreateManyAndReturnArgs} args - Arguments to create many PlantGrowingConditions.
     * @example
     * // Create many PlantGrowingConditions
     * const plantGrowingCondition = await prisma.plantGrowingCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantGrowingConditions and only return the `id`
     * const plantGrowingConditionWithIdOnly = await prisma.plantGrowingCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantGrowingConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantGrowingConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantGrowingCondition.
     * @param {PlantGrowingConditionDeleteArgs} args - Arguments to delete one PlantGrowingCondition.
     * @example
     * // Delete one PlantGrowingCondition
     * const PlantGrowingCondition = await prisma.plantGrowingCondition.delete({
     *   where: {
     *     // ... filter to delete one PlantGrowingCondition
     *   }
     * })
     * 
     */
    delete<T extends PlantGrowingConditionDeleteArgs>(args: SelectSubset<T, PlantGrowingConditionDeleteArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantGrowingCondition.
     * @param {PlantGrowingConditionUpdateArgs} args - Arguments to update one PlantGrowingCondition.
     * @example
     * // Update one PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantGrowingConditionUpdateArgs>(args: SelectSubset<T, PlantGrowingConditionUpdateArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantGrowingConditions.
     * @param {PlantGrowingConditionDeleteManyArgs} args - Arguments to filter PlantGrowingConditions to delete.
     * @example
     * // Delete a few PlantGrowingConditions
     * const { count } = await prisma.plantGrowingCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantGrowingConditionDeleteManyArgs>(args?: SelectSubset<T, PlantGrowingConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantGrowingConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantGrowingConditions
     * const plantGrowingCondition = await prisma.plantGrowingCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantGrowingConditionUpdateManyArgs>(args: SelectSubset<T, PlantGrowingConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantGrowingConditions and returns the data updated in the database.
     * @param {PlantGrowingConditionUpdateManyAndReturnArgs} args - Arguments to update many PlantGrowingConditions.
     * @example
     * // Update many PlantGrowingConditions
     * const plantGrowingCondition = await prisma.plantGrowingCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantGrowingConditions and only return the `id`
     * const plantGrowingConditionWithIdOnly = await prisma.plantGrowingCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantGrowingConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantGrowingConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantGrowingCondition.
     * @param {PlantGrowingConditionUpsertArgs} args - Arguments to update or create a PlantGrowingCondition.
     * @example
     * // Update or create a PlantGrowingCondition
     * const plantGrowingCondition = await prisma.plantGrowingCondition.upsert({
     *   create: {
     *     // ... data to create a PlantGrowingCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantGrowingCondition we want to update
     *   }
     * })
     */
    upsert<T extends PlantGrowingConditionUpsertArgs>(args: SelectSubset<T, PlantGrowingConditionUpsertArgs<ExtArgs>>): Prisma__PlantGrowingConditionClient<$Result.GetResult<Prisma.$PlantGrowingConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantGrowingConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionCountArgs} args - Arguments to filter PlantGrowingConditions to count.
     * @example
     * // Count the number of PlantGrowingConditions
     * const count = await prisma.plantGrowingCondition.count({
     *   where: {
     *     // ... the filter for the PlantGrowingConditions we want to count
     *   }
     * })
    **/
    count<T extends PlantGrowingConditionCountArgs>(
      args?: Subset<T, PlantGrowingConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantGrowingConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantGrowingCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantGrowingConditionAggregateArgs>(args: Subset<T, PlantGrowingConditionAggregateArgs>): Prisma.PrismaPromise<GetPlantGrowingConditionAggregateType<T>>

    /**
     * Group by PlantGrowingCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowingConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantGrowingConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantGrowingConditionGroupByArgs['orderBy'] }
        : { orderBy?: PlantGrowingConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantGrowingConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantGrowingConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantGrowingCondition model
   */
  readonly fields: PlantGrowingConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantGrowingCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantGrowingConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantGrowingCondition model
   */
  interface PlantGrowingConditionFieldRefs {
    readonly id: FieldRef<"PlantGrowingCondition", 'Int'>
    readonly plantId: FieldRef<"PlantGrowingCondition", 'Int'>
    readonly minTemperatureF: FieldRef<"PlantGrowingCondition", 'Int'>
    readonly maxTemperatureF: FieldRef<"PlantGrowingCondition", 'Int'>
    readonly sunlightNeeds: FieldRef<"PlantGrowingCondition", 'String'>
    readonly waterNeeds: FieldRef<"PlantGrowingCondition", 'String'>
    readonly soilPhMin: FieldRef<"PlantGrowingCondition", 'Decimal'>
    readonly soilPhMax: FieldRef<"PlantGrowingCondition", 'Decimal'>
    readonly soilTypePreference: FieldRef<"PlantGrowingCondition", 'String'>
    readonly fertilizerNeeds: FieldRef<"PlantGrowingCondition", 'String'>
    readonly spacingInches: FieldRef<"PlantGrowingCondition", 'Decimal'>
    readonly containerSuitable: FieldRef<"PlantGrowingCondition", 'Boolean'>
    readonly minContainerDepthInches: FieldRef<"PlantGrowingCondition", 'Decimal'>
    readonly minContainerVolumeGallons: FieldRef<"PlantGrowingCondition", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PlantGrowingCondition findUnique
   */
  export type PlantGrowingConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowingCondition to fetch.
     */
    where: PlantGrowingConditionWhereUniqueInput
  }

  /**
   * PlantGrowingCondition findUniqueOrThrow
   */
  export type PlantGrowingConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowingCondition to fetch.
     */
    where: PlantGrowingConditionWhereUniqueInput
  }

  /**
   * PlantGrowingCondition findFirst
   */
  export type PlantGrowingConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowingCondition to fetch.
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowingConditions to fetch.
     */
    orderBy?: PlantGrowingConditionOrderByWithRelationInput | PlantGrowingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantGrowingConditions.
     */
    cursor?: PlantGrowingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantGrowingConditions.
     */
    distinct?: PlantGrowingConditionScalarFieldEnum | PlantGrowingConditionScalarFieldEnum[]
  }

  /**
   * PlantGrowingCondition findFirstOrThrow
   */
  export type PlantGrowingConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowingCondition to fetch.
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowingConditions to fetch.
     */
    orderBy?: PlantGrowingConditionOrderByWithRelationInput | PlantGrowingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantGrowingConditions.
     */
    cursor?: PlantGrowingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantGrowingConditions.
     */
    distinct?: PlantGrowingConditionScalarFieldEnum | PlantGrowingConditionScalarFieldEnum[]
  }

  /**
   * PlantGrowingCondition findMany
   */
  export type PlantGrowingConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowingConditions to fetch.
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowingConditions to fetch.
     */
    orderBy?: PlantGrowingConditionOrderByWithRelationInput | PlantGrowingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantGrowingConditions.
     */
    cursor?: PlantGrowingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowingConditions.
     */
    skip?: number
    distinct?: PlantGrowingConditionScalarFieldEnum | PlantGrowingConditionScalarFieldEnum[]
  }

  /**
   * PlantGrowingCondition create
   */
  export type PlantGrowingConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantGrowingCondition.
     */
    data: XOR<PlantGrowingConditionCreateInput, PlantGrowingConditionUncheckedCreateInput>
  }

  /**
   * PlantGrowingCondition createMany
   */
  export type PlantGrowingConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantGrowingConditions.
     */
    data: PlantGrowingConditionCreateManyInput | PlantGrowingConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantGrowingCondition createManyAndReturn
   */
  export type PlantGrowingConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * The data used to create many PlantGrowingConditions.
     */
    data: PlantGrowingConditionCreateManyInput | PlantGrowingConditionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantGrowingCondition update
   */
  export type PlantGrowingConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantGrowingCondition.
     */
    data: XOR<PlantGrowingConditionUpdateInput, PlantGrowingConditionUncheckedUpdateInput>
    /**
     * Choose, which PlantGrowingCondition to update.
     */
    where: PlantGrowingConditionWhereUniqueInput
  }

  /**
   * PlantGrowingCondition updateMany
   */
  export type PlantGrowingConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantGrowingConditions.
     */
    data: XOR<PlantGrowingConditionUpdateManyMutationInput, PlantGrowingConditionUncheckedUpdateManyInput>
    /**
     * Filter which PlantGrowingConditions to update
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * Limit how many PlantGrowingConditions to update.
     */
    limit?: number
  }

  /**
   * PlantGrowingCondition updateManyAndReturn
   */
  export type PlantGrowingConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * The data used to update PlantGrowingConditions.
     */
    data: XOR<PlantGrowingConditionUpdateManyMutationInput, PlantGrowingConditionUncheckedUpdateManyInput>
    /**
     * Filter which PlantGrowingConditions to update
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * Limit how many PlantGrowingConditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantGrowingCondition upsert
   */
  export type PlantGrowingConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantGrowingCondition to update in case it exists.
     */
    where: PlantGrowingConditionWhereUniqueInput
    /**
     * In case the PlantGrowingCondition found by the `where` argument doesn't exist, create a new PlantGrowingCondition with this data.
     */
    create: XOR<PlantGrowingConditionCreateInput, PlantGrowingConditionUncheckedCreateInput>
    /**
     * In case the PlantGrowingCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantGrowingConditionUpdateInput, PlantGrowingConditionUncheckedUpdateInput>
  }

  /**
   * PlantGrowingCondition delete
   */
  export type PlantGrowingConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
    /**
     * Filter which PlantGrowingCondition to delete.
     */
    where: PlantGrowingConditionWhereUniqueInput
  }

  /**
   * PlantGrowingCondition deleteMany
   */
  export type PlantGrowingConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantGrowingConditions to delete
     */
    where?: PlantGrowingConditionWhereInput
    /**
     * Limit how many PlantGrowingConditions to delete.
     */
    limit?: number
  }

  /**
   * PlantGrowingCondition without action
   */
  export type PlantGrowingConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowingCondition
     */
    select?: PlantGrowingConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowingCondition
     */
    omit?: PlantGrowingConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowingConditionInclude<ExtArgs> | null
  }


  /**
   * Model PlantClimateZone
   */

  export type AggregatePlantClimateZone = {
    _count: PlantClimateZoneCountAggregateOutputType | null
    _avg: PlantClimateZoneAvgAggregateOutputType | null
    _sum: PlantClimateZoneSumAggregateOutputType | null
    _min: PlantClimateZoneMinAggregateOutputType | null
    _max: PlantClimateZoneMaxAggregateOutputType | null
  }

  export type PlantClimateZoneAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type PlantClimateZoneSumAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type PlantClimateZoneMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    climateZone: string | null
    notes: string | null
  }

  export type PlantClimateZoneMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    climateZone: string | null
    notes: string | null
  }

  export type PlantClimateZoneCountAggregateOutputType = {
    id: number
    plantId: number
    climateZone: number
    notes: number
    _all: number
  }


  export type PlantClimateZoneAvgAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type PlantClimateZoneSumAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type PlantClimateZoneMinAggregateInputType = {
    id?: true
    plantId?: true
    climateZone?: true
    notes?: true
  }

  export type PlantClimateZoneMaxAggregateInputType = {
    id?: true
    plantId?: true
    climateZone?: true
    notes?: true
  }

  export type PlantClimateZoneCountAggregateInputType = {
    id?: true
    plantId?: true
    climateZone?: true
    notes?: true
    _all?: true
  }

  export type PlantClimateZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantClimateZone to aggregate.
     */
    where?: PlantClimateZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantClimateZones to fetch.
     */
    orderBy?: PlantClimateZoneOrderByWithRelationInput | PlantClimateZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantClimateZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantClimateZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantClimateZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantClimateZones
    **/
    _count?: true | PlantClimateZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantClimateZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantClimateZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantClimateZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantClimateZoneMaxAggregateInputType
  }

  export type GetPlantClimateZoneAggregateType<T extends PlantClimateZoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantClimateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantClimateZone[P]>
      : GetScalarType<T[P], AggregatePlantClimateZone[P]>
  }




  export type PlantClimateZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantClimateZoneWhereInput
    orderBy?: PlantClimateZoneOrderByWithAggregationInput | PlantClimateZoneOrderByWithAggregationInput[]
    by: PlantClimateZoneScalarFieldEnum[] | PlantClimateZoneScalarFieldEnum
    having?: PlantClimateZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantClimateZoneCountAggregateInputType | true
    _avg?: PlantClimateZoneAvgAggregateInputType
    _sum?: PlantClimateZoneSumAggregateInputType
    _min?: PlantClimateZoneMinAggregateInputType
    _max?: PlantClimateZoneMaxAggregateInputType
  }

  export type PlantClimateZoneGroupByOutputType = {
    id: number
    plantId: number
    climateZone: string
    notes: string | null
    _count: PlantClimateZoneCountAggregateOutputType | null
    _avg: PlantClimateZoneAvgAggregateOutputType | null
    _sum: PlantClimateZoneSumAggregateOutputType | null
    _min: PlantClimateZoneMinAggregateOutputType | null
    _max: PlantClimateZoneMaxAggregateOutputType | null
  }

  type GetPlantClimateZoneGroupByPayload<T extends PlantClimateZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantClimateZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantClimateZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantClimateZoneGroupByOutputType[P]>
            : GetScalarType<T[P], PlantClimateZoneGroupByOutputType[P]>
        }
      >
    >


  export type PlantClimateZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    climateZone?: boolean
    notes?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantClimateZone"]>

  export type PlantClimateZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    climateZone?: boolean
    notes?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantClimateZone"]>

  export type PlantClimateZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    climateZone?: boolean
    notes?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantClimateZone"]>

  export type PlantClimateZoneSelectScalar = {
    id?: boolean
    plantId?: boolean
    climateZone?: boolean
    notes?: boolean
  }

  export type PlantClimateZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantId" | "climateZone" | "notes", ExtArgs["result"]["plantClimateZone"]>
  export type PlantClimateZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantClimateZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantClimateZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }

  export type $PlantClimateZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantClimateZone"
    objects: {
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      climateZone: string
      notes: string | null
    }, ExtArgs["result"]["plantClimateZone"]>
    composites: {}
  }

  type PlantClimateZoneGetPayload<S extends boolean | null | undefined | PlantClimateZoneDefaultArgs> = $Result.GetResult<Prisma.$PlantClimateZonePayload, S>

  type PlantClimateZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantClimateZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantClimateZoneCountAggregateInputType | true
    }

  export interface PlantClimateZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantClimateZone'], meta: { name: 'PlantClimateZone' } }
    /**
     * Find zero or one PlantClimateZone that matches the filter.
     * @param {PlantClimateZoneFindUniqueArgs} args - Arguments to find a PlantClimateZone
     * @example
     * // Get one PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantClimateZoneFindUniqueArgs>(args: SelectSubset<T, PlantClimateZoneFindUniqueArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantClimateZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantClimateZoneFindUniqueOrThrowArgs} args - Arguments to find a PlantClimateZone
     * @example
     * // Get one PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantClimateZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantClimateZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantClimateZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneFindFirstArgs} args - Arguments to find a PlantClimateZone
     * @example
     * // Get one PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantClimateZoneFindFirstArgs>(args?: SelectSubset<T, PlantClimateZoneFindFirstArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantClimateZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneFindFirstOrThrowArgs} args - Arguments to find a PlantClimateZone
     * @example
     * // Get one PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantClimateZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantClimateZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantClimateZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantClimateZones
     * const plantClimateZones = await prisma.plantClimateZone.findMany()
     * 
     * // Get first 10 PlantClimateZones
     * const plantClimateZones = await prisma.plantClimateZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantClimateZoneWithIdOnly = await prisma.plantClimateZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantClimateZoneFindManyArgs>(args?: SelectSubset<T, PlantClimateZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantClimateZone.
     * @param {PlantClimateZoneCreateArgs} args - Arguments to create a PlantClimateZone.
     * @example
     * // Create one PlantClimateZone
     * const PlantClimateZone = await prisma.plantClimateZone.create({
     *   data: {
     *     // ... data to create a PlantClimateZone
     *   }
     * })
     * 
     */
    create<T extends PlantClimateZoneCreateArgs>(args: SelectSubset<T, PlantClimateZoneCreateArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantClimateZones.
     * @param {PlantClimateZoneCreateManyArgs} args - Arguments to create many PlantClimateZones.
     * @example
     * // Create many PlantClimateZones
     * const plantClimateZone = await prisma.plantClimateZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantClimateZoneCreateManyArgs>(args?: SelectSubset<T, PlantClimateZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantClimateZones and returns the data saved in the database.
     * @param {PlantClimateZoneCreateManyAndReturnArgs} args - Arguments to create many PlantClimateZones.
     * @example
     * // Create many PlantClimateZones
     * const plantClimateZone = await prisma.plantClimateZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantClimateZones and only return the `id`
     * const plantClimateZoneWithIdOnly = await prisma.plantClimateZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantClimateZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantClimateZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantClimateZone.
     * @param {PlantClimateZoneDeleteArgs} args - Arguments to delete one PlantClimateZone.
     * @example
     * // Delete one PlantClimateZone
     * const PlantClimateZone = await prisma.plantClimateZone.delete({
     *   where: {
     *     // ... filter to delete one PlantClimateZone
     *   }
     * })
     * 
     */
    delete<T extends PlantClimateZoneDeleteArgs>(args: SelectSubset<T, PlantClimateZoneDeleteArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantClimateZone.
     * @param {PlantClimateZoneUpdateArgs} args - Arguments to update one PlantClimateZone.
     * @example
     * // Update one PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantClimateZoneUpdateArgs>(args: SelectSubset<T, PlantClimateZoneUpdateArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantClimateZones.
     * @param {PlantClimateZoneDeleteManyArgs} args - Arguments to filter PlantClimateZones to delete.
     * @example
     * // Delete a few PlantClimateZones
     * const { count } = await prisma.plantClimateZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantClimateZoneDeleteManyArgs>(args?: SelectSubset<T, PlantClimateZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantClimateZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantClimateZones
     * const plantClimateZone = await prisma.plantClimateZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantClimateZoneUpdateManyArgs>(args: SelectSubset<T, PlantClimateZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantClimateZones and returns the data updated in the database.
     * @param {PlantClimateZoneUpdateManyAndReturnArgs} args - Arguments to update many PlantClimateZones.
     * @example
     * // Update many PlantClimateZones
     * const plantClimateZone = await prisma.plantClimateZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantClimateZones and only return the `id`
     * const plantClimateZoneWithIdOnly = await prisma.plantClimateZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantClimateZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantClimateZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantClimateZone.
     * @param {PlantClimateZoneUpsertArgs} args - Arguments to update or create a PlantClimateZone.
     * @example
     * // Update or create a PlantClimateZone
     * const plantClimateZone = await prisma.plantClimateZone.upsert({
     *   create: {
     *     // ... data to create a PlantClimateZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantClimateZone we want to update
     *   }
     * })
     */
    upsert<T extends PlantClimateZoneUpsertArgs>(args: SelectSubset<T, PlantClimateZoneUpsertArgs<ExtArgs>>): Prisma__PlantClimateZoneClient<$Result.GetResult<Prisma.$PlantClimateZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantClimateZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneCountArgs} args - Arguments to filter PlantClimateZones to count.
     * @example
     * // Count the number of PlantClimateZones
     * const count = await prisma.plantClimateZone.count({
     *   where: {
     *     // ... the filter for the PlantClimateZones we want to count
     *   }
     * })
    **/
    count<T extends PlantClimateZoneCountArgs>(
      args?: Subset<T, PlantClimateZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantClimateZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantClimateZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantClimateZoneAggregateArgs>(args: Subset<T, PlantClimateZoneAggregateArgs>): Prisma.PrismaPromise<GetPlantClimateZoneAggregateType<T>>

    /**
     * Group by PlantClimateZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantClimateZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantClimateZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantClimateZoneGroupByArgs['orderBy'] }
        : { orderBy?: PlantClimateZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantClimateZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantClimateZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantClimateZone model
   */
  readonly fields: PlantClimateZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantClimateZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantClimateZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantClimateZone model
   */
  interface PlantClimateZoneFieldRefs {
    readonly id: FieldRef<"PlantClimateZone", 'Int'>
    readonly plantId: FieldRef<"PlantClimateZone", 'Int'>
    readonly climateZone: FieldRef<"PlantClimateZone", 'String'>
    readonly notes: FieldRef<"PlantClimateZone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlantClimateZone findUnique
   */
  export type PlantClimateZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter, which PlantClimateZone to fetch.
     */
    where: PlantClimateZoneWhereUniqueInput
  }

  /**
   * PlantClimateZone findUniqueOrThrow
   */
  export type PlantClimateZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter, which PlantClimateZone to fetch.
     */
    where: PlantClimateZoneWhereUniqueInput
  }

  /**
   * PlantClimateZone findFirst
   */
  export type PlantClimateZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter, which PlantClimateZone to fetch.
     */
    where?: PlantClimateZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantClimateZones to fetch.
     */
    orderBy?: PlantClimateZoneOrderByWithRelationInput | PlantClimateZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantClimateZones.
     */
    cursor?: PlantClimateZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantClimateZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantClimateZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantClimateZones.
     */
    distinct?: PlantClimateZoneScalarFieldEnum | PlantClimateZoneScalarFieldEnum[]
  }

  /**
   * PlantClimateZone findFirstOrThrow
   */
  export type PlantClimateZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter, which PlantClimateZone to fetch.
     */
    where?: PlantClimateZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantClimateZones to fetch.
     */
    orderBy?: PlantClimateZoneOrderByWithRelationInput | PlantClimateZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantClimateZones.
     */
    cursor?: PlantClimateZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantClimateZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantClimateZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantClimateZones.
     */
    distinct?: PlantClimateZoneScalarFieldEnum | PlantClimateZoneScalarFieldEnum[]
  }

  /**
   * PlantClimateZone findMany
   */
  export type PlantClimateZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter, which PlantClimateZones to fetch.
     */
    where?: PlantClimateZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantClimateZones to fetch.
     */
    orderBy?: PlantClimateZoneOrderByWithRelationInput | PlantClimateZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantClimateZones.
     */
    cursor?: PlantClimateZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantClimateZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantClimateZones.
     */
    skip?: number
    distinct?: PlantClimateZoneScalarFieldEnum | PlantClimateZoneScalarFieldEnum[]
  }

  /**
   * PlantClimateZone create
   */
  export type PlantClimateZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantClimateZone.
     */
    data: XOR<PlantClimateZoneCreateInput, PlantClimateZoneUncheckedCreateInput>
  }

  /**
   * PlantClimateZone createMany
   */
  export type PlantClimateZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantClimateZones.
     */
    data: PlantClimateZoneCreateManyInput | PlantClimateZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantClimateZone createManyAndReturn
   */
  export type PlantClimateZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * The data used to create many PlantClimateZones.
     */
    data: PlantClimateZoneCreateManyInput | PlantClimateZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantClimateZone update
   */
  export type PlantClimateZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantClimateZone.
     */
    data: XOR<PlantClimateZoneUpdateInput, PlantClimateZoneUncheckedUpdateInput>
    /**
     * Choose, which PlantClimateZone to update.
     */
    where: PlantClimateZoneWhereUniqueInput
  }

  /**
   * PlantClimateZone updateMany
   */
  export type PlantClimateZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantClimateZones.
     */
    data: XOR<PlantClimateZoneUpdateManyMutationInput, PlantClimateZoneUncheckedUpdateManyInput>
    /**
     * Filter which PlantClimateZones to update
     */
    where?: PlantClimateZoneWhereInput
    /**
     * Limit how many PlantClimateZones to update.
     */
    limit?: number
  }

  /**
   * PlantClimateZone updateManyAndReturn
   */
  export type PlantClimateZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * The data used to update PlantClimateZones.
     */
    data: XOR<PlantClimateZoneUpdateManyMutationInput, PlantClimateZoneUncheckedUpdateManyInput>
    /**
     * Filter which PlantClimateZones to update
     */
    where?: PlantClimateZoneWhereInput
    /**
     * Limit how many PlantClimateZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantClimateZone upsert
   */
  export type PlantClimateZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantClimateZone to update in case it exists.
     */
    where: PlantClimateZoneWhereUniqueInput
    /**
     * In case the PlantClimateZone found by the `where` argument doesn't exist, create a new PlantClimateZone with this data.
     */
    create: XOR<PlantClimateZoneCreateInput, PlantClimateZoneUncheckedCreateInput>
    /**
     * In case the PlantClimateZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantClimateZoneUpdateInput, PlantClimateZoneUncheckedUpdateInput>
  }

  /**
   * PlantClimateZone delete
   */
  export type PlantClimateZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
    /**
     * Filter which PlantClimateZone to delete.
     */
    where: PlantClimateZoneWhereUniqueInput
  }

  /**
   * PlantClimateZone deleteMany
   */
  export type PlantClimateZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantClimateZones to delete
     */
    where?: PlantClimateZoneWhereInput
    /**
     * Limit how many PlantClimateZones to delete.
     */
    limit?: number
  }

  /**
   * PlantClimateZone without action
   */
  export type PlantClimateZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantClimateZone
     */
    select?: PlantClimateZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantClimateZone
     */
    omit?: PlantClimateZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantClimateZoneInclude<ExtArgs> | null
  }


  /**
   * Model PlantVariety
   */

  export type AggregatePlantVariety = {
    _count: PlantVarietyCountAggregateOutputType | null
    _avg: PlantVarietyAvgAggregateOutputType | null
    _sum: PlantVarietySumAggregateOutputType | null
    _min: PlantVarietyMinAggregateOutputType | null
    _max: PlantVarietyMaxAggregateOutputType | null
  }

  export type PlantVarietyAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type PlantVarietySumAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type PlantVarietyMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    varietyName: string | null
    description: string | null
    specificTraits: string | null
    specificCareNeeds: string | null
    imageUrl: string | null
  }

  export type PlantVarietyMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    varietyName: string | null
    description: string | null
    specificTraits: string | null
    specificCareNeeds: string | null
    imageUrl: string | null
  }

  export type PlantVarietyCountAggregateOutputType = {
    id: number
    plantId: number
    varietyName: number
    description: number
    specificTraits: number
    specificCareNeeds: number
    imageUrl: number
    _all: number
  }


  export type PlantVarietyAvgAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type PlantVarietySumAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type PlantVarietyMinAggregateInputType = {
    id?: true
    plantId?: true
    varietyName?: true
    description?: true
    specificTraits?: true
    specificCareNeeds?: true
    imageUrl?: true
  }

  export type PlantVarietyMaxAggregateInputType = {
    id?: true
    plantId?: true
    varietyName?: true
    description?: true
    specificTraits?: true
    specificCareNeeds?: true
    imageUrl?: true
  }

  export type PlantVarietyCountAggregateInputType = {
    id?: true
    plantId?: true
    varietyName?: true
    description?: true
    specificTraits?: true
    specificCareNeeds?: true
    imageUrl?: true
    _all?: true
  }

  export type PlantVarietyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantVariety to aggregate.
     */
    where?: PlantVarietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantVarieties to fetch.
     */
    orderBy?: PlantVarietyOrderByWithRelationInput | PlantVarietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantVarietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantVarieties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantVarieties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantVarieties
    **/
    _count?: true | PlantVarietyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantVarietyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantVarietySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantVarietyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantVarietyMaxAggregateInputType
  }

  export type GetPlantVarietyAggregateType<T extends PlantVarietyAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantVariety]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantVariety[P]>
      : GetScalarType<T[P], AggregatePlantVariety[P]>
  }




  export type PlantVarietyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantVarietyWhereInput
    orderBy?: PlantVarietyOrderByWithAggregationInput | PlantVarietyOrderByWithAggregationInput[]
    by: PlantVarietyScalarFieldEnum[] | PlantVarietyScalarFieldEnum
    having?: PlantVarietyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantVarietyCountAggregateInputType | true
    _avg?: PlantVarietyAvgAggregateInputType
    _sum?: PlantVarietySumAggregateInputType
    _min?: PlantVarietyMinAggregateInputType
    _max?: PlantVarietyMaxAggregateInputType
  }

  export type PlantVarietyGroupByOutputType = {
    id: number
    plantId: number
    varietyName: string
    description: string | null
    specificTraits: string | null
    specificCareNeeds: string | null
    imageUrl: string | null
    _count: PlantVarietyCountAggregateOutputType | null
    _avg: PlantVarietyAvgAggregateOutputType | null
    _sum: PlantVarietySumAggregateOutputType | null
    _min: PlantVarietyMinAggregateOutputType | null
    _max: PlantVarietyMaxAggregateOutputType | null
  }

  type GetPlantVarietyGroupByPayload<T extends PlantVarietyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantVarietyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantVarietyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantVarietyGroupByOutputType[P]>
            : GetScalarType<T[P], PlantVarietyGroupByOutputType[P]>
        }
      >
    >


  export type PlantVarietySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    varietyName?: boolean
    description?: boolean
    specificTraits?: boolean
    specificCareNeeds?: boolean
    imageUrl?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    containerPlants?: boolean | PlantVariety$containerPlantsArgs<ExtArgs>
    plannedPlantings?: boolean | PlantVariety$plannedPlantingsArgs<ExtArgs>
    _count?: boolean | PlantVarietyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantVariety"]>

  export type PlantVarietySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    varietyName?: boolean
    description?: boolean
    specificTraits?: boolean
    specificCareNeeds?: boolean
    imageUrl?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantVariety"]>

  export type PlantVarietySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    varietyName?: boolean
    description?: boolean
    specificTraits?: boolean
    specificCareNeeds?: boolean
    imageUrl?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantVariety"]>

  export type PlantVarietySelectScalar = {
    id?: boolean
    plantId?: boolean
    varietyName?: boolean
    description?: boolean
    specificTraits?: boolean
    specificCareNeeds?: boolean
    imageUrl?: boolean
  }

  export type PlantVarietyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantId" | "varietyName" | "description" | "specificTraits" | "specificCareNeeds" | "imageUrl", ExtArgs["result"]["plantVariety"]>
  export type PlantVarietyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    containerPlants?: boolean | PlantVariety$containerPlantsArgs<ExtArgs>
    plannedPlantings?: boolean | PlantVariety$plannedPlantingsArgs<ExtArgs>
    _count?: boolean | PlantVarietyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlantVarietyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantVarietyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }

  export type $PlantVarietyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantVariety"
    objects: {
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
      containerPlants: Prisma.$ContainerPlantPayload<ExtArgs>[]
      plannedPlantings: Prisma.$PlannedPlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      varietyName: string
      description: string | null
      specificTraits: string | null
      specificCareNeeds: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["plantVariety"]>
    composites: {}
  }

  type PlantVarietyGetPayload<S extends boolean | null | undefined | PlantVarietyDefaultArgs> = $Result.GetResult<Prisma.$PlantVarietyPayload, S>

  type PlantVarietyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantVarietyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantVarietyCountAggregateInputType | true
    }

  export interface PlantVarietyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantVariety'], meta: { name: 'PlantVariety' } }
    /**
     * Find zero or one PlantVariety that matches the filter.
     * @param {PlantVarietyFindUniqueArgs} args - Arguments to find a PlantVariety
     * @example
     * // Get one PlantVariety
     * const plantVariety = await prisma.plantVariety.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantVarietyFindUniqueArgs>(args: SelectSubset<T, PlantVarietyFindUniqueArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantVariety that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantVarietyFindUniqueOrThrowArgs} args - Arguments to find a PlantVariety
     * @example
     * // Get one PlantVariety
     * const plantVariety = await prisma.plantVariety.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantVarietyFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantVarietyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantVariety that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyFindFirstArgs} args - Arguments to find a PlantVariety
     * @example
     * // Get one PlantVariety
     * const plantVariety = await prisma.plantVariety.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantVarietyFindFirstArgs>(args?: SelectSubset<T, PlantVarietyFindFirstArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantVariety that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyFindFirstOrThrowArgs} args - Arguments to find a PlantVariety
     * @example
     * // Get one PlantVariety
     * const plantVariety = await prisma.plantVariety.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantVarietyFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantVarietyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantVarieties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantVarieties
     * const plantVarieties = await prisma.plantVariety.findMany()
     * 
     * // Get first 10 PlantVarieties
     * const plantVarieties = await prisma.plantVariety.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantVarietyWithIdOnly = await prisma.plantVariety.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantVarietyFindManyArgs>(args?: SelectSubset<T, PlantVarietyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantVariety.
     * @param {PlantVarietyCreateArgs} args - Arguments to create a PlantVariety.
     * @example
     * // Create one PlantVariety
     * const PlantVariety = await prisma.plantVariety.create({
     *   data: {
     *     // ... data to create a PlantVariety
     *   }
     * })
     * 
     */
    create<T extends PlantVarietyCreateArgs>(args: SelectSubset<T, PlantVarietyCreateArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantVarieties.
     * @param {PlantVarietyCreateManyArgs} args - Arguments to create many PlantVarieties.
     * @example
     * // Create many PlantVarieties
     * const plantVariety = await prisma.plantVariety.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantVarietyCreateManyArgs>(args?: SelectSubset<T, PlantVarietyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantVarieties and returns the data saved in the database.
     * @param {PlantVarietyCreateManyAndReturnArgs} args - Arguments to create many PlantVarieties.
     * @example
     * // Create many PlantVarieties
     * const plantVariety = await prisma.plantVariety.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantVarieties and only return the `id`
     * const plantVarietyWithIdOnly = await prisma.plantVariety.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantVarietyCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantVarietyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantVariety.
     * @param {PlantVarietyDeleteArgs} args - Arguments to delete one PlantVariety.
     * @example
     * // Delete one PlantVariety
     * const PlantVariety = await prisma.plantVariety.delete({
     *   where: {
     *     // ... filter to delete one PlantVariety
     *   }
     * })
     * 
     */
    delete<T extends PlantVarietyDeleteArgs>(args: SelectSubset<T, PlantVarietyDeleteArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantVariety.
     * @param {PlantVarietyUpdateArgs} args - Arguments to update one PlantVariety.
     * @example
     * // Update one PlantVariety
     * const plantVariety = await prisma.plantVariety.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantVarietyUpdateArgs>(args: SelectSubset<T, PlantVarietyUpdateArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantVarieties.
     * @param {PlantVarietyDeleteManyArgs} args - Arguments to filter PlantVarieties to delete.
     * @example
     * // Delete a few PlantVarieties
     * const { count } = await prisma.plantVariety.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantVarietyDeleteManyArgs>(args?: SelectSubset<T, PlantVarietyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantVarieties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantVarieties
     * const plantVariety = await prisma.plantVariety.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantVarietyUpdateManyArgs>(args: SelectSubset<T, PlantVarietyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantVarieties and returns the data updated in the database.
     * @param {PlantVarietyUpdateManyAndReturnArgs} args - Arguments to update many PlantVarieties.
     * @example
     * // Update many PlantVarieties
     * const plantVariety = await prisma.plantVariety.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantVarieties and only return the `id`
     * const plantVarietyWithIdOnly = await prisma.plantVariety.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantVarietyUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantVarietyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantVariety.
     * @param {PlantVarietyUpsertArgs} args - Arguments to update or create a PlantVariety.
     * @example
     * // Update or create a PlantVariety
     * const plantVariety = await prisma.plantVariety.upsert({
     *   create: {
     *     // ... data to create a PlantVariety
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantVariety we want to update
     *   }
     * })
     */
    upsert<T extends PlantVarietyUpsertArgs>(args: SelectSubset<T, PlantVarietyUpsertArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantVarieties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyCountArgs} args - Arguments to filter PlantVarieties to count.
     * @example
     * // Count the number of PlantVarieties
     * const count = await prisma.plantVariety.count({
     *   where: {
     *     // ... the filter for the PlantVarieties we want to count
     *   }
     * })
    **/
    count<T extends PlantVarietyCountArgs>(
      args?: Subset<T, PlantVarietyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantVarietyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantVariety.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantVarietyAggregateArgs>(args: Subset<T, PlantVarietyAggregateArgs>): Prisma.PrismaPromise<GetPlantVarietyAggregateType<T>>

    /**
     * Group by PlantVariety.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantVarietyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantVarietyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantVarietyGroupByArgs['orderBy'] }
        : { orderBy?: PlantVarietyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantVarietyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantVarietyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantVariety model
   */
  readonly fields: PlantVarietyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantVariety.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantVarietyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    containerPlants<T extends PlantVariety$containerPlantsArgs<ExtArgs> = {}>(args?: Subset<T, PlantVariety$containerPlantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plannedPlantings<T extends PlantVariety$plannedPlantingsArgs<ExtArgs> = {}>(args?: Subset<T, PlantVariety$plannedPlantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantVariety model
   */
  interface PlantVarietyFieldRefs {
    readonly id: FieldRef<"PlantVariety", 'Int'>
    readonly plantId: FieldRef<"PlantVariety", 'Int'>
    readonly varietyName: FieldRef<"PlantVariety", 'String'>
    readonly description: FieldRef<"PlantVariety", 'String'>
    readonly specificTraits: FieldRef<"PlantVariety", 'String'>
    readonly specificCareNeeds: FieldRef<"PlantVariety", 'String'>
    readonly imageUrl: FieldRef<"PlantVariety", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlantVariety findUnique
   */
  export type PlantVarietyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter, which PlantVariety to fetch.
     */
    where: PlantVarietyWhereUniqueInput
  }

  /**
   * PlantVariety findUniqueOrThrow
   */
  export type PlantVarietyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter, which PlantVariety to fetch.
     */
    where: PlantVarietyWhereUniqueInput
  }

  /**
   * PlantVariety findFirst
   */
  export type PlantVarietyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter, which PlantVariety to fetch.
     */
    where?: PlantVarietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantVarieties to fetch.
     */
    orderBy?: PlantVarietyOrderByWithRelationInput | PlantVarietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantVarieties.
     */
    cursor?: PlantVarietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantVarieties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantVarieties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantVarieties.
     */
    distinct?: PlantVarietyScalarFieldEnum | PlantVarietyScalarFieldEnum[]
  }

  /**
   * PlantVariety findFirstOrThrow
   */
  export type PlantVarietyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter, which PlantVariety to fetch.
     */
    where?: PlantVarietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantVarieties to fetch.
     */
    orderBy?: PlantVarietyOrderByWithRelationInput | PlantVarietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantVarieties.
     */
    cursor?: PlantVarietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantVarieties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantVarieties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantVarieties.
     */
    distinct?: PlantVarietyScalarFieldEnum | PlantVarietyScalarFieldEnum[]
  }

  /**
   * PlantVariety findMany
   */
  export type PlantVarietyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter, which PlantVarieties to fetch.
     */
    where?: PlantVarietyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantVarieties to fetch.
     */
    orderBy?: PlantVarietyOrderByWithRelationInput | PlantVarietyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantVarieties.
     */
    cursor?: PlantVarietyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantVarieties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantVarieties.
     */
    skip?: number
    distinct?: PlantVarietyScalarFieldEnum | PlantVarietyScalarFieldEnum[]
  }

  /**
   * PlantVariety create
   */
  export type PlantVarietyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantVariety.
     */
    data: XOR<PlantVarietyCreateInput, PlantVarietyUncheckedCreateInput>
  }

  /**
   * PlantVariety createMany
   */
  export type PlantVarietyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantVarieties.
     */
    data: PlantVarietyCreateManyInput | PlantVarietyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantVariety createManyAndReturn
   */
  export type PlantVarietyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * The data used to create many PlantVarieties.
     */
    data: PlantVarietyCreateManyInput | PlantVarietyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantVariety update
   */
  export type PlantVarietyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantVariety.
     */
    data: XOR<PlantVarietyUpdateInput, PlantVarietyUncheckedUpdateInput>
    /**
     * Choose, which PlantVariety to update.
     */
    where: PlantVarietyWhereUniqueInput
  }

  /**
   * PlantVariety updateMany
   */
  export type PlantVarietyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantVarieties.
     */
    data: XOR<PlantVarietyUpdateManyMutationInput, PlantVarietyUncheckedUpdateManyInput>
    /**
     * Filter which PlantVarieties to update
     */
    where?: PlantVarietyWhereInput
    /**
     * Limit how many PlantVarieties to update.
     */
    limit?: number
  }

  /**
   * PlantVariety updateManyAndReturn
   */
  export type PlantVarietyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * The data used to update PlantVarieties.
     */
    data: XOR<PlantVarietyUpdateManyMutationInput, PlantVarietyUncheckedUpdateManyInput>
    /**
     * Filter which PlantVarieties to update
     */
    where?: PlantVarietyWhereInput
    /**
     * Limit how many PlantVarieties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantVariety upsert
   */
  export type PlantVarietyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantVariety to update in case it exists.
     */
    where: PlantVarietyWhereUniqueInput
    /**
     * In case the PlantVariety found by the `where` argument doesn't exist, create a new PlantVariety with this data.
     */
    create: XOR<PlantVarietyCreateInput, PlantVarietyUncheckedCreateInput>
    /**
     * In case the PlantVariety was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantVarietyUpdateInput, PlantVarietyUncheckedUpdateInput>
  }

  /**
   * PlantVariety delete
   */
  export type PlantVarietyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    /**
     * Filter which PlantVariety to delete.
     */
    where: PlantVarietyWhereUniqueInput
  }

  /**
   * PlantVariety deleteMany
   */
  export type PlantVarietyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantVarieties to delete
     */
    where?: PlantVarietyWhereInput
    /**
     * Limit how many PlantVarieties to delete.
     */
    limit?: number
  }

  /**
   * PlantVariety.containerPlants
   */
  export type PlantVariety$containerPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    where?: ContainerPlantWhereInput
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    cursor?: ContainerPlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * PlantVariety.plannedPlantings
   */
  export type PlantVariety$plannedPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    where?: PlannedPlantingWhereInput
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    cursor?: PlannedPlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * PlantVariety without action
   */
  export type PlantVarietyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
  }


  /**
   * Model PlantCompanion
   */

  export type AggregatePlantCompanion = {
    _count: PlantCompanionCountAggregateOutputType | null
    _avg: PlantCompanionAvgAggregateOutputType | null
    _sum: PlantCompanionSumAggregateOutputType | null
    _min: PlantCompanionMinAggregateOutputType | null
    _max: PlantCompanionMaxAggregateOutputType | null
  }

  export type PlantCompanionAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
    companionPlantId: number | null
  }

  export type PlantCompanionSumAggregateOutputType = {
    id: number | null
    plantId: number | null
    companionPlantId: number | null
  }

  export type PlantCompanionMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    companionPlantId: number | null
    relationshipType: string | null
    effectDescription: string | null
  }

  export type PlantCompanionMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    companionPlantId: number | null
    relationshipType: string | null
    effectDescription: string | null
  }

  export type PlantCompanionCountAggregateOutputType = {
    id: number
    plantId: number
    companionPlantId: number
    relationshipType: number
    effectDescription: number
    _all: number
  }


  export type PlantCompanionAvgAggregateInputType = {
    id?: true
    plantId?: true
    companionPlantId?: true
  }

  export type PlantCompanionSumAggregateInputType = {
    id?: true
    plantId?: true
    companionPlantId?: true
  }

  export type PlantCompanionMinAggregateInputType = {
    id?: true
    plantId?: true
    companionPlantId?: true
    relationshipType?: true
    effectDescription?: true
  }

  export type PlantCompanionMaxAggregateInputType = {
    id?: true
    plantId?: true
    companionPlantId?: true
    relationshipType?: true
    effectDescription?: true
  }

  export type PlantCompanionCountAggregateInputType = {
    id?: true
    plantId?: true
    companionPlantId?: true
    relationshipType?: true
    effectDescription?: true
    _all?: true
  }

  export type PlantCompanionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantCompanion to aggregate.
     */
    where?: PlantCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCompanions to fetch.
     */
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantCompanions
    **/
    _count?: true | PlantCompanionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantCompanionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantCompanionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantCompanionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantCompanionMaxAggregateInputType
  }

  export type GetPlantCompanionAggregateType<T extends PlantCompanionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantCompanion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantCompanion[P]>
      : GetScalarType<T[P], AggregatePlantCompanion[P]>
  }




  export type PlantCompanionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantCompanionWhereInput
    orderBy?: PlantCompanionOrderByWithAggregationInput | PlantCompanionOrderByWithAggregationInput[]
    by: PlantCompanionScalarFieldEnum[] | PlantCompanionScalarFieldEnum
    having?: PlantCompanionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantCompanionCountAggregateInputType | true
    _avg?: PlantCompanionAvgAggregateInputType
    _sum?: PlantCompanionSumAggregateInputType
    _min?: PlantCompanionMinAggregateInputType
    _max?: PlantCompanionMaxAggregateInputType
  }

  export type PlantCompanionGroupByOutputType = {
    id: number
    plantId: number
    companionPlantId: number
    relationshipType: string
    effectDescription: string | null
    _count: PlantCompanionCountAggregateOutputType | null
    _avg: PlantCompanionAvgAggregateOutputType | null
    _sum: PlantCompanionSumAggregateOutputType | null
    _min: PlantCompanionMinAggregateOutputType | null
    _max: PlantCompanionMaxAggregateOutputType | null
  }

  type GetPlantCompanionGroupByPayload<T extends PlantCompanionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantCompanionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantCompanionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantCompanionGroupByOutputType[P]>
            : GetScalarType<T[P], PlantCompanionGroupByOutputType[P]>
        }
      >
    >


  export type PlantCompanionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    companionPlantId?: boolean
    relationshipType?: boolean
    effectDescription?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantCompanion"]>

  export type PlantCompanionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    companionPlantId?: boolean
    relationshipType?: boolean
    effectDescription?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantCompanion"]>

  export type PlantCompanionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    companionPlantId?: boolean
    relationshipType?: boolean
    effectDescription?: boolean
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantCompanion"]>

  export type PlantCompanionSelectScalar = {
    id?: boolean
    plantId?: boolean
    companionPlantId?: boolean
    relationshipType?: boolean
    effectDescription?: boolean
  }

  export type PlantCompanionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantId" | "companionPlantId" | "relationshipType" | "effectDescription", ExtArgs["result"]["plantCompanion"]>
  export type PlantCompanionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantCompanionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }
  export type PlantCompanionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    companionPlant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
  }

  export type $PlantCompanionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantCompanion"
    objects: {
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
      companionPlant: Prisma.$PlantCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      companionPlantId: number
      relationshipType: string
      effectDescription: string | null
    }, ExtArgs["result"]["plantCompanion"]>
    composites: {}
  }

  type PlantCompanionGetPayload<S extends boolean | null | undefined | PlantCompanionDefaultArgs> = $Result.GetResult<Prisma.$PlantCompanionPayload, S>

  type PlantCompanionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantCompanionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantCompanionCountAggregateInputType | true
    }

  export interface PlantCompanionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantCompanion'], meta: { name: 'PlantCompanion' } }
    /**
     * Find zero or one PlantCompanion that matches the filter.
     * @param {PlantCompanionFindUniqueArgs} args - Arguments to find a PlantCompanion
     * @example
     * // Get one PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantCompanionFindUniqueArgs>(args: SelectSubset<T, PlantCompanionFindUniqueArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantCompanion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantCompanionFindUniqueOrThrowArgs} args - Arguments to find a PlantCompanion
     * @example
     * // Get one PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantCompanionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantCompanionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantCompanion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionFindFirstArgs} args - Arguments to find a PlantCompanion
     * @example
     * // Get one PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantCompanionFindFirstArgs>(args?: SelectSubset<T, PlantCompanionFindFirstArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantCompanion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionFindFirstOrThrowArgs} args - Arguments to find a PlantCompanion
     * @example
     * // Get one PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantCompanionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantCompanionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantCompanions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantCompanions
     * const plantCompanions = await prisma.plantCompanion.findMany()
     * 
     * // Get first 10 PlantCompanions
     * const plantCompanions = await prisma.plantCompanion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantCompanionWithIdOnly = await prisma.plantCompanion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantCompanionFindManyArgs>(args?: SelectSubset<T, PlantCompanionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantCompanion.
     * @param {PlantCompanionCreateArgs} args - Arguments to create a PlantCompanion.
     * @example
     * // Create one PlantCompanion
     * const PlantCompanion = await prisma.plantCompanion.create({
     *   data: {
     *     // ... data to create a PlantCompanion
     *   }
     * })
     * 
     */
    create<T extends PlantCompanionCreateArgs>(args: SelectSubset<T, PlantCompanionCreateArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantCompanions.
     * @param {PlantCompanionCreateManyArgs} args - Arguments to create many PlantCompanions.
     * @example
     * // Create many PlantCompanions
     * const plantCompanion = await prisma.plantCompanion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantCompanionCreateManyArgs>(args?: SelectSubset<T, PlantCompanionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantCompanions and returns the data saved in the database.
     * @param {PlantCompanionCreateManyAndReturnArgs} args - Arguments to create many PlantCompanions.
     * @example
     * // Create many PlantCompanions
     * const plantCompanion = await prisma.plantCompanion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantCompanions and only return the `id`
     * const plantCompanionWithIdOnly = await prisma.plantCompanion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantCompanionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantCompanionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantCompanion.
     * @param {PlantCompanionDeleteArgs} args - Arguments to delete one PlantCompanion.
     * @example
     * // Delete one PlantCompanion
     * const PlantCompanion = await prisma.plantCompanion.delete({
     *   where: {
     *     // ... filter to delete one PlantCompanion
     *   }
     * })
     * 
     */
    delete<T extends PlantCompanionDeleteArgs>(args: SelectSubset<T, PlantCompanionDeleteArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantCompanion.
     * @param {PlantCompanionUpdateArgs} args - Arguments to update one PlantCompanion.
     * @example
     * // Update one PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantCompanionUpdateArgs>(args: SelectSubset<T, PlantCompanionUpdateArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantCompanions.
     * @param {PlantCompanionDeleteManyArgs} args - Arguments to filter PlantCompanions to delete.
     * @example
     * // Delete a few PlantCompanions
     * const { count } = await prisma.plantCompanion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantCompanionDeleteManyArgs>(args?: SelectSubset<T, PlantCompanionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantCompanions
     * const plantCompanion = await prisma.plantCompanion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantCompanionUpdateManyArgs>(args: SelectSubset<T, PlantCompanionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantCompanions and returns the data updated in the database.
     * @param {PlantCompanionUpdateManyAndReturnArgs} args - Arguments to update many PlantCompanions.
     * @example
     * // Update many PlantCompanions
     * const plantCompanion = await prisma.plantCompanion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantCompanions and only return the `id`
     * const plantCompanionWithIdOnly = await prisma.plantCompanion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantCompanionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantCompanionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantCompanion.
     * @param {PlantCompanionUpsertArgs} args - Arguments to update or create a PlantCompanion.
     * @example
     * // Update or create a PlantCompanion
     * const plantCompanion = await prisma.plantCompanion.upsert({
     *   create: {
     *     // ... data to create a PlantCompanion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantCompanion we want to update
     *   }
     * })
     */
    upsert<T extends PlantCompanionUpsertArgs>(args: SelectSubset<T, PlantCompanionUpsertArgs<ExtArgs>>): Prisma__PlantCompanionClient<$Result.GetResult<Prisma.$PlantCompanionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionCountArgs} args - Arguments to filter PlantCompanions to count.
     * @example
     * // Count the number of PlantCompanions
     * const count = await prisma.plantCompanion.count({
     *   where: {
     *     // ... the filter for the PlantCompanions we want to count
     *   }
     * })
    **/
    count<T extends PlantCompanionCountArgs>(
      args?: Subset<T, PlantCompanionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantCompanionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantCompanionAggregateArgs>(args: Subset<T, PlantCompanionAggregateArgs>): Prisma.PrismaPromise<GetPlantCompanionAggregateType<T>>

    /**
     * Group by PlantCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCompanionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantCompanionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantCompanionGroupByArgs['orderBy'] }
        : { orderBy?: PlantCompanionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantCompanionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantCompanionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantCompanion model
   */
  readonly fields: PlantCompanionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantCompanion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantCompanionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companionPlant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantCompanion model
   */
  interface PlantCompanionFieldRefs {
    readonly id: FieldRef<"PlantCompanion", 'Int'>
    readonly plantId: FieldRef<"PlantCompanion", 'Int'>
    readonly companionPlantId: FieldRef<"PlantCompanion", 'Int'>
    readonly relationshipType: FieldRef<"PlantCompanion", 'String'>
    readonly effectDescription: FieldRef<"PlantCompanion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlantCompanion findUnique
   */
  export type PlantCompanionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlantCompanion to fetch.
     */
    where: PlantCompanionWhereUniqueInput
  }

  /**
   * PlantCompanion findUniqueOrThrow
   */
  export type PlantCompanionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlantCompanion to fetch.
     */
    where: PlantCompanionWhereUniqueInput
  }

  /**
   * PlantCompanion findFirst
   */
  export type PlantCompanionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlantCompanion to fetch.
     */
    where?: PlantCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCompanions to fetch.
     */
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantCompanions.
     */
    cursor?: PlantCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantCompanions.
     */
    distinct?: PlantCompanionScalarFieldEnum | PlantCompanionScalarFieldEnum[]
  }

  /**
   * PlantCompanion findFirstOrThrow
   */
  export type PlantCompanionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlantCompanion to fetch.
     */
    where?: PlantCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCompanions to fetch.
     */
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantCompanions.
     */
    cursor?: PlantCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantCompanions.
     */
    distinct?: PlantCompanionScalarFieldEnum | PlantCompanionScalarFieldEnum[]
  }

  /**
   * PlantCompanion findMany
   */
  export type PlantCompanionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter, which PlantCompanions to fetch.
     */
    where?: PlantCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantCompanions to fetch.
     */
    orderBy?: PlantCompanionOrderByWithRelationInput | PlantCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantCompanions.
     */
    cursor?: PlantCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantCompanions.
     */
    skip?: number
    distinct?: PlantCompanionScalarFieldEnum | PlantCompanionScalarFieldEnum[]
  }

  /**
   * PlantCompanion create
   */
  export type PlantCompanionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantCompanion.
     */
    data: XOR<PlantCompanionCreateInput, PlantCompanionUncheckedCreateInput>
  }

  /**
   * PlantCompanion createMany
   */
  export type PlantCompanionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantCompanions.
     */
    data: PlantCompanionCreateManyInput | PlantCompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantCompanion createManyAndReturn
   */
  export type PlantCompanionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * The data used to create many PlantCompanions.
     */
    data: PlantCompanionCreateManyInput | PlantCompanionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantCompanion update
   */
  export type PlantCompanionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantCompanion.
     */
    data: XOR<PlantCompanionUpdateInput, PlantCompanionUncheckedUpdateInput>
    /**
     * Choose, which PlantCompanion to update.
     */
    where: PlantCompanionWhereUniqueInput
  }

  /**
   * PlantCompanion updateMany
   */
  export type PlantCompanionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantCompanions.
     */
    data: XOR<PlantCompanionUpdateManyMutationInput, PlantCompanionUncheckedUpdateManyInput>
    /**
     * Filter which PlantCompanions to update
     */
    where?: PlantCompanionWhereInput
    /**
     * Limit how many PlantCompanions to update.
     */
    limit?: number
  }

  /**
   * PlantCompanion updateManyAndReturn
   */
  export type PlantCompanionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * The data used to update PlantCompanions.
     */
    data: XOR<PlantCompanionUpdateManyMutationInput, PlantCompanionUncheckedUpdateManyInput>
    /**
     * Filter which PlantCompanions to update
     */
    where?: PlantCompanionWhereInput
    /**
     * Limit how many PlantCompanions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantCompanion upsert
   */
  export type PlantCompanionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantCompanion to update in case it exists.
     */
    where: PlantCompanionWhereUniqueInput
    /**
     * In case the PlantCompanion found by the `where` argument doesn't exist, create a new PlantCompanion with this data.
     */
    create: XOR<PlantCompanionCreateInput, PlantCompanionUncheckedCreateInput>
    /**
     * In case the PlantCompanion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantCompanionUpdateInput, PlantCompanionUncheckedUpdateInput>
  }

  /**
   * PlantCompanion delete
   */
  export type PlantCompanionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
    /**
     * Filter which PlantCompanion to delete.
     */
    where: PlantCompanionWhereUniqueInput
  }

  /**
   * PlantCompanion deleteMany
   */
  export type PlantCompanionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantCompanions to delete
     */
    where?: PlantCompanionWhereInput
    /**
     * Limit how many PlantCompanions to delete.
     */
    limit?: number
  }

  /**
   * PlantCompanion without action
   */
  export type PlantCompanionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCompanion
     */
    select?: PlantCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantCompanion
     */
    omit?: PlantCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantCompanionInclude<ExtArgs> | null
  }


  /**
   * Model ContainerPlant
   */

  export type AggregateContainerPlant = {
    _count: ContainerPlantCountAggregateOutputType | null
    _avg: ContainerPlantAvgAggregateOutputType | null
    _sum: ContainerPlantSumAggregateOutputType | null
    _min: ContainerPlantMinAggregateOutputType | null
    _max: ContainerPlantMaxAggregateOutputType | null
  }

  export type ContainerPlantAvgAggregateOutputType = {
    id: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
  }

  export type ContainerPlantSumAggregateOutputType = {
    id: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
    positionX: Decimal | null
    positionY: Decimal | null
  }

  export type ContainerPlantMinAggregateOutputType = {
    id: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
    plantDate: Date | null
    initialStage: string | null
    currentStage: string | null
    status: string | null
    positionX: Decimal | null
    positionY: Decimal | null
    expectedHarvestDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerPlantMaxAggregateOutputType = {
    id: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
    plantDate: Date | null
    initialStage: string | null
    currentStage: string | null
    status: string | null
    positionX: Decimal | null
    positionY: Decimal | null
    expectedHarvestDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContainerPlantCountAggregateOutputType = {
    id: number
    containerId: number
    plantId: number
    varietyId: number
    quantity: number
    plantDate: number
    initialStage: number
    currentStage: number
    status: number
    positionX: number
    positionY: number
    expectedHarvestDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContainerPlantAvgAggregateInputType = {
    id?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
    positionX?: true
    positionY?: true
  }

  export type ContainerPlantSumAggregateInputType = {
    id?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
    positionX?: true
    positionY?: true
  }

  export type ContainerPlantMinAggregateInputType = {
    id?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
    plantDate?: true
    initialStage?: true
    currentStage?: true
    status?: true
    positionX?: true
    positionY?: true
    expectedHarvestDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerPlantMaxAggregateInputType = {
    id?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
    plantDate?: true
    initialStage?: true
    currentStage?: true
    status?: true
    positionX?: true
    positionY?: true
    expectedHarvestDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContainerPlantCountAggregateInputType = {
    id?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
    plantDate?: true
    initialStage?: true
    currentStage?: true
    status?: true
    positionX?: true
    positionY?: true
    expectedHarvestDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContainerPlantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerPlant to aggregate.
     */
    where?: ContainerPlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerPlants to fetch.
     */
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerPlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerPlants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerPlants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContainerPlants
    **/
    _count?: true | ContainerPlantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerPlantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerPlantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerPlantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerPlantMaxAggregateInputType
  }

  export type GetContainerPlantAggregateType<T extends ContainerPlantAggregateArgs> = {
        [P in keyof T & keyof AggregateContainerPlant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainerPlant[P]>
      : GetScalarType<T[P], AggregateContainerPlant[P]>
  }




  export type ContainerPlantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerPlantWhereInput
    orderBy?: ContainerPlantOrderByWithAggregationInput | ContainerPlantOrderByWithAggregationInput[]
    by: ContainerPlantScalarFieldEnum[] | ContainerPlantScalarFieldEnum
    having?: ContainerPlantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerPlantCountAggregateInputType | true
    _avg?: ContainerPlantAvgAggregateInputType
    _sum?: ContainerPlantSumAggregateInputType
    _min?: ContainerPlantMinAggregateInputType
    _max?: ContainerPlantMaxAggregateInputType
  }

  export type ContainerPlantGroupByOutputType = {
    id: number
    containerId: number
    plantId: number
    varietyId: number | null
    quantity: Decimal | null
    plantDate: Date
    initialStage: string
    currentStage: string
    status: string
    positionX: Decimal | null
    positionY: Decimal | null
    expectedHarvestDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContainerPlantCountAggregateOutputType | null
    _avg: ContainerPlantAvgAggregateOutputType | null
    _sum: ContainerPlantSumAggregateOutputType | null
    _min: ContainerPlantMinAggregateOutputType | null
    _max: ContainerPlantMaxAggregateOutputType | null
  }

  type GetContainerPlantGroupByPayload<T extends ContainerPlantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerPlantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerPlantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerPlantGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerPlantGroupByOutputType[P]>
        }
      >
    >


  export type ContainerPlantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    quantity?: boolean
    plantDate?: boolean
    initialStage?: boolean
    currentStage?: boolean
    status?: boolean
    positionX?: boolean
    positionY?: boolean
    expectedHarvestDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
    growthStages?: boolean | ContainerPlant$growthStagesArgs<ExtArgs>
    gardenActions?: boolean | ContainerPlant$gardenActionsArgs<ExtArgs>
    harvests?: boolean | ContainerPlant$harvestsArgs<ExtArgs>
    movementHistory?: boolean | ContainerPlant$movementHistoryArgs<ExtArgs>
    tasks?: boolean | ContainerPlant$tasksArgs<ExtArgs>
    _count?: boolean | ContainerPlantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["containerPlant"]>

  export type ContainerPlantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    quantity?: boolean
    plantDate?: boolean
    initialStage?: boolean
    currentStage?: boolean
    status?: boolean
    positionX?: boolean
    positionY?: boolean
    expectedHarvestDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
  }, ExtArgs["result"]["containerPlant"]>

  export type ContainerPlantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    quantity?: boolean
    plantDate?: boolean
    initialStage?: boolean
    currentStage?: boolean
    status?: boolean
    positionX?: boolean
    positionY?: boolean
    expectedHarvestDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
  }, ExtArgs["result"]["containerPlant"]>

  export type ContainerPlantSelectScalar = {
    id?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    quantity?: boolean
    plantDate?: boolean
    initialStage?: boolean
    currentStage?: boolean
    status?: boolean
    positionX?: boolean
    positionY?: boolean
    expectedHarvestDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContainerPlantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerId" | "plantId" | "varietyId" | "quantity" | "plantDate" | "initialStage" | "currentStage" | "status" | "positionX" | "positionY" | "expectedHarvestDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["containerPlant"]>
  export type ContainerPlantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
    growthStages?: boolean | ContainerPlant$growthStagesArgs<ExtArgs>
    gardenActions?: boolean | ContainerPlant$gardenActionsArgs<ExtArgs>
    harvests?: boolean | ContainerPlant$harvestsArgs<ExtArgs>
    movementHistory?: boolean | ContainerPlant$movementHistoryArgs<ExtArgs>
    tasks?: boolean | ContainerPlant$tasksArgs<ExtArgs>
    _count?: boolean | ContainerPlantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContainerPlantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
  }
  export type ContainerPlantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | ContainerPlant$varietyArgs<ExtArgs>
  }

  export type $ContainerPlantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContainerPlant"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
      variety: Prisma.$PlantVarietyPayload<ExtArgs> | null
      growthStages: Prisma.$PlantGrowthStagePayload<ExtArgs>[]
      gardenActions: Prisma.$GardenActionPayload<ExtArgs>[]
      harvests: Prisma.$HarvestPayload<ExtArgs>[]
      movementHistory: Prisma.$PlantMovementHistoryPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      containerId: number
      plantId: number
      varietyId: number | null
      quantity: Prisma.Decimal | null
      plantDate: Date
      initialStage: string
      currentStage: string
      status: string
      positionX: Prisma.Decimal | null
      positionY: Prisma.Decimal | null
      expectedHarvestDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["containerPlant"]>
    composites: {}
  }

  type ContainerPlantGetPayload<S extends boolean | null | undefined | ContainerPlantDefaultArgs> = $Result.GetResult<Prisma.$ContainerPlantPayload, S>

  type ContainerPlantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContainerPlantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContainerPlantCountAggregateInputType | true
    }

  export interface ContainerPlantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContainerPlant'], meta: { name: 'ContainerPlant' } }
    /**
     * Find zero or one ContainerPlant that matches the filter.
     * @param {ContainerPlantFindUniqueArgs} args - Arguments to find a ContainerPlant
     * @example
     * // Get one ContainerPlant
     * const containerPlant = await prisma.containerPlant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerPlantFindUniqueArgs>(args: SelectSubset<T, ContainerPlantFindUniqueArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContainerPlant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContainerPlantFindUniqueOrThrowArgs} args - Arguments to find a ContainerPlant
     * @example
     * // Get one ContainerPlant
     * const containerPlant = await prisma.containerPlant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerPlantFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerPlantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerPlant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantFindFirstArgs} args - Arguments to find a ContainerPlant
     * @example
     * // Get one ContainerPlant
     * const containerPlant = await prisma.containerPlant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerPlantFindFirstArgs>(args?: SelectSubset<T, ContainerPlantFindFirstArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerPlant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantFindFirstOrThrowArgs} args - Arguments to find a ContainerPlant
     * @example
     * // Get one ContainerPlant
     * const containerPlant = await prisma.containerPlant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerPlantFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerPlantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContainerPlants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContainerPlants
     * const containerPlants = await prisma.containerPlant.findMany()
     * 
     * // Get first 10 ContainerPlants
     * const containerPlants = await prisma.containerPlant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerPlantWithIdOnly = await prisma.containerPlant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerPlantFindManyArgs>(args?: SelectSubset<T, ContainerPlantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContainerPlant.
     * @param {ContainerPlantCreateArgs} args - Arguments to create a ContainerPlant.
     * @example
     * // Create one ContainerPlant
     * const ContainerPlant = await prisma.containerPlant.create({
     *   data: {
     *     // ... data to create a ContainerPlant
     *   }
     * })
     * 
     */
    create<T extends ContainerPlantCreateArgs>(args: SelectSubset<T, ContainerPlantCreateArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContainerPlants.
     * @param {ContainerPlantCreateManyArgs} args - Arguments to create many ContainerPlants.
     * @example
     * // Create many ContainerPlants
     * const containerPlant = await prisma.containerPlant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerPlantCreateManyArgs>(args?: SelectSubset<T, ContainerPlantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContainerPlants and returns the data saved in the database.
     * @param {ContainerPlantCreateManyAndReturnArgs} args - Arguments to create many ContainerPlants.
     * @example
     * // Create many ContainerPlants
     * const containerPlant = await prisma.containerPlant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContainerPlants and only return the `id`
     * const containerPlantWithIdOnly = await prisma.containerPlant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerPlantCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerPlantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContainerPlant.
     * @param {ContainerPlantDeleteArgs} args - Arguments to delete one ContainerPlant.
     * @example
     * // Delete one ContainerPlant
     * const ContainerPlant = await prisma.containerPlant.delete({
     *   where: {
     *     // ... filter to delete one ContainerPlant
     *   }
     * })
     * 
     */
    delete<T extends ContainerPlantDeleteArgs>(args: SelectSubset<T, ContainerPlantDeleteArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContainerPlant.
     * @param {ContainerPlantUpdateArgs} args - Arguments to update one ContainerPlant.
     * @example
     * // Update one ContainerPlant
     * const containerPlant = await prisma.containerPlant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerPlantUpdateArgs>(args: SelectSubset<T, ContainerPlantUpdateArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContainerPlants.
     * @param {ContainerPlantDeleteManyArgs} args - Arguments to filter ContainerPlants to delete.
     * @example
     * // Delete a few ContainerPlants
     * const { count } = await prisma.containerPlant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerPlantDeleteManyArgs>(args?: SelectSubset<T, ContainerPlantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerPlants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContainerPlants
     * const containerPlant = await prisma.containerPlant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerPlantUpdateManyArgs>(args: SelectSubset<T, ContainerPlantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerPlants and returns the data updated in the database.
     * @param {ContainerPlantUpdateManyAndReturnArgs} args - Arguments to update many ContainerPlants.
     * @example
     * // Update many ContainerPlants
     * const containerPlant = await prisma.containerPlant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContainerPlants and only return the `id`
     * const containerPlantWithIdOnly = await prisma.containerPlant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContainerPlantUpdateManyAndReturnArgs>(args: SelectSubset<T, ContainerPlantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContainerPlant.
     * @param {ContainerPlantUpsertArgs} args - Arguments to update or create a ContainerPlant.
     * @example
     * // Update or create a ContainerPlant
     * const containerPlant = await prisma.containerPlant.upsert({
     *   create: {
     *     // ... data to create a ContainerPlant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContainerPlant we want to update
     *   }
     * })
     */
    upsert<T extends ContainerPlantUpsertArgs>(args: SelectSubset<T, ContainerPlantUpsertArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContainerPlants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantCountArgs} args - Arguments to filter ContainerPlants to count.
     * @example
     * // Count the number of ContainerPlants
     * const count = await prisma.containerPlant.count({
     *   where: {
     *     // ... the filter for the ContainerPlants we want to count
     *   }
     * })
    **/
    count<T extends ContainerPlantCountArgs>(
      args?: Subset<T, ContainerPlantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerPlantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContainerPlant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerPlantAggregateArgs>(args: Subset<T, ContainerPlantAggregateArgs>): Prisma.PrismaPromise<GetContainerPlantAggregateType<T>>

    /**
     * Group by ContainerPlant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerPlantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerPlantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerPlantGroupByArgs['orderBy'] }
        : { orderBy?: ContainerPlantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerPlantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerPlantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContainerPlant model
   */
  readonly fields: ContainerPlantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContainerPlant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerPlantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variety<T extends ContainerPlant$varietyArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$varietyArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    growthStages<T extends ContainerPlant$growthStagesArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$growthStagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gardenActions<T extends ContainerPlant$gardenActionsArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$gardenActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    harvests<T extends ContainerPlant$harvestsArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$harvestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movementHistory<T extends ContainerPlant$movementHistoryArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$movementHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends ContainerPlant$tasksArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlant$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContainerPlant model
   */
  interface ContainerPlantFieldRefs {
    readonly id: FieldRef<"ContainerPlant", 'Int'>
    readonly containerId: FieldRef<"ContainerPlant", 'Int'>
    readonly plantId: FieldRef<"ContainerPlant", 'Int'>
    readonly varietyId: FieldRef<"ContainerPlant", 'Int'>
    readonly quantity: FieldRef<"ContainerPlant", 'Decimal'>
    readonly plantDate: FieldRef<"ContainerPlant", 'DateTime'>
    readonly initialStage: FieldRef<"ContainerPlant", 'String'>
    readonly currentStage: FieldRef<"ContainerPlant", 'String'>
    readonly status: FieldRef<"ContainerPlant", 'String'>
    readonly positionX: FieldRef<"ContainerPlant", 'Decimal'>
    readonly positionY: FieldRef<"ContainerPlant", 'Decimal'>
    readonly expectedHarvestDate: FieldRef<"ContainerPlant", 'DateTime'>
    readonly notes: FieldRef<"ContainerPlant", 'String'>
    readonly createdAt: FieldRef<"ContainerPlant", 'DateTime'>
    readonly updatedAt: FieldRef<"ContainerPlant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContainerPlant findUnique
   */
  export type ContainerPlantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter, which ContainerPlant to fetch.
     */
    where: ContainerPlantWhereUniqueInput
  }

  /**
   * ContainerPlant findUniqueOrThrow
   */
  export type ContainerPlantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter, which ContainerPlant to fetch.
     */
    where: ContainerPlantWhereUniqueInput
  }

  /**
   * ContainerPlant findFirst
   */
  export type ContainerPlantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter, which ContainerPlant to fetch.
     */
    where?: ContainerPlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerPlants to fetch.
     */
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerPlants.
     */
    cursor?: ContainerPlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerPlants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerPlants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerPlants.
     */
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * ContainerPlant findFirstOrThrow
   */
  export type ContainerPlantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter, which ContainerPlant to fetch.
     */
    where?: ContainerPlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerPlants to fetch.
     */
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerPlants.
     */
    cursor?: ContainerPlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerPlants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerPlants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerPlants.
     */
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * ContainerPlant findMany
   */
  export type ContainerPlantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter, which ContainerPlants to fetch.
     */
    where?: ContainerPlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerPlants to fetch.
     */
    orderBy?: ContainerPlantOrderByWithRelationInput | ContainerPlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContainerPlants.
     */
    cursor?: ContainerPlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerPlants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerPlants.
     */
    skip?: number
    distinct?: ContainerPlantScalarFieldEnum | ContainerPlantScalarFieldEnum[]
  }

  /**
   * ContainerPlant create
   */
  export type ContainerPlantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * The data needed to create a ContainerPlant.
     */
    data: XOR<ContainerPlantCreateInput, ContainerPlantUncheckedCreateInput>
  }

  /**
   * ContainerPlant createMany
   */
  export type ContainerPlantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContainerPlants.
     */
    data: ContainerPlantCreateManyInput | ContainerPlantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerPlant createManyAndReturn
   */
  export type ContainerPlantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * The data used to create many ContainerPlants.
     */
    data: ContainerPlantCreateManyInput | ContainerPlantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContainerPlant update
   */
  export type ContainerPlantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * The data needed to update a ContainerPlant.
     */
    data: XOR<ContainerPlantUpdateInput, ContainerPlantUncheckedUpdateInput>
    /**
     * Choose, which ContainerPlant to update.
     */
    where: ContainerPlantWhereUniqueInput
  }

  /**
   * ContainerPlant updateMany
   */
  export type ContainerPlantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContainerPlants.
     */
    data: XOR<ContainerPlantUpdateManyMutationInput, ContainerPlantUncheckedUpdateManyInput>
    /**
     * Filter which ContainerPlants to update
     */
    where?: ContainerPlantWhereInput
    /**
     * Limit how many ContainerPlants to update.
     */
    limit?: number
  }

  /**
   * ContainerPlant updateManyAndReturn
   */
  export type ContainerPlantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * The data used to update ContainerPlants.
     */
    data: XOR<ContainerPlantUpdateManyMutationInput, ContainerPlantUncheckedUpdateManyInput>
    /**
     * Filter which ContainerPlants to update
     */
    where?: ContainerPlantWhereInput
    /**
     * Limit how many ContainerPlants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContainerPlant upsert
   */
  export type ContainerPlantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * The filter to search for the ContainerPlant to update in case it exists.
     */
    where: ContainerPlantWhereUniqueInput
    /**
     * In case the ContainerPlant found by the `where` argument doesn't exist, create a new ContainerPlant with this data.
     */
    create: XOR<ContainerPlantCreateInput, ContainerPlantUncheckedCreateInput>
    /**
     * In case the ContainerPlant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerPlantUpdateInput, ContainerPlantUncheckedUpdateInput>
  }

  /**
   * ContainerPlant delete
   */
  export type ContainerPlantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    /**
     * Filter which ContainerPlant to delete.
     */
    where: ContainerPlantWhereUniqueInput
  }

  /**
   * ContainerPlant deleteMany
   */
  export type ContainerPlantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerPlants to delete
     */
    where?: ContainerPlantWhereInput
    /**
     * Limit how many ContainerPlants to delete.
     */
    limit?: number
  }

  /**
   * ContainerPlant.variety
   */
  export type ContainerPlant$varietyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    where?: PlantVarietyWhereInput
  }

  /**
   * ContainerPlant.growthStages
   */
  export type ContainerPlant$growthStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    where?: PlantGrowthStageWhereInput
    orderBy?: PlantGrowthStageOrderByWithRelationInput | PlantGrowthStageOrderByWithRelationInput[]
    cursor?: PlantGrowthStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantGrowthStageScalarFieldEnum | PlantGrowthStageScalarFieldEnum[]
  }

  /**
   * ContainerPlant.gardenActions
   */
  export type ContainerPlant$gardenActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    cursor?: GardenActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * ContainerPlant.harvests
   */
  export type ContainerPlant$harvestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    where?: HarvestWhereInput
    orderBy?: HarvestOrderByWithRelationInput | HarvestOrderByWithRelationInput[]
    cursor?: HarvestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HarvestScalarFieldEnum | HarvestScalarFieldEnum[]
  }

  /**
   * ContainerPlant.movementHistory
   */
  export type ContainerPlant$movementHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    where?: PlantMovementHistoryWhereInput
    orderBy?: PlantMovementHistoryOrderByWithRelationInput | PlantMovementHistoryOrderByWithRelationInput[]
    cursor?: PlantMovementHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantMovementHistoryScalarFieldEnum | PlantMovementHistoryScalarFieldEnum[]
  }

  /**
   * ContainerPlant.tasks
   */
  export type ContainerPlant$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * ContainerPlant without action
   */
  export type ContainerPlantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
  }


  /**
   * Model PlantGrowthStage
   */

  export type AggregatePlantGrowthStage = {
    _count: PlantGrowthStageCountAggregateOutputType | null
    _avg: PlantGrowthStageAvgAggregateOutputType | null
    _sum: PlantGrowthStageSumAggregateOutputType | null
    _min: PlantGrowthStageMinAggregateOutputType | null
    _max: PlantGrowthStageMaxAggregateOutputType | null
  }

  export type PlantGrowthStageAvgAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
  }

  export type PlantGrowthStageSumAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
  }

  export type PlantGrowthStageMinAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    stageName: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    imageUrl: string | null
  }

  export type PlantGrowthStageMaxAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    stageName: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    imageUrl: string | null
  }

  export type PlantGrowthStageCountAggregateOutputType = {
    id: number
    containerPlantId: number
    stageName: number
    startDate: number
    endDate: number
    notes: number
    imageUrl: number
    _all: number
  }


  export type PlantGrowthStageAvgAggregateInputType = {
    id?: true
    containerPlantId?: true
  }

  export type PlantGrowthStageSumAggregateInputType = {
    id?: true
    containerPlantId?: true
  }

  export type PlantGrowthStageMinAggregateInputType = {
    id?: true
    containerPlantId?: true
    stageName?: true
    startDate?: true
    endDate?: true
    notes?: true
    imageUrl?: true
  }

  export type PlantGrowthStageMaxAggregateInputType = {
    id?: true
    containerPlantId?: true
    stageName?: true
    startDate?: true
    endDate?: true
    notes?: true
    imageUrl?: true
  }

  export type PlantGrowthStageCountAggregateInputType = {
    id?: true
    containerPlantId?: true
    stageName?: true
    startDate?: true
    endDate?: true
    notes?: true
    imageUrl?: true
    _all?: true
  }

  export type PlantGrowthStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantGrowthStage to aggregate.
     */
    where?: PlantGrowthStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowthStages to fetch.
     */
    orderBy?: PlantGrowthStageOrderByWithRelationInput | PlantGrowthStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantGrowthStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowthStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowthStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantGrowthStages
    **/
    _count?: true | PlantGrowthStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantGrowthStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantGrowthStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantGrowthStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantGrowthStageMaxAggregateInputType
  }

  export type GetPlantGrowthStageAggregateType<T extends PlantGrowthStageAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantGrowthStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantGrowthStage[P]>
      : GetScalarType<T[P], AggregatePlantGrowthStage[P]>
  }




  export type PlantGrowthStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantGrowthStageWhereInput
    orderBy?: PlantGrowthStageOrderByWithAggregationInput | PlantGrowthStageOrderByWithAggregationInput[]
    by: PlantGrowthStageScalarFieldEnum[] | PlantGrowthStageScalarFieldEnum
    having?: PlantGrowthStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantGrowthStageCountAggregateInputType | true
    _avg?: PlantGrowthStageAvgAggregateInputType
    _sum?: PlantGrowthStageSumAggregateInputType
    _min?: PlantGrowthStageMinAggregateInputType
    _max?: PlantGrowthStageMaxAggregateInputType
  }

  export type PlantGrowthStageGroupByOutputType = {
    id: number
    containerPlantId: number
    stageName: string
    startDate: Date
    endDate: Date | null
    notes: string | null
    imageUrl: string | null
    _count: PlantGrowthStageCountAggregateOutputType | null
    _avg: PlantGrowthStageAvgAggregateOutputType | null
    _sum: PlantGrowthStageSumAggregateOutputType | null
    _min: PlantGrowthStageMinAggregateOutputType | null
    _max: PlantGrowthStageMaxAggregateOutputType | null
  }

  type GetPlantGrowthStageGroupByPayload<T extends PlantGrowthStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantGrowthStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantGrowthStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantGrowthStageGroupByOutputType[P]>
            : GetScalarType<T[P], PlantGrowthStageGroupByOutputType[P]>
        }
      >
    >


  export type PlantGrowthStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    stageName?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowthStage"]>

  export type PlantGrowthStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    stageName?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowthStage"]>

  export type PlantGrowthStageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    stageName?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantGrowthStage"]>

  export type PlantGrowthStageSelectScalar = {
    id?: boolean
    containerPlantId?: boolean
    stageName?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    imageUrl?: boolean
  }

  export type PlantGrowthStageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerPlantId" | "stageName" | "startDate" | "endDate" | "notes" | "imageUrl", ExtArgs["result"]["plantGrowthStage"]>
  export type PlantGrowthStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type PlantGrowthStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type PlantGrowthStageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }

  export type $PlantGrowthStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantGrowthStage"
    objects: {
      containerPlant: Prisma.$ContainerPlantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      containerPlantId: number
      stageName: string
      startDate: Date
      endDate: Date | null
      notes: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["plantGrowthStage"]>
    composites: {}
  }

  type PlantGrowthStageGetPayload<S extends boolean | null | undefined | PlantGrowthStageDefaultArgs> = $Result.GetResult<Prisma.$PlantGrowthStagePayload, S>

  type PlantGrowthStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantGrowthStageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantGrowthStageCountAggregateInputType | true
    }

  export interface PlantGrowthStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantGrowthStage'], meta: { name: 'PlantGrowthStage' } }
    /**
     * Find zero or one PlantGrowthStage that matches the filter.
     * @param {PlantGrowthStageFindUniqueArgs} args - Arguments to find a PlantGrowthStage
     * @example
     * // Get one PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantGrowthStageFindUniqueArgs>(args: SelectSubset<T, PlantGrowthStageFindUniqueArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantGrowthStage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantGrowthStageFindUniqueOrThrowArgs} args - Arguments to find a PlantGrowthStage
     * @example
     * // Get one PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantGrowthStageFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantGrowthStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantGrowthStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageFindFirstArgs} args - Arguments to find a PlantGrowthStage
     * @example
     * // Get one PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantGrowthStageFindFirstArgs>(args?: SelectSubset<T, PlantGrowthStageFindFirstArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantGrowthStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageFindFirstOrThrowArgs} args - Arguments to find a PlantGrowthStage
     * @example
     * // Get one PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantGrowthStageFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantGrowthStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantGrowthStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantGrowthStages
     * const plantGrowthStages = await prisma.plantGrowthStage.findMany()
     * 
     * // Get first 10 PlantGrowthStages
     * const plantGrowthStages = await prisma.plantGrowthStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantGrowthStageWithIdOnly = await prisma.plantGrowthStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantGrowthStageFindManyArgs>(args?: SelectSubset<T, PlantGrowthStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantGrowthStage.
     * @param {PlantGrowthStageCreateArgs} args - Arguments to create a PlantGrowthStage.
     * @example
     * // Create one PlantGrowthStage
     * const PlantGrowthStage = await prisma.plantGrowthStage.create({
     *   data: {
     *     // ... data to create a PlantGrowthStage
     *   }
     * })
     * 
     */
    create<T extends PlantGrowthStageCreateArgs>(args: SelectSubset<T, PlantGrowthStageCreateArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantGrowthStages.
     * @param {PlantGrowthStageCreateManyArgs} args - Arguments to create many PlantGrowthStages.
     * @example
     * // Create many PlantGrowthStages
     * const plantGrowthStage = await prisma.plantGrowthStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantGrowthStageCreateManyArgs>(args?: SelectSubset<T, PlantGrowthStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantGrowthStages and returns the data saved in the database.
     * @param {PlantGrowthStageCreateManyAndReturnArgs} args - Arguments to create many PlantGrowthStages.
     * @example
     * // Create many PlantGrowthStages
     * const plantGrowthStage = await prisma.plantGrowthStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantGrowthStages and only return the `id`
     * const plantGrowthStageWithIdOnly = await prisma.plantGrowthStage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantGrowthStageCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantGrowthStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantGrowthStage.
     * @param {PlantGrowthStageDeleteArgs} args - Arguments to delete one PlantGrowthStage.
     * @example
     * // Delete one PlantGrowthStage
     * const PlantGrowthStage = await prisma.plantGrowthStage.delete({
     *   where: {
     *     // ... filter to delete one PlantGrowthStage
     *   }
     * })
     * 
     */
    delete<T extends PlantGrowthStageDeleteArgs>(args: SelectSubset<T, PlantGrowthStageDeleteArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantGrowthStage.
     * @param {PlantGrowthStageUpdateArgs} args - Arguments to update one PlantGrowthStage.
     * @example
     * // Update one PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantGrowthStageUpdateArgs>(args: SelectSubset<T, PlantGrowthStageUpdateArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantGrowthStages.
     * @param {PlantGrowthStageDeleteManyArgs} args - Arguments to filter PlantGrowthStages to delete.
     * @example
     * // Delete a few PlantGrowthStages
     * const { count } = await prisma.plantGrowthStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantGrowthStageDeleteManyArgs>(args?: SelectSubset<T, PlantGrowthStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantGrowthStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantGrowthStages
     * const plantGrowthStage = await prisma.plantGrowthStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantGrowthStageUpdateManyArgs>(args: SelectSubset<T, PlantGrowthStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantGrowthStages and returns the data updated in the database.
     * @param {PlantGrowthStageUpdateManyAndReturnArgs} args - Arguments to update many PlantGrowthStages.
     * @example
     * // Update many PlantGrowthStages
     * const plantGrowthStage = await prisma.plantGrowthStage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantGrowthStages and only return the `id`
     * const plantGrowthStageWithIdOnly = await prisma.plantGrowthStage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantGrowthStageUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantGrowthStageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantGrowthStage.
     * @param {PlantGrowthStageUpsertArgs} args - Arguments to update or create a PlantGrowthStage.
     * @example
     * // Update or create a PlantGrowthStage
     * const plantGrowthStage = await prisma.plantGrowthStage.upsert({
     *   create: {
     *     // ... data to create a PlantGrowthStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantGrowthStage we want to update
     *   }
     * })
     */
    upsert<T extends PlantGrowthStageUpsertArgs>(args: SelectSubset<T, PlantGrowthStageUpsertArgs<ExtArgs>>): Prisma__PlantGrowthStageClient<$Result.GetResult<Prisma.$PlantGrowthStagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantGrowthStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageCountArgs} args - Arguments to filter PlantGrowthStages to count.
     * @example
     * // Count the number of PlantGrowthStages
     * const count = await prisma.plantGrowthStage.count({
     *   where: {
     *     // ... the filter for the PlantGrowthStages we want to count
     *   }
     * })
    **/
    count<T extends PlantGrowthStageCountArgs>(
      args?: Subset<T, PlantGrowthStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantGrowthStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantGrowthStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantGrowthStageAggregateArgs>(args: Subset<T, PlantGrowthStageAggregateArgs>): Prisma.PrismaPromise<GetPlantGrowthStageAggregateType<T>>

    /**
     * Group by PlantGrowthStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGrowthStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantGrowthStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantGrowthStageGroupByArgs['orderBy'] }
        : { orderBy?: PlantGrowthStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantGrowthStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantGrowthStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantGrowthStage model
   */
  readonly fields: PlantGrowthStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantGrowthStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantGrowthStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containerPlant<T extends ContainerPlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlantDefaultArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantGrowthStage model
   */
  interface PlantGrowthStageFieldRefs {
    readonly id: FieldRef<"PlantGrowthStage", 'Int'>
    readonly containerPlantId: FieldRef<"PlantGrowthStage", 'Int'>
    readonly stageName: FieldRef<"PlantGrowthStage", 'String'>
    readonly startDate: FieldRef<"PlantGrowthStage", 'DateTime'>
    readonly endDate: FieldRef<"PlantGrowthStage", 'DateTime'>
    readonly notes: FieldRef<"PlantGrowthStage", 'String'>
    readonly imageUrl: FieldRef<"PlantGrowthStage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlantGrowthStage findUnique
   */
  export type PlantGrowthStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowthStage to fetch.
     */
    where: PlantGrowthStageWhereUniqueInput
  }

  /**
   * PlantGrowthStage findUniqueOrThrow
   */
  export type PlantGrowthStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowthStage to fetch.
     */
    where: PlantGrowthStageWhereUniqueInput
  }

  /**
   * PlantGrowthStage findFirst
   */
  export type PlantGrowthStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowthStage to fetch.
     */
    where?: PlantGrowthStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowthStages to fetch.
     */
    orderBy?: PlantGrowthStageOrderByWithRelationInput | PlantGrowthStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantGrowthStages.
     */
    cursor?: PlantGrowthStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowthStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowthStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantGrowthStages.
     */
    distinct?: PlantGrowthStageScalarFieldEnum | PlantGrowthStageScalarFieldEnum[]
  }

  /**
   * PlantGrowthStage findFirstOrThrow
   */
  export type PlantGrowthStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowthStage to fetch.
     */
    where?: PlantGrowthStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowthStages to fetch.
     */
    orderBy?: PlantGrowthStageOrderByWithRelationInput | PlantGrowthStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantGrowthStages.
     */
    cursor?: PlantGrowthStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowthStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowthStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantGrowthStages.
     */
    distinct?: PlantGrowthStageScalarFieldEnum | PlantGrowthStageScalarFieldEnum[]
  }

  /**
   * PlantGrowthStage findMany
   */
  export type PlantGrowthStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter, which PlantGrowthStages to fetch.
     */
    where?: PlantGrowthStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantGrowthStages to fetch.
     */
    orderBy?: PlantGrowthStageOrderByWithRelationInput | PlantGrowthStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantGrowthStages.
     */
    cursor?: PlantGrowthStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantGrowthStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantGrowthStages.
     */
    skip?: number
    distinct?: PlantGrowthStageScalarFieldEnum | PlantGrowthStageScalarFieldEnum[]
  }

  /**
   * PlantGrowthStage create
   */
  export type PlantGrowthStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantGrowthStage.
     */
    data: XOR<PlantGrowthStageCreateInput, PlantGrowthStageUncheckedCreateInput>
  }

  /**
   * PlantGrowthStage createMany
   */
  export type PlantGrowthStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantGrowthStages.
     */
    data: PlantGrowthStageCreateManyInput | PlantGrowthStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantGrowthStage createManyAndReturn
   */
  export type PlantGrowthStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * The data used to create many PlantGrowthStages.
     */
    data: PlantGrowthStageCreateManyInput | PlantGrowthStageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantGrowthStage update
   */
  export type PlantGrowthStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantGrowthStage.
     */
    data: XOR<PlantGrowthStageUpdateInput, PlantGrowthStageUncheckedUpdateInput>
    /**
     * Choose, which PlantGrowthStage to update.
     */
    where: PlantGrowthStageWhereUniqueInput
  }

  /**
   * PlantGrowthStage updateMany
   */
  export type PlantGrowthStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantGrowthStages.
     */
    data: XOR<PlantGrowthStageUpdateManyMutationInput, PlantGrowthStageUncheckedUpdateManyInput>
    /**
     * Filter which PlantGrowthStages to update
     */
    where?: PlantGrowthStageWhereInput
    /**
     * Limit how many PlantGrowthStages to update.
     */
    limit?: number
  }

  /**
   * PlantGrowthStage updateManyAndReturn
   */
  export type PlantGrowthStageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * The data used to update PlantGrowthStages.
     */
    data: XOR<PlantGrowthStageUpdateManyMutationInput, PlantGrowthStageUncheckedUpdateManyInput>
    /**
     * Filter which PlantGrowthStages to update
     */
    where?: PlantGrowthStageWhereInput
    /**
     * Limit how many PlantGrowthStages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantGrowthStage upsert
   */
  export type PlantGrowthStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantGrowthStage to update in case it exists.
     */
    where: PlantGrowthStageWhereUniqueInput
    /**
     * In case the PlantGrowthStage found by the `where` argument doesn't exist, create a new PlantGrowthStage with this data.
     */
    create: XOR<PlantGrowthStageCreateInput, PlantGrowthStageUncheckedCreateInput>
    /**
     * In case the PlantGrowthStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantGrowthStageUpdateInput, PlantGrowthStageUncheckedUpdateInput>
  }

  /**
   * PlantGrowthStage delete
   */
  export type PlantGrowthStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
    /**
     * Filter which PlantGrowthStage to delete.
     */
    where: PlantGrowthStageWhereUniqueInput
  }

  /**
   * PlantGrowthStage deleteMany
   */
  export type PlantGrowthStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantGrowthStages to delete
     */
    where?: PlantGrowthStageWhereInput
    /**
     * Limit how many PlantGrowthStages to delete.
     */
    limit?: number
  }

  /**
   * PlantGrowthStage without action
   */
  export type PlantGrowthStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantGrowthStage
     */
    select?: PlantGrowthStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantGrowthStage
     */
    omit?: PlantGrowthStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantGrowthStageInclude<ExtArgs> | null
  }


  /**
   * Model ActionType
   */

  export type AggregateActionType = {
    _count: ActionTypeCountAggregateOutputType | null
    _avg: ActionTypeAvgAggregateOutputType | null
    _sum: ActionTypeSumAggregateOutputType | null
    _min: ActionTypeMinAggregateOutputType | null
    _max: ActionTypeMaxAggregateOutputType | null
  }

  export type ActionTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ActionTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ActionTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
  }

  export type ActionTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
  }

  export type ActionTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type ActionTypeAvgAggregateInputType = {
    id?: true
  }

  export type ActionTypeSumAggregateInputType = {
    id?: true
  }

  export type ActionTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type ActionTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type ActionTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type ActionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionType to aggregate.
     */
    where?: ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionTypes to fetch.
     */
    orderBy?: ActionTypeOrderByWithRelationInput | ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionTypes
    **/
    _count?: true | ActionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionTypeMaxAggregateInputType
  }

  export type GetActionTypeAggregateType<T extends ActionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateActionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionType[P]>
      : GetScalarType<T[P], AggregateActionType[P]>
  }




  export type ActionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionTypeWhereInput
    orderBy?: ActionTypeOrderByWithAggregationInput | ActionTypeOrderByWithAggregationInput[]
    by: ActionTypeScalarFieldEnum[] | ActionTypeScalarFieldEnum
    having?: ActionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionTypeCountAggregateInputType | true
    _avg?: ActionTypeAvgAggregateInputType
    _sum?: ActionTypeSumAggregateInputType
    _min?: ActionTypeMinAggregateInputType
    _max?: ActionTypeMaxAggregateInputType
  }

  export type ActionTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string | null
    _count: ActionTypeCountAggregateOutputType | null
    _avg: ActionTypeAvgAggregateOutputType | null
    _sum: ActionTypeSumAggregateOutputType | null
    _min: ActionTypeMinAggregateOutputType | null
    _max: ActionTypeMaxAggregateOutputType | null
  }

  type GetActionTypeGroupByPayload<T extends ActionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ActionTypeGroupByOutputType[P]>
        }
      >
    >


  export type ActionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    actions?: boolean | ActionType$actionsArgs<ExtArgs>
    _count?: boolean | ActionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionType"]>

  export type ActionTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["actionType"]>

  export type ActionTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["actionType"]>

  export type ActionTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type ActionTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["actionType"]>
  export type ActionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | ActionType$actionsArgs<ExtArgs>
    _count?: boolean | ActionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActionTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionType"
    objects: {
      actions: Prisma.$GardenActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string | null
    }, ExtArgs["result"]["actionType"]>
    composites: {}
  }

  type ActionTypeGetPayload<S extends boolean | null | undefined | ActionTypeDefaultArgs> = $Result.GetResult<Prisma.$ActionTypePayload, S>

  type ActionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionTypeCountAggregateInputType | true
    }

  export interface ActionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionType'], meta: { name: 'ActionType' } }
    /**
     * Find zero or one ActionType that matches the filter.
     * @param {ActionTypeFindUniqueArgs} args - Arguments to find a ActionType
     * @example
     * // Get one ActionType
     * const actionType = await prisma.actionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionTypeFindUniqueArgs>(args: SelectSubset<T, ActionTypeFindUniqueArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionTypeFindUniqueOrThrowArgs} args - Arguments to find a ActionType
     * @example
     * // Get one ActionType
     * const actionType = await prisma.actionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeFindFirstArgs} args - Arguments to find a ActionType
     * @example
     * // Get one ActionType
     * const actionType = await prisma.actionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionTypeFindFirstArgs>(args?: SelectSubset<T, ActionTypeFindFirstArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeFindFirstOrThrowArgs} args - Arguments to find a ActionType
     * @example
     * // Get one ActionType
     * const actionType = await prisma.actionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionTypes
     * const actionTypes = await prisma.actionType.findMany()
     * 
     * // Get first 10 ActionTypes
     * const actionTypes = await prisma.actionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionTypeWithIdOnly = await prisma.actionType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionTypeFindManyArgs>(args?: SelectSubset<T, ActionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionType.
     * @param {ActionTypeCreateArgs} args - Arguments to create a ActionType.
     * @example
     * // Create one ActionType
     * const ActionType = await prisma.actionType.create({
     *   data: {
     *     // ... data to create a ActionType
     *   }
     * })
     * 
     */
    create<T extends ActionTypeCreateArgs>(args: SelectSubset<T, ActionTypeCreateArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionTypes.
     * @param {ActionTypeCreateManyArgs} args - Arguments to create many ActionTypes.
     * @example
     * // Create many ActionTypes
     * const actionType = await prisma.actionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionTypeCreateManyArgs>(args?: SelectSubset<T, ActionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionTypes and returns the data saved in the database.
     * @param {ActionTypeCreateManyAndReturnArgs} args - Arguments to create many ActionTypes.
     * @example
     * // Create many ActionTypes
     * const actionType = await prisma.actionType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionTypes and only return the `id`
     * const actionTypeWithIdOnly = await prisma.actionType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionType.
     * @param {ActionTypeDeleteArgs} args - Arguments to delete one ActionType.
     * @example
     * // Delete one ActionType
     * const ActionType = await prisma.actionType.delete({
     *   where: {
     *     // ... filter to delete one ActionType
     *   }
     * })
     * 
     */
    delete<T extends ActionTypeDeleteArgs>(args: SelectSubset<T, ActionTypeDeleteArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionType.
     * @param {ActionTypeUpdateArgs} args - Arguments to update one ActionType.
     * @example
     * // Update one ActionType
     * const actionType = await prisma.actionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionTypeUpdateArgs>(args: SelectSubset<T, ActionTypeUpdateArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionTypes.
     * @param {ActionTypeDeleteManyArgs} args - Arguments to filter ActionTypes to delete.
     * @example
     * // Delete a few ActionTypes
     * const { count } = await prisma.actionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionTypeDeleteManyArgs>(args?: SelectSubset<T, ActionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionTypes
     * const actionType = await prisma.actionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionTypeUpdateManyArgs>(args: SelectSubset<T, ActionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionTypes and returns the data updated in the database.
     * @param {ActionTypeUpdateManyAndReturnArgs} args - Arguments to update many ActionTypes.
     * @example
     * // Update many ActionTypes
     * const actionType = await prisma.actionType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionTypes and only return the `id`
     * const actionTypeWithIdOnly = await prisma.actionType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionType.
     * @param {ActionTypeUpsertArgs} args - Arguments to update or create a ActionType.
     * @example
     * // Update or create a ActionType
     * const actionType = await prisma.actionType.upsert({
     *   create: {
     *     // ... data to create a ActionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionType we want to update
     *   }
     * })
     */
    upsert<T extends ActionTypeUpsertArgs>(args: SelectSubset<T, ActionTypeUpsertArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeCountArgs} args - Arguments to filter ActionTypes to count.
     * @example
     * // Count the number of ActionTypes
     * const count = await prisma.actionType.count({
     *   where: {
     *     // ... the filter for the ActionTypes we want to count
     *   }
     * })
    **/
    count<T extends ActionTypeCountArgs>(
      args?: Subset<T, ActionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionTypeAggregateArgs>(args: Subset<T, ActionTypeAggregateArgs>): Prisma.PrismaPromise<GetActionTypeAggregateType<T>>

    /**
     * Group by ActionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionTypeGroupByArgs['orderBy'] }
        : { orderBy?: ActionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionType model
   */
  readonly fields: ActionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actions<T extends ActionType$actionsArgs<ExtArgs> = {}>(args?: Subset<T, ActionType$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionType model
   */
  interface ActionTypeFieldRefs {
    readonly id: FieldRef<"ActionType", 'Int'>
    readonly name: FieldRef<"ActionType", 'String'>
    readonly description: FieldRef<"ActionType", 'String'>
    readonly category: FieldRef<"ActionType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActionType findUnique
   */
  export type ActionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ActionType to fetch.
     */
    where: ActionTypeWhereUniqueInput
  }

  /**
   * ActionType findUniqueOrThrow
   */
  export type ActionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ActionType to fetch.
     */
    where: ActionTypeWhereUniqueInput
  }

  /**
   * ActionType findFirst
   */
  export type ActionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ActionType to fetch.
     */
    where?: ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionTypes to fetch.
     */
    orderBy?: ActionTypeOrderByWithRelationInput | ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionTypes.
     */
    cursor?: ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionTypes.
     */
    distinct?: ActionTypeScalarFieldEnum | ActionTypeScalarFieldEnum[]
  }

  /**
   * ActionType findFirstOrThrow
   */
  export type ActionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ActionType to fetch.
     */
    where?: ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionTypes to fetch.
     */
    orderBy?: ActionTypeOrderByWithRelationInput | ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionTypes.
     */
    cursor?: ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionTypes.
     */
    distinct?: ActionTypeScalarFieldEnum | ActionTypeScalarFieldEnum[]
  }

  /**
   * ActionType findMany
   */
  export type ActionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter, which ActionTypes to fetch.
     */
    where?: ActionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionTypes to fetch.
     */
    orderBy?: ActionTypeOrderByWithRelationInput | ActionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionTypes.
     */
    cursor?: ActionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionTypes.
     */
    skip?: number
    distinct?: ActionTypeScalarFieldEnum | ActionTypeScalarFieldEnum[]
  }

  /**
   * ActionType create
   */
  export type ActionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionType.
     */
    data: XOR<ActionTypeCreateInput, ActionTypeUncheckedCreateInput>
  }

  /**
   * ActionType createMany
   */
  export type ActionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionTypes.
     */
    data: ActionTypeCreateManyInput | ActionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionType createManyAndReturn
   */
  export type ActionTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ActionTypes.
     */
    data: ActionTypeCreateManyInput | ActionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionType update
   */
  export type ActionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionType.
     */
    data: XOR<ActionTypeUpdateInput, ActionTypeUncheckedUpdateInput>
    /**
     * Choose, which ActionType to update.
     */
    where: ActionTypeWhereUniqueInput
  }

  /**
   * ActionType updateMany
   */
  export type ActionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionTypes.
     */
    data: XOR<ActionTypeUpdateManyMutationInput, ActionTypeUncheckedUpdateManyInput>
    /**
     * Filter which ActionTypes to update
     */
    where?: ActionTypeWhereInput
    /**
     * Limit how many ActionTypes to update.
     */
    limit?: number
  }

  /**
   * ActionType updateManyAndReturn
   */
  export type ActionTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * The data used to update ActionTypes.
     */
    data: XOR<ActionTypeUpdateManyMutationInput, ActionTypeUncheckedUpdateManyInput>
    /**
     * Filter which ActionTypes to update
     */
    where?: ActionTypeWhereInput
    /**
     * Limit how many ActionTypes to update.
     */
    limit?: number
  }

  /**
   * ActionType upsert
   */
  export type ActionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionType to update in case it exists.
     */
    where: ActionTypeWhereUniqueInput
    /**
     * In case the ActionType found by the `where` argument doesn't exist, create a new ActionType with this data.
     */
    create: XOR<ActionTypeCreateInput, ActionTypeUncheckedCreateInput>
    /**
     * In case the ActionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionTypeUpdateInput, ActionTypeUncheckedUpdateInput>
  }

  /**
   * ActionType delete
   */
  export type ActionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
    /**
     * Filter which ActionType to delete.
     */
    where: ActionTypeWhereUniqueInput
  }

  /**
   * ActionType deleteMany
   */
  export type ActionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionTypes to delete
     */
    where?: ActionTypeWhereInput
    /**
     * Limit how many ActionTypes to delete.
     */
    limit?: number
  }

  /**
   * ActionType.actions
   */
  export type ActionType$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    cursor?: GardenActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * ActionType without action
   */
  export type ActionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionType
     */
    select?: ActionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionType
     */
    omit?: ActionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionTypeInclude<ExtArgs> | null
  }


  /**
   * Model GardenAction
   */

  export type AggregateGardenAction = {
    _count: GardenActionCountAggregateOutputType | null
    _avg: GardenActionAvgAggregateOutputType | null
    _sum: GardenActionSumAggregateOutputType | null
    _min: GardenActionMinAggregateOutputType | null
    _max: GardenActionMaxAggregateOutputType | null
  }

  export type GardenActionAvgAggregateOutputType = {
    id: number | null
    actionTypeId: number | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    quantity: Decimal | null
    successRating: number | null
  }

  export type GardenActionSumAggregateOutputType = {
    id: number | null
    actionTypeId: number | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    quantity: Decimal | null
    successRating: number | null
  }

  export type GardenActionMinAggregateOutputType = {
    id: number | null
    actionTypeId: number | null
    userId: string | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    actionDate: Date | null
    quantity: Decimal | null
    unit: string | null
    notes: string | null
    successRating: number | null
    createdAt: Date | null
  }

  export type GardenActionMaxAggregateOutputType = {
    id: number | null
    actionTypeId: number | null
    userId: string | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    actionDate: Date | null
    quantity: Decimal | null
    unit: string | null
    notes: string | null
    successRating: number | null
    createdAt: Date | null
  }

  export type GardenActionCountAggregateOutputType = {
    id: number
    actionTypeId: number
    userId: number
    gardenId: number
    containerId: number
    containerPlantId: number
    actionDate: number
    quantity: number
    unit: number
    notes: number
    successRating: number
    createdAt: number
    _all: number
  }


  export type GardenActionAvgAggregateInputType = {
    id?: true
    actionTypeId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    quantity?: true
    successRating?: true
  }

  export type GardenActionSumAggregateInputType = {
    id?: true
    actionTypeId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    quantity?: true
    successRating?: true
  }

  export type GardenActionMinAggregateInputType = {
    id?: true
    actionTypeId?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    actionDate?: true
    quantity?: true
    unit?: true
    notes?: true
    successRating?: true
    createdAt?: true
  }

  export type GardenActionMaxAggregateInputType = {
    id?: true
    actionTypeId?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    actionDate?: true
    quantity?: true
    unit?: true
    notes?: true
    successRating?: true
    createdAt?: true
  }

  export type GardenActionCountAggregateInputType = {
    id?: true
    actionTypeId?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    actionDate?: true
    quantity?: true
    unit?: true
    notes?: true
    successRating?: true
    createdAt?: true
    _all?: true
  }

  export type GardenActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GardenAction to aggregate.
     */
    where?: GardenActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenActions to fetch.
     */
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GardenActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GardenActions
    **/
    _count?: true | GardenActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GardenActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GardenActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GardenActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GardenActionMaxAggregateInputType
  }

  export type GetGardenActionAggregateType<T extends GardenActionAggregateArgs> = {
        [P in keyof T & keyof AggregateGardenAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGardenAction[P]>
      : GetScalarType<T[P], AggregateGardenAction[P]>
  }




  export type GardenActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GardenActionWhereInput
    orderBy?: GardenActionOrderByWithAggregationInput | GardenActionOrderByWithAggregationInput[]
    by: GardenActionScalarFieldEnum[] | GardenActionScalarFieldEnum
    having?: GardenActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GardenActionCountAggregateInputType | true
    _avg?: GardenActionAvgAggregateInputType
    _sum?: GardenActionSumAggregateInputType
    _min?: GardenActionMinAggregateInputType
    _max?: GardenActionMaxAggregateInputType
  }

  export type GardenActionGroupByOutputType = {
    id: number
    actionTypeId: number
    userId: string
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    actionDate: Date
    quantity: Decimal | null
    unit: string | null
    notes: string | null
    successRating: number | null
    createdAt: Date
    _count: GardenActionCountAggregateOutputType | null
    _avg: GardenActionAvgAggregateOutputType | null
    _sum: GardenActionSumAggregateOutputType | null
    _min: GardenActionMinAggregateOutputType | null
    _max: GardenActionMaxAggregateOutputType | null
  }

  type GetGardenActionGroupByPayload<T extends GardenActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GardenActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GardenActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GardenActionGroupByOutputType[P]>
            : GetScalarType<T[P], GardenActionGroupByOutputType[P]>
        }
      >
    >


  export type GardenActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionTypeId?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    actionDate?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    successRating?: boolean
    createdAt?: boolean
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }, ExtArgs["result"]["gardenAction"]>

  export type GardenActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionTypeId?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    actionDate?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    successRating?: boolean
    createdAt?: boolean
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }, ExtArgs["result"]["gardenAction"]>

  export type GardenActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionTypeId?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    actionDate?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    successRating?: boolean
    createdAt?: boolean
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }, ExtArgs["result"]["gardenAction"]>

  export type GardenActionSelectScalar = {
    id?: boolean
    actionTypeId?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    actionDate?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    successRating?: boolean
    createdAt?: boolean
  }

  export type GardenActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actionTypeId" | "userId" | "gardenId" | "containerId" | "containerPlantId" | "actionDate" | "quantity" | "unit" | "notes" | "successRating" | "createdAt", ExtArgs["result"]["gardenAction"]>
  export type GardenActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }
  export type GardenActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }
  export type GardenActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionType?: boolean | ActionTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | GardenAction$gardenArgs<ExtArgs>
    container?: boolean | GardenAction$containerArgs<ExtArgs>
    containerPlant?: boolean | GardenAction$containerPlantArgs<ExtArgs>
  }

  export type $GardenActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GardenAction"
    objects: {
      actionType: Prisma.$ActionTypePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      garden: Prisma.$GardenPayload<ExtArgs> | null
      container: Prisma.$ContainerPayload<ExtArgs> | null
      containerPlant: Prisma.$ContainerPlantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actionTypeId: number
      userId: string
      gardenId: number | null
      containerId: number | null
      containerPlantId: number | null
      actionDate: Date
      quantity: Prisma.Decimal | null
      unit: string | null
      notes: string | null
      successRating: number | null
      createdAt: Date
    }, ExtArgs["result"]["gardenAction"]>
    composites: {}
  }

  type GardenActionGetPayload<S extends boolean | null | undefined | GardenActionDefaultArgs> = $Result.GetResult<Prisma.$GardenActionPayload, S>

  type GardenActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GardenActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GardenActionCountAggregateInputType | true
    }

  export interface GardenActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GardenAction'], meta: { name: 'GardenAction' } }
    /**
     * Find zero or one GardenAction that matches the filter.
     * @param {GardenActionFindUniqueArgs} args - Arguments to find a GardenAction
     * @example
     * // Get one GardenAction
     * const gardenAction = await prisma.gardenAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GardenActionFindUniqueArgs>(args: SelectSubset<T, GardenActionFindUniqueArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GardenAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GardenActionFindUniqueOrThrowArgs} args - Arguments to find a GardenAction
     * @example
     * // Get one GardenAction
     * const gardenAction = await prisma.gardenAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GardenActionFindUniqueOrThrowArgs>(args: SelectSubset<T, GardenActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GardenAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionFindFirstArgs} args - Arguments to find a GardenAction
     * @example
     * // Get one GardenAction
     * const gardenAction = await prisma.gardenAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GardenActionFindFirstArgs>(args?: SelectSubset<T, GardenActionFindFirstArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GardenAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionFindFirstOrThrowArgs} args - Arguments to find a GardenAction
     * @example
     * // Get one GardenAction
     * const gardenAction = await prisma.gardenAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GardenActionFindFirstOrThrowArgs>(args?: SelectSubset<T, GardenActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GardenActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GardenActions
     * const gardenActions = await prisma.gardenAction.findMany()
     * 
     * // Get first 10 GardenActions
     * const gardenActions = await prisma.gardenAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gardenActionWithIdOnly = await prisma.gardenAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GardenActionFindManyArgs>(args?: SelectSubset<T, GardenActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GardenAction.
     * @param {GardenActionCreateArgs} args - Arguments to create a GardenAction.
     * @example
     * // Create one GardenAction
     * const GardenAction = await prisma.gardenAction.create({
     *   data: {
     *     // ... data to create a GardenAction
     *   }
     * })
     * 
     */
    create<T extends GardenActionCreateArgs>(args: SelectSubset<T, GardenActionCreateArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GardenActions.
     * @param {GardenActionCreateManyArgs} args - Arguments to create many GardenActions.
     * @example
     * // Create many GardenActions
     * const gardenAction = await prisma.gardenAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GardenActionCreateManyArgs>(args?: SelectSubset<T, GardenActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GardenActions and returns the data saved in the database.
     * @param {GardenActionCreateManyAndReturnArgs} args - Arguments to create many GardenActions.
     * @example
     * // Create many GardenActions
     * const gardenAction = await prisma.gardenAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GardenActions and only return the `id`
     * const gardenActionWithIdOnly = await prisma.gardenAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GardenActionCreateManyAndReturnArgs>(args?: SelectSubset<T, GardenActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GardenAction.
     * @param {GardenActionDeleteArgs} args - Arguments to delete one GardenAction.
     * @example
     * // Delete one GardenAction
     * const GardenAction = await prisma.gardenAction.delete({
     *   where: {
     *     // ... filter to delete one GardenAction
     *   }
     * })
     * 
     */
    delete<T extends GardenActionDeleteArgs>(args: SelectSubset<T, GardenActionDeleteArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GardenAction.
     * @param {GardenActionUpdateArgs} args - Arguments to update one GardenAction.
     * @example
     * // Update one GardenAction
     * const gardenAction = await prisma.gardenAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GardenActionUpdateArgs>(args: SelectSubset<T, GardenActionUpdateArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GardenActions.
     * @param {GardenActionDeleteManyArgs} args - Arguments to filter GardenActions to delete.
     * @example
     * // Delete a few GardenActions
     * const { count } = await prisma.gardenAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GardenActionDeleteManyArgs>(args?: SelectSubset<T, GardenActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GardenActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GardenActions
     * const gardenAction = await prisma.gardenAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GardenActionUpdateManyArgs>(args: SelectSubset<T, GardenActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GardenActions and returns the data updated in the database.
     * @param {GardenActionUpdateManyAndReturnArgs} args - Arguments to update many GardenActions.
     * @example
     * // Update many GardenActions
     * const gardenAction = await prisma.gardenAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GardenActions and only return the `id`
     * const gardenActionWithIdOnly = await prisma.gardenAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GardenActionUpdateManyAndReturnArgs>(args: SelectSubset<T, GardenActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GardenAction.
     * @param {GardenActionUpsertArgs} args - Arguments to update or create a GardenAction.
     * @example
     * // Update or create a GardenAction
     * const gardenAction = await prisma.gardenAction.upsert({
     *   create: {
     *     // ... data to create a GardenAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GardenAction we want to update
     *   }
     * })
     */
    upsert<T extends GardenActionUpsertArgs>(args: SelectSubset<T, GardenActionUpsertArgs<ExtArgs>>): Prisma__GardenActionClient<$Result.GetResult<Prisma.$GardenActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GardenActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionCountArgs} args - Arguments to filter GardenActions to count.
     * @example
     * // Count the number of GardenActions
     * const count = await prisma.gardenAction.count({
     *   where: {
     *     // ... the filter for the GardenActions we want to count
     *   }
     * })
    **/
    count<T extends GardenActionCountArgs>(
      args?: Subset<T, GardenActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GardenActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GardenAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GardenActionAggregateArgs>(args: Subset<T, GardenActionAggregateArgs>): Prisma.PrismaPromise<GetGardenActionAggregateType<T>>

    /**
     * Group by GardenAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardenActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GardenActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GardenActionGroupByArgs['orderBy'] }
        : { orderBy?: GardenActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GardenActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGardenActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GardenAction model
   */
  readonly fields: GardenActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GardenAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GardenActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionType<T extends ActionTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionTypeDefaultArgs<ExtArgs>>): Prisma__ActionTypeClient<$Result.GetResult<Prisma.$ActionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    garden<T extends GardenAction$gardenArgs<ExtArgs> = {}>(args?: Subset<T, GardenAction$gardenArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    container<T extends GardenAction$containerArgs<ExtArgs> = {}>(args?: Subset<T, GardenAction$containerArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    containerPlant<T extends GardenAction$containerPlantArgs<ExtArgs> = {}>(args?: Subset<T, GardenAction$containerPlantArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GardenAction model
   */
  interface GardenActionFieldRefs {
    readonly id: FieldRef<"GardenAction", 'Int'>
    readonly actionTypeId: FieldRef<"GardenAction", 'Int'>
    readonly userId: FieldRef<"GardenAction", 'String'>
    readonly gardenId: FieldRef<"GardenAction", 'Int'>
    readonly containerId: FieldRef<"GardenAction", 'Int'>
    readonly containerPlantId: FieldRef<"GardenAction", 'Int'>
    readonly actionDate: FieldRef<"GardenAction", 'DateTime'>
    readonly quantity: FieldRef<"GardenAction", 'Decimal'>
    readonly unit: FieldRef<"GardenAction", 'String'>
    readonly notes: FieldRef<"GardenAction", 'String'>
    readonly successRating: FieldRef<"GardenAction", 'Int'>
    readonly createdAt: FieldRef<"GardenAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GardenAction findUnique
   */
  export type GardenActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter, which GardenAction to fetch.
     */
    where: GardenActionWhereUniqueInput
  }

  /**
   * GardenAction findUniqueOrThrow
   */
  export type GardenActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter, which GardenAction to fetch.
     */
    where: GardenActionWhereUniqueInput
  }

  /**
   * GardenAction findFirst
   */
  export type GardenActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter, which GardenAction to fetch.
     */
    where?: GardenActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenActions to fetch.
     */
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GardenActions.
     */
    cursor?: GardenActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GardenActions.
     */
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * GardenAction findFirstOrThrow
   */
  export type GardenActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter, which GardenAction to fetch.
     */
    where?: GardenActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenActions to fetch.
     */
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GardenActions.
     */
    cursor?: GardenActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GardenActions.
     */
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * GardenAction findMany
   */
  export type GardenActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter, which GardenActions to fetch.
     */
    where?: GardenActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GardenActions to fetch.
     */
    orderBy?: GardenActionOrderByWithRelationInput | GardenActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GardenActions.
     */
    cursor?: GardenActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GardenActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GardenActions.
     */
    skip?: number
    distinct?: GardenActionScalarFieldEnum | GardenActionScalarFieldEnum[]
  }

  /**
   * GardenAction create
   */
  export type GardenActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * The data needed to create a GardenAction.
     */
    data: XOR<GardenActionCreateInput, GardenActionUncheckedCreateInput>
  }

  /**
   * GardenAction createMany
   */
  export type GardenActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GardenActions.
     */
    data: GardenActionCreateManyInput | GardenActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GardenAction createManyAndReturn
   */
  export type GardenActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * The data used to create many GardenActions.
     */
    data: GardenActionCreateManyInput | GardenActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GardenAction update
   */
  export type GardenActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * The data needed to update a GardenAction.
     */
    data: XOR<GardenActionUpdateInput, GardenActionUncheckedUpdateInput>
    /**
     * Choose, which GardenAction to update.
     */
    where: GardenActionWhereUniqueInput
  }

  /**
   * GardenAction updateMany
   */
  export type GardenActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GardenActions.
     */
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyInput>
    /**
     * Filter which GardenActions to update
     */
    where?: GardenActionWhereInput
    /**
     * Limit how many GardenActions to update.
     */
    limit?: number
  }

  /**
   * GardenAction updateManyAndReturn
   */
  export type GardenActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * The data used to update GardenActions.
     */
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyInput>
    /**
     * Filter which GardenActions to update
     */
    where?: GardenActionWhereInput
    /**
     * Limit how many GardenActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GardenAction upsert
   */
  export type GardenActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * The filter to search for the GardenAction to update in case it exists.
     */
    where: GardenActionWhereUniqueInput
    /**
     * In case the GardenAction found by the `where` argument doesn't exist, create a new GardenAction with this data.
     */
    create: XOR<GardenActionCreateInput, GardenActionUncheckedCreateInput>
    /**
     * In case the GardenAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GardenActionUpdateInput, GardenActionUncheckedUpdateInput>
  }

  /**
   * GardenAction delete
   */
  export type GardenActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
    /**
     * Filter which GardenAction to delete.
     */
    where: GardenActionWhereUniqueInput
  }

  /**
   * GardenAction deleteMany
   */
  export type GardenActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GardenActions to delete
     */
    where?: GardenActionWhereInput
    /**
     * Limit how many GardenActions to delete.
     */
    limit?: number
  }

  /**
   * GardenAction.garden
   */
  export type GardenAction$gardenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    where?: GardenWhereInput
  }

  /**
   * GardenAction.container
   */
  export type GardenAction$containerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
  }

  /**
   * GardenAction.containerPlant
   */
  export type GardenAction$containerPlantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    where?: ContainerPlantWhereInput
  }

  /**
   * GardenAction without action
   */
  export type GardenActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GardenAction
     */
    select?: GardenActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GardenAction
     */
    omit?: GardenActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenActionInclude<ExtArgs> | null
  }


  /**
   * Model Harvest
   */

  export type AggregateHarvest = {
    _count: HarvestCountAggregateOutputType | null
    _avg: HarvestAvgAggregateOutputType | null
    _sum: HarvestSumAggregateOutputType | null
    _min: HarvestMinAggregateOutputType | null
    _max: HarvestMaxAggregateOutputType | null
  }

  export type HarvestAvgAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    quantity: Decimal | null
    qualityRating: number | null
  }

  export type HarvestSumAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    quantity: Decimal | null
    qualityRating: number | null
  }

  export type HarvestMinAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    harvestDate: Date | null
    quantity: Decimal | null
    unit: string | null
    qualityRating: number | null
    notes: string | null
    imageUrl: string | null
  }

  export type HarvestMaxAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    harvestDate: Date | null
    quantity: Decimal | null
    unit: string | null
    qualityRating: number | null
    notes: string | null
    imageUrl: string | null
  }

  export type HarvestCountAggregateOutputType = {
    id: number
    containerPlantId: number
    harvestDate: number
    quantity: number
    unit: number
    qualityRating: number
    notes: number
    imageUrl: number
    _all: number
  }


  export type HarvestAvgAggregateInputType = {
    id?: true
    containerPlantId?: true
    quantity?: true
    qualityRating?: true
  }

  export type HarvestSumAggregateInputType = {
    id?: true
    containerPlantId?: true
    quantity?: true
    qualityRating?: true
  }

  export type HarvestMinAggregateInputType = {
    id?: true
    containerPlantId?: true
    harvestDate?: true
    quantity?: true
    unit?: true
    qualityRating?: true
    notes?: true
    imageUrl?: true
  }

  export type HarvestMaxAggregateInputType = {
    id?: true
    containerPlantId?: true
    harvestDate?: true
    quantity?: true
    unit?: true
    qualityRating?: true
    notes?: true
    imageUrl?: true
  }

  export type HarvestCountAggregateInputType = {
    id?: true
    containerPlantId?: true
    harvestDate?: true
    quantity?: true
    unit?: true
    qualityRating?: true
    notes?: true
    imageUrl?: true
    _all?: true
  }

  export type HarvestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Harvest to aggregate.
     */
    where?: HarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Harvests to fetch.
     */
    orderBy?: HarvestOrderByWithRelationInput | HarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Harvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Harvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Harvests
    **/
    _count?: true | HarvestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HarvestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HarvestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HarvestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HarvestMaxAggregateInputType
  }

  export type GetHarvestAggregateType<T extends HarvestAggregateArgs> = {
        [P in keyof T & keyof AggregateHarvest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHarvest[P]>
      : GetScalarType<T[P], AggregateHarvest[P]>
  }




  export type HarvestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HarvestWhereInput
    orderBy?: HarvestOrderByWithAggregationInput | HarvestOrderByWithAggregationInput[]
    by: HarvestScalarFieldEnum[] | HarvestScalarFieldEnum
    having?: HarvestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HarvestCountAggregateInputType | true
    _avg?: HarvestAvgAggregateInputType
    _sum?: HarvestSumAggregateInputType
    _min?: HarvestMinAggregateInputType
    _max?: HarvestMaxAggregateInputType
  }

  export type HarvestGroupByOutputType = {
    id: number
    containerPlantId: number
    harvestDate: Date
    quantity: Decimal | null
    unit: string | null
    qualityRating: number | null
    notes: string | null
    imageUrl: string | null
    _count: HarvestCountAggregateOutputType | null
    _avg: HarvestAvgAggregateOutputType | null
    _sum: HarvestSumAggregateOutputType | null
    _min: HarvestMinAggregateOutputType | null
    _max: HarvestMaxAggregateOutputType | null
  }

  type GetHarvestGroupByPayload<T extends HarvestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HarvestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HarvestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HarvestGroupByOutputType[P]>
            : GetScalarType<T[P], HarvestGroupByOutputType[P]>
        }
      >
    >


  export type HarvestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    harvestDate?: boolean
    quantity?: boolean
    unit?: boolean
    qualityRating?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["harvest"]>

  export type HarvestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    harvestDate?: boolean
    quantity?: boolean
    unit?: boolean
    qualityRating?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["harvest"]>

  export type HarvestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    harvestDate?: boolean
    quantity?: boolean
    unit?: boolean
    qualityRating?: boolean
    notes?: boolean
    imageUrl?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["harvest"]>

  export type HarvestSelectScalar = {
    id?: boolean
    containerPlantId?: boolean
    harvestDate?: boolean
    quantity?: boolean
    unit?: boolean
    qualityRating?: boolean
    notes?: boolean
    imageUrl?: boolean
  }

  export type HarvestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerPlantId" | "harvestDate" | "quantity" | "unit" | "qualityRating" | "notes" | "imageUrl", ExtArgs["result"]["harvest"]>
  export type HarvestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type HarvestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type HarvestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }

  export type $HarvestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Harvest"
    objects: {
      containerPlant: Prisma.$ContainerPlantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      containerPlantId: number
      harvestDate: Date
      quantity: Prisma.Decimal | null
      unit: string | null
      qualityRating: number | null
      notes: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["harvest"]>
    composites: {}
  }

  type HarvestGetPayload<S extends boolean | null | undefined | HarvestDefaultArgs> = $Result.GetResult<Prisma.$HarvestPayload, S>

  type HarvestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HarvestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HarvestCountAggregateInputType | true
    }

  export interface HarvestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Harvest'], meta: { name: 'Harvest' } }
    /**
     * Find zero or one Harvest that matches the filter.
     * @param {HarvestFindUniqueArgs} args - Arguments to find a Harvest
     * @example
     * // Get one Harvest
     * const harvest = await prisma.harvest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HarvestFindUniqueArgs>(args: SelectSubset<T, HarvestFindUniqueArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Harvest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HarvestFindUniqueOrThrowArgs} args - Arguments to find a Harvest
     * @example
     * // Get one Harvest
     * const harvest = await prisma.harvest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HarvestFindUniqueOrThrowArgs>(args: SelectSubset<T, HarvestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Harvest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestFindFirstArgs} args - Arguments to find a Harvest
     * @example
     * // Get one Harvest
     * const harvest = await prisma.harvest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HarvestFindFirstArgs>(args?: SelectSubset<T, HarvestFindFirstArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Harvest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestFindFirstOrThrowArgs} args - Arguments to find a Harvest
     * @example
     * // Get one Harvest
     * const harvest = await prisma.harvest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HarvestFindFirstOrThrowArgs>(args?: SelectSubset<T, HarvestFindFirstOrThrowArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Harvests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Harvests
     * const harvests = await prisma.harvest.findMany()
     * 
     * // Get first 10 Harvests
     * const harvests = await prisma.harvest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const harvestWithIdOnly = await prisma.harvest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HarvestFindManyArgs>(args?: SelectSubset<T, HarvestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Harvest.
     * @param {HarvestCreateArgs} args - Arguments to create a Harvest.
     * @example
     * // Create one Harvest
     * const Harvest = await prisma.harvest.create({
     *   data: {
     *     // ... data to create a Harvest
     *   }
     * })
     * 
     */
    create<T extends HarvestCreateArgs>(args: SelectSubset<T, HarvestCreateArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Harvests.
     * @param {HarvestCreateManyArgs} args - Arguments to create many Harvests.
     * @example
     * // Create many Harvests
     * const harvest = await prisma.harvest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HarvestCreateManyArgs>(args?: SelectSubset<T, HarvestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Harvests and returns the data saved in the database.
     * @param {HarvestCreateManyAndReturnArgs} args - Arguments to create many Harvests.
     * @example
     * // Create many Harvests
     * const harvest = await prisma.harvest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Harvests and only return the `id`
     * const harvestWithIdOnly = await prisma.harvest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HarvestCreateManyAndReturnArgs>(args?: SelectSubset<T, HarvestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Harvest.
     * @param {HarvestDeleteArgs} args - Arguments to delete one Harvest.
     * @example
     * // Delete one Harvest
     * const Harvest = await prisma.harvest.delete({
     *   where: {
     *     // ... filter to delete one Harvest
     *   }
     * })
     * 
     */
    delete<T extends HarvestDeleteArgs>(args: SelectSubset<T, HarvestDeleteArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Harvest.
     * @param {HarvestUpdateArgs} args - Arguments to update one Harvest.
     * @example
     * // Update one Harvest
     * const harvest = await prisma.harvest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HarvestUpdateArgs>(args: SelectSubset<T, HarvestUpdateArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Harvests.
     * @param {HarvestDeleteManyArgs} args - Arguments to filter Harvests to delete.
     * @example
     * // Delete a few Harvests
     * const { count } = await prisma.harvest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HarvestDeleteManyArgs>(args?: SelectSubset<T, HarvestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Harvests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Harvests
     * const harvest = await prisma.harvest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HarvestUpdateManyArgs>(args: SelectSubset<T, HarvestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Harvests and returns the data updated in the database.
     * @param {HarvestUpdateManyAndReturnArgs} args - Arguments to update many Harvests.
     * @example
     * // Update many Harvests
     * const harvest = await prisma.harvest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Harvests and only return the `id`
     * const harvestWithIdOnly = await prisma.harvest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HarvestUpdateManyAndReturnArgs>(args: SelectSubset<T, HarvestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Harvest.
     * @param {HarvestUpsertArgs} args - Arguments to update or create a Harvest.
     * @example
     * // Update or create a Harvest
     * const harvest = await prisma.harvest.upsert({
     *   create: {
     *     // ... data to create a Harvest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Harvest we want to update
     *   }
     * })
     */
    upsert<T extends HarvestUpsertArgs>(args: SelectSubset<T, HarvestUpsertArgs<ExtArgs>>): Prisma__HarvestClient<$Result.GetResult<Prisma.$HarvestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Harvests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestCountArgs} args - Arguments to filter Harvests to count.
     * @example
     * // Count the number of Harvests
     * const count = await prisma.harvest.count({
     *   where: {
     *     // ... the filter for the Harvests we want to count
     *   }
     * })
    **/
    count<T extends HarvestCountArgs>(
      args?: Subset<T, HarvestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HarvestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Harvest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HarvestAggregateArgs>(args: Subset<T, HarvestAggregateArgs>): Prisma.PrismaPromise<GetHarvestAggregateType<T>>

    /**
     * Group by Harvest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarvestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HarvestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HarvestGroupByArgs['orderBy'] }
        : { orderBy?: HarvestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HarvestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHarvestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Harvest model
   */
  readonly fields: HarvestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Harvest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HarvestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containerPlant<T extends ContainerPlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlantDefaultArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Harvest model
   */
  interface HarvestFieldRefs {
    readonly id: FieldRef<"Harvest", 'Int'>
    readonly containerPlantId: FieldRef<"Harvest", 'Int'>
    readonly harvestDate: FieldRef<"Harvest", 'DateTime'>
    readonly quantity: FieldRef<"Harvest", 'Decimal'>
    readonly unit: FieldRef<"Harvest", 'String'>
    readonly qualityRating: FieldRef<"Harvest", 'Int'>
    readonly notes: FieldRef<"Harvest", 'String'>
    readonly imageUrl: FieldRef<"Harvest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Harvest findUnique
   */
  export type HarvestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter, which Harvest to fetch.
     */
    where: HarvestWhereUniqueInput
  }

  /**
   * Harvest findUniqueOrThrow
   */
  export type HarvestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter, which Harvest to fetch.
     */
    where: HarvestWhereUniqueInput
  }

  /**
   * Harvest findFirst
   */
  export type HarvestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter, which Harvest to fetch.
     */
    where?: HarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Harvests to fetch.
     */
    orderBy?: HarvestOrderByWithRelationInput | HarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Harvests.
     */
    cursor?: HarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Harvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Harvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Harvests.
     */
    distinct?: HarvestScalarFieldEnum | HarvestScalarFieldEnum[]
  }

  /**
   * Harvest findFirstOrThrow
   */
  export type HarvestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter, which Harvest to fetch.
     */
    where?: HarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Harvests to fetch.
     */
    orderBy?: HarvestOrderByWithRelationInput | HarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Harvests.
     */
    cursor?: HarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Harvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Harvests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Harvests.
     */
    distinct?: HarvestScalarFieldEnum | HarvestScalarFieldEnum[]
  }

  /**
   * Harvest findMany
   */
  export type HarvestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter, which Harvests to fetch.
     */
    where?: HarvestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Harvests to fetch.
     */
    orderBy?: HarvestOrderByWithRelationInput | HarvestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Harvests.
     */
    cursor?: HarvestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Harvests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Harvests.
     */
    skip?: number
    distinct?: HarvestScalarFieldEnum | HarvestScalarFieldEnum[]
  }

  /**
   * Harvest create
   */
  export type HarvestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * The data needed to create a Harvest.
     */
    data: XOR<HarvestCreateInput, HarvestUncheckedCreateInput>
  }

  /**
   * Harvest createMany
   */
  export type HarvestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Harvests.
     */
    data: HarvestCreateManyInput | HarvestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Harvest createManyAndReturn
   */
  export type HarvestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * The data used to create many Harvests.
     */
    data: HarvestCreateManyInput | HarvestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Harvest update
   */
  export type HarvestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * The data needed to update a Harvest.
     */
    data: XOR<HarvestUpdateInput, HarvestUncheckedUpdateInput>
    /**
     * Choose, which Harvest to update.
     */
    where: HarvestWhereUniqueInput
  }

  /**
   * Harvest updateMany
   */
  export type HarvestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Harvests.
     */
    data: XOR<HarvestUpdateManyMutationInput, HarvestUncheckedUpdateManyInput>
    /**
     * Filter which Harvests to update
     */
    where?: HarvestWhereInput
    /**
     * Limit how many Harvests to update.
     */
    limit?: number
  }

  /**
   * Harvest updateManyAndReturn
   */
  export type HarvestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * The data used to update Harvests.
     */
    data: XOR<HarvestUpdateManyMutationInput, HarvestUncheckedUpdateManyInput>
    /**
     * Filter which Harvests to update
     */
    where?: HarvestWhereInput
    /**
     * Limit how many Harvests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Harvest upsert
   */
  export type HarvestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * The filter to search for the Harvest to update in case it exists.
     */
    where: HarvestWhereUniqueInput
    /**
     * In case the Harvest found by the `where` argument doesn't exist, create a new Harvest with this data.
     */
    create: XOR<HarvestCreateInput, HarvestUncheckedCreateInput>
    /**
     * In case the Harvest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HarvestUpdateInput, HarvestUncheckedUpdateInput>
  }

  /**
   * Harvest delete
   */
  export type HarvestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
    /**
     * Filter which Harvest to delete.
     */
    where: HarvestWhereUniqueInput
  }

  /**
   * Harvest deleteMany
   */
  export type HarvestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Harvests to delete
     */
    where?: HarvestWhereInput
    /**
     * Limit how many Harvests to delete.
     */
    limit?: number
  }

  /**
   * Harvest without action
   */
  export type HarvestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Harvest
     */
    select?: HarvestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Harvest
     */
    omit?: HarvestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HarvestInclude<ExtArgs> | null
  }


  /**
   * Model ContainerHistory
   */

  export type AggregateContainerHistory = {
    _count: ContainerHistoryCountAggregateOutputType | null
    _avg: ContainerHistoryAvgAggregateOutputType | null
    _sum: ContainerHistorySumAggregateOutputType | null
    _min: ContainerHistoryMinAggregateOutputType | null
    _max: ContainerHistoryMaxAggregateOutputType | null
  }

  export type ContainerHistoryAvgAggregateOutputType = {
    id: number | null
    containerId: number | null
    previousContainerId: number | null
    previousGardenId: number | null
    newGardenId: number | null
  }

  export type ContainerHistorySumAggregateOutputType = {
    id: number | null
    containerId: number | null
    previousContainerId: number | null
    previousGardenId: number | null
    newGardenId: number | null
  }

  export type ContainerHistoryMinAggregateOutputType = {
    id: number | null
    containerId: number | null
    previousContainerId: number | null
    previousGardenId: number | null
    newGardenId: number | null
    moveDate: Date | null
    reason: string | null
  }

  export type ContainerHistoryMaxAggregateOutputType = {
    id: number | null
    containerId: number | null
    previousContainerId: number | null
    previousGardenId: number | null
    newGardenId: number | null
    moveDate: Date | null
    reason: string | null
  }

  export type ContainerHistoryCountAggregateOutputType = {
    id: number
    containerId: number
    previousContainerId: number
    previousGardenId: number
    newGardenId: number
    moveDate: number
    reason: number
    _all: number
  }


  export type ContainerHistoryAvgAggregateInputType = {
    id?: true
    containerId?: true
    previousContainerId?: true
    previousGardenId?: true
    newGardenId?: true
  }

  export type ContainerHistorySumAggregateInputType = {
    id?: true
    containerId?: true
    previousContainerId?: true
    previousGardenId?: true
    newGardenId?: true
  }

  export type ContainerHistoryMinAggregateInputType = {
    id?: true
    containerId?: true
    previousContainerId?: true
    previousGardenId?: true
    newGardenId?: true
    moveDate?: true
    reason?: true
  }

  export type ContainerHistoryMaxAggregateInputType = {
    id?: true
    containerId?: true
    previousContainerId?: true
    previousGardenId?: true
    newGardenId?: true
    moveDate?: true
    reason?: true
  }

  export type ContainerHistoryCountAggregateInputType = {
    id?: true
    containerId?: true
    previousContainerId?: true
    previousGardenId?: true
    newGardenId?: true
    moveDate?: true
    reason?: true
    _all?: true
  }

  export type ContainerHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerHistory to aggregate.
     */
    where?: ContainerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerHistories to fetch.
     */
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContainerHistories
    **/
    _count?: true | ContainerHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerHistoryMaxAggregateInputType
  }

  export type GetContainerHistoryAggregateType<T extends ContainerHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateContainerHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainerHistory[P]>
      : GetScalarType<T[P], AggregateContainerHistory[P]>
  }




  export type ContainerHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerHistoryWhereInput
    orderBy?: ContainerHistoryOrderByWithAggregationInput | ContainerHistoryOrderByWithAggregationInput[]
    by: ContainerHistoryScalarFieldEnum[] | ContainerHistoryScalarFieldEnum
    having?: ContainerHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerHistoryCountAggregateInputType | true
    _avg?: ContainerHistoryAvgAggregateInputType
    _sum?: ContainerHistorySumAggregateInputType
    _min?: ContainerHistoryMinAggregateInputType
    _max?: ContainerHistoryMaxAggregateInputType
  }

  export type ContainerHistoryGroupByOutputType = {
    id: number
    containerId: number
    previousContainerId: number | null
    previousGardenId: number | null
    newGardenId: number | null
    moveDate: Date
    reason: string | null
    _count: ContainerHistoryCountAggregateOutputType | null
    _avg: ContainerHistoryAvgAggregateOutputType | null
    _sum: ContainerHistorySumAggregateOutputType | null
    _min: ContainerHistoryMinAggregateOutputType | null
    _max: ContainerHistoryMaxAggregateOutputType | null
  }

  type GetContainerHistoryGroupByPayload<T extends ContainerHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ContainerHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    previousContainerId?: boolean
    previousGardenId?: boolean
    newGardenId?: boolean
    moveDate?: boolean
    reason?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }, ExtArgs["result"]["containerHistory"]>

  export type ContainerHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    previousContainerId?: boolean
    previousGardenId?: boolean
    newGardenId?: boolean
    moveDate?: boolean
    reason?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }, ExtArgs["result"]["containerHistory"]>

  export type ContainerHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerId?: boolean
    previousContainerId?: boolean
    previousGardenId?: boolean
    newGardenId?: boolean
    moveDate?: boolean
    reason?: boolean
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }, ExtArgs["result"]["containerHistory"]>

  export type ContainerHistorySelectScalar = {
    id?: boolean
    containerId?: boolean
    previousContainerId?: boolean
    previousGardenId?: boolean
    newGardenId?: boolean
    moveDate?: boolean
    reason?: boolean
  }

  export type ContainerHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerId" | "previousContainerId" | "previousGardenId" | "newGardenId" | "moveDate" | "reason", ExtArgs["result"]["containerHistory"]>
  export type ContainerHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }
  export type ContainerHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }
  export type ContainerHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    previousContainer?: boolean | ContainerHistory$previousContainerArgs<ExtArgs>
    previousGarden?: boolean | ContainerHistory$previousGardenArgs<ExtArgs>
    newGarden?: boolean | ContainerHistory$newGardenArgs<ExtArgs>
  }

  export type $ContainerHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContainerHistory"
    objects: {
      container: Prisma.$ContainerPayload<ExtArgs>
      previousContainer: Prisma.$ContainerPayload<ExtArgs> | null
      previousGarden: Prisma.$GardenPayload<ExtArgs> | null
      newGarden: Prisma.$GardenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      containerId: number
      previousContainerId: number | null
      previousGardenId: number | null
      newGardenId: number | null
      moveDate: Date
      reason: string | null
    }, ExtArgs["result"]["containerHistory"]>
    composites: {}
  }

  type ContainerHistoryGetPayload<S extends boolean | null | undefined | ContainerHistoryDefaultArgs> = $Result.GetResult<Prisma.$ContainerHistoryPayload, S>

  type ContainerHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContainerHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContainerHistoryCountAggregateInputType | true
    }

  export interface ContainerHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContainerHistory'], meta: { name: 'ContainerHistory' } }
    /**
     * Find zero or one ContainerHistory that matches the filter.
     * @param {ContainerHistoryFindUniqueArgs} args - Arguments to find a ContainerHistory
     * @example
     * // Get one ContainerHistory
     * const containerHistory = await prisma.containerHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerHistoryFindUniqueArgs>(args: SelectSubset<T, ContainerHistoryFindUniqueArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContainerHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContainerHistoryFindUniqueOrThrowArgs} args - Arguments to find a ContainerHistory
     * @example
     * // Get one ContainerHistory
     * const containerHistory = await prisma.containerHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryFindFirstArgs} args - Arguments to find a ContainerHistory
     * @example
     * // Get one ContainerHistory
     * const containerHistory = await prisma.containerHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerHistoryFindFirstArgs>(args?: SelectSubset<T, ContainerHistoryFindFirstArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContainerHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryFindFirstOrThrowArgs} args - Arguments to find a ContainerHistory
     * @example
     * // Get one ContainerHistory
     * const containerHistory = await prisma.containerHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContainerHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContainerHistories
     * const containerHistories = await prisma.containerHistory.findMany()
     * 
     * // Get first 10 ContainerHistories
     * const containerHistories = await prisma.containerHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerHistoryWithIdOnly = await prisma.containerHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerHistoryFindManyArgs>(args?: SelectSubset<T, ContainerHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContainerHistory.
     * @param {ContainerHistoryCreateArgs} args - Arguments to create a ContainerHistory.
     * @example
     * // Create one ContainerHistory
     * const ContainerHistory = await prisma.containerHistory.create({
     *   data: {
     *     // ... data to create a ContainerHistory
     *   }
     * })
     * 
     */
    create<T extends ContainerHistoryCreateArgs>(args: SelectSubset<T, ContainerHistoryCreateArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContainerHistories.
     * @param {ContainerHistoryCreateManyArgs} args - Arguments to create many ContainerHistories.
     * @example
     * // Create many ContainerHistories
     * const containerHistory = await prisma.containerHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerHistoryCreateManyArgs>(args?: SelectSubset<T, ContainerHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContainerHistories and returns the data saved in the database.
     * @param {ContainerHistoryCreateManyAndReturnArgs} args - Arguments to create many ContainerHistories.
     * @example
     * // Create many ContainerHistories
     * const containerHistory = await prisma.containerHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContainerHistories and only return the `id`
     * const containerHistoryWithIdOnly = await prisma.containerHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContainerHistory.
     * @param {ContainerHistoryDeleteArgs} args - Arguments to delete one ContainerHistory.
     * @example
     * // Delete one ContainerHistory
     * const ContainerHistory = await prisma.containerHistory.delete({
     *   where: {
     *     // ... filter to delete one ContainerHistory
     *   }
     * })
     * 
     */
    delete<T extends ContainerHistoryDeleteArgs>(args: SelectSubset<T, ContainerHistoryDeleteArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContainerHistory.
     * @param {ContainerHistoryUpdateArgs} args - Arguments to update one ContainerHistory.
     * @example
     * // Update one ContainerHistory
     * const containerHistory = await prisma.containerHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerHistoryUpdateArgs>(args: SelectSubset<T, ContainerHistoryUpdateArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContainerHistories.
     * @param {ContainerHistoryDeleteManyArgs} args - Arguments to filter ContainerHistories to delete.
     * @example
     * // Delete a few ContainerHistories
     * const { count } = await prisma.containerHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerHistoryDeleteManyArgs>(args?: SelectSubset<T, ContainerHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContainerHistories
     * const containerHistory = await prisma.containerHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerHistoryUpdateManyArgs>(args: SelectSubset<T, ContainerHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerHistories and returns the data updated in the database.
     * @param {ContainerHistoryUpdateManyAndReturnArgs} args - Arguments to update many ContainerHistories.
     * @example
     * // Update many ContainerHistories
     * const containerHistory = await prisma.containerHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContainerHistories and only return the `id`
     * const containerHistoryWithIdOnly = await prisma.containerHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContainerHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ContainerHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContainerHistory.
     * @param {ContainerHistoryUpsertArgs} args - Arguments to update or create a ContainerHistory.
     * @example
     * // Update or create a ContainerHistory
     * const containerHistory = await prisma.containerHistory.upsert({
     *   create: {
     *     // ... data to create a ContainerHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContainerHistory we want to update
     *   }
     * })
     */
    upsert<T extends ContainerHistoryUpsertArgs>(args: SelectSubset<T, ContainerHistoryUpsertArgs<ExtArgs>>): Prisma__ContainerHistoryClient<$Result.GetResult<Prisma.$ContainerHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContainerHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryCountArgs} args - Arguments to filter ContainerHistories to count.
     * @example
     * // Count the number of ContainerHistories
     * const count = await prisma.containerHistory.count({
     *   where: {
     *     // ... the filter for the ContainerHistories we want to count
     *   }
     * })
    **/
    count<T extends ContainerHistoryCountArgs>(
      args?: Subset<T, ContainerHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContainerHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerHistoryAggregateArgs>(args: Subset<T, ContainerHistoryAggregateArgs>): Prisma.PrismaPromise<GetContainerHistoryAggregateType<T>>

    /**
     * Group by ContainerHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ContainerHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContainerHistory model
   */
  readonly fields: ContainerHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContainerHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    previousContainer<T extends ContainerHistory$previousContainerArgs<ExtArgs> = {}>(args?: Subset<T, ContainerHistory$previousContainerArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    previousGarden<T extends ContainerHistory$previousGardenArgs<ExtArgs> = {}>(args?: Subset<T, ContainerHistory$previousGardenArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    newGarden<T extends ContainerHistory$newGardenArgs<ExtArgs> = {}>(args?: Subset<T, ContainerHistory$newGardenArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContainerHistory model
   */
  interface ContainerHistoryFieldRefs {
    readonly id: FieldRef<"ContainerHistory", 'Int'>
    readonly containerId: FieldRef<"ContainerHistory", 'Int'>
    readonly previousContainerId: FieldRef<"ContainerHistory", 'Int'>
    readonly previousGardenId: FieldRef<"ContainerHistory", 'Int'>
    readonly newGardenId: FieldRef<"ContainerHistory", 'Int'>
    readonly moveDate: FieldRef<"ContainerHistory", 'DateTime'>
    readonly reason: FieldRef<"ContainerHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContainerHistory findUnique
   */
  export type ContainerHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ContainerHistory to fetch.
     */
    where: ContainerHistoryWhereUniqueInput
  }

  /**
   * ContainerHistory findUniqueOrThrow
   */
  export type ContainerHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ContainerHistory to fetch.
     */
    where: ContainerHistoryWhereUniqueInput
  }

  /**
   * ContainerHistory findFirst
   */
  export type ContainerHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ContainerHistory to fetch.
     */
    where?: ContainerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerHistories to fetch.
     */
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerHistories.
     */
    cursor?: ContainerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerHistories.
     */
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * ContainerHistory findFirstOrThrow
   */
  export type ContainerHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ContainerHistory to fetch.
     */
    where?: ContainerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerHistories to fetch.
     */
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerHistories.
     */
    cursor?: ContainerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerHistories.
     */
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * ContainerHistory findMany
   */
  export type ContainerHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ContainerHistories to fetch.
     */
    where?: ContainerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerHistories to fetch.
     */
    orderBy?: ContainerHistoryOrderByWithRelationInput | ContainerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContainerHistories.
     */
    cursor?: ContainerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerHistories.
     */
    skip?: number
    distinct?: ContainerHistoryScalarFieldEnum | ContainerHistoryScalarFieldEnum[]
  }

  /**
   * ContainerHistory create
   */
  export type ContainerHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ContainerHistory.
     */
    data: XOR<ContainerHistoryCreateInput, ContainerHistoryUncheckedCreateInput>
  }

  /**
   * ContainerHistory createMany
   */
  export type ContainerHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContainerHistories.
     */
    data: ContainerHistoryCreateManyInput | ContainerHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerHistory createManyAndReturn
   */
  export type ContainerHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ContainerHistories.
     */
    data: ContainerHistoryCreateManyInput | ContainerHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContainerHistory update
   */
  export type ContainerHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ContainerHistory.
     */
    data: XOR<ContainerHistoryUpdateInput, ContainerHistoryUncheckedUpdateInput>
    /**
     * Choose, which ContainerHistory to update.
     */
    where: ContainerHistoryWhereUniqueInput
  }

  /**
   * ContainerHistory updateMany
   */
  export type ContainerHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContainerHistories.
     */
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ContainerHistories to update
     */
    where?: ContainerHistoryWhereInput
    /**
     * Limit how many ContainerHistories to update.
     */
    limit?: number
  }

  /**
   * ContainerHistory updateManyAndReturn
   */
  export type ContainerHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ContainerHistories.
     */
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ContainerHistories to update
     */
    where?: ContainerHistoryWhereInput
    /**
     * Limit how many ContainerHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContainerHistory upsert
   */
  export type ContainerHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ContainerHistory to update in case it exists.
     */
    where: ContainerHistoryWhereUniqueInput
    /**
     * In case the ContainerHistory found by the `where` argument doesn't exist, create a new ContainerHistory with this data.
     */
    create: XOR<ContainerHistoryCreateInput, ContainerHistoryUncheckedCreateInput>
    /**
     * In case the ContainerHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerHistoryUpdateInput, ContainerHistoryUncheckedUpdateInput>
  }

  /**
   * ContainerHistory delete
   */
  export type ContainerHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
    /**
     * Filter which ContainerHistory to delete.
     */
    where: ContainerHistoryWhereUniqueInput
  }

  /**
   * ContainerHistory deleteMany
   */
  export type ContainerHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerHistories to delete
     */
    where?: ContainerHistoryWhereInput
    /**
     * Limit how many ContainerHistories to delete.
     */
    limit?: number
  }

  /**
   * ContainerHistory.previousContainer
   */
  export type ContainerHistory$previousContainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
  }

  /**
   * ContainerHistory.previousGarden
   */
  export type ContainerHistory$previousGardenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    where?: GardenWhereInput
  }

  /**
   * ContainerHistory.newGarden
   */
  export type ContainerHistory$newGardenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    where?: GardenWhereInput
  }

  /**
   * ContainerHistory without action
   */
  export type ContainerHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerHistory
     */
    select?: ContainerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerHistory
     */
    omit?: ContainerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PlantMovementHistory
   */

  export type AggregatePlantMovementHistory = {
    _count: PlantMovementHistoryCountAggregateOutputType | null
    _avg: PlantMovementHistoryAvgAggregateOutputType | null
    _sum: PlantMovementHistorySumAggregateOutputType | null
    _min: PlantMovementHistoryMinAggregateOutputType | null
    _max: PlantMovementHistoryMaxAggregateOutputType | null
  }

  export type PlantMovementHistoryAvgAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    previousContainerId: number | null
    newContainerId: number | null
  }

  export type PlantMovementHistorySumAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    previousContainerId: number | null
    newContainerId: number | null
  }

  export type PlantMovementHistoryMinAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    previousContainerId: number | null
    newContainerId: number | null
    moveDate: Date | null
    reason: string | null
    plantConditionBefore: string | null
    plantConditionAfter: string | null
  }

  export type PlantMovementHistoryMaxAggregateOutputType = {
    id: number | null
    containerPlantId: number | null
    previousContainerId: number | null
    newContainerId: number | null
    moveDate: Date | null
    reason: string | null
    plantConditionBefore: string | null
    plantConditionAfter: string | null
  }

  export type PlantMovementHistoryCountAggregateOutputType = {
    id: number
    containerPlantId: number
    previousContainerId: number
    newContainerId: number
    moveDate: number
    reason: number
    plantConditionBefore: number
    plantConditionAfter: number
    _all: number
  }


  export type PlantMovementHistoryAvgAggregateInputType = {
    id?: true
    containerPlantId?: true
    previousContainerId?: true
    newContainerId?: true
  }

  export type PlantMovementHistorySumAggregateInputType = {
    id?: true
    containerPlantId?: true
    previousContainerId?: true
    newContainerId?: true
  }

  export type PlantMovementHistoryMinAggregateInputType = {
    id?: true
    containerPlantId?: true
    previousContainerId?: true
    newContainerId?: true
    moveDate?: true
    reason?: true
    plantConditionBefore?: true
    plantConditionAfter?: true
  }

  export type PlantMovementHistoryMaxAggregateInputType = {
    id?: true
    containerPlantId?: true
    previousContainerId?: true
    newContainerId?: true
    moveDate?: true
    reason?: true
    plantConditionBefore?: true
    plantConditionAfter?: true
  }

  export type PlantMovementHistoryCountAggregateInputType = {
    id?: true
    containerPlantId?: true
    previousContainerId?: true
    newContainerId?: true
    moveDate?: true
    reason?: true
    plantConditionBefore?: true
    plantConditionAfter?: true
    _all?: true
  }

  export type PlantMovementHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantMovementHistory to aggregate.
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantMovementHistories to fetch.
     */
    orderBy?: PlantMovementHistoryOrderByWithRelationInput | PlantMovementHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantMovementHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantMovementHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantMovementHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantMovementHistories
    **/
    _count?: true | PlantMovementHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantMovementHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantMovementHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantMovementHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantMovementHistoryMaxAggregateInputType
  }

  export type GetPlantMovementHistoryAggregateType<T extends PlantMovementHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantMovementHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantMovementHistory[P]>
      : GetScalarType<T[P], AggregatePlantMovementHistory[P]>
  }




  export type PlantMovementHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantMovementHistoryWhereInput
    orderBy?: PlantMovementHistoryOrderByWithAggregationInput | PlantMovementHistoryOrderByWithAggregationInput[]
    by: PlantMovementHistoryScalarFieldEnum[] | PlantMovementHistoryScalarFieldEnum
    having?: PlantMovementHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantMovementHistoryCountAggregateInputType | true
    _avg?: PlantMovementHistoryAvgAggregateInputType
    _sum?: PlantMovementHistorySumAggregateInputType
    _min?: PlantMovementHistoryMinAggregateInputType
    _max?: PlantMovementHistoryMaxAggregateInputType
  }

  export type PlantMovementHistoryGroupByOutputType = {
    id: number
    containerPlantId: number
    previousContainerId: number | null
    newContainerId: number | null
    moveDate: Date
    reason: string | null
    plantConditionBefore: string | null
    plantConditionAfter: string | null
    _count: PlantMovementHistoryCountAggregateOutputType | null
    _avg: PlantMovementHistoryAvgAggregateOutputType | null
    _sum: PlantMovementHistorySumAggregateOutputType | null
    _min: PlantMovementHistoryMinAggregateOutputType | null
    _max: PlantMovementHistoryMaxAggregateOutputType | null
  }

  type GetPlantMovementHistoryGroupByPayload<T extends PlantMovementHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantMovementHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantMovementHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantMovementHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PlantMovementHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PlantMovementHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    previousContainerId?: boolean
    newContainerId?: boolean
    moveDate?: boolean
    reason?: boolean
    plantConditionBefore?: boolean
    plantConditionAfter?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantMovementHistory"]>

  export type PlantMovementHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    previousContainerId?: boolean
    newContainerId?: boolean
    moveDate?: boolean
    reason?: boolean
    plantConditionBefore?: boolean
    plantConditionAfter?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantMovementHistory"]>

  export type PlantMovementHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    containerPlantId?: boolean
    previousContainerId?: boolean
    newContainerId?: boolean
    moveDate?: boolean
    reason?: boolean
    plantConditionBefore?: boolean
    plantConditionAfter?: boolean
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plantMovementHistory"]>

  export type PlantMovementHistorySelectScalar = {
    id?: boolean
    containerPlantId?: boolean
    previousContainerId?: boolean
    newContainerId?: boolean
    moveDate?: boolean
    reason?: boolean
    plantConditionBefore?: boolean
    plantConditionAfter?: boolean
  }

  export type PlantMovementHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "containerPlantId" | "previousContainerId" | "newContainerId" | "moveDate" | "reason" | "plantConditionBefore" | "plantConditionAfter", ExtArgs["result"]["plantMovementHistory"]>
  export type PlantMovementHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type PlantMovementHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }
  export type PlantMovementHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containerPlant?: boolean | ContainerPlantDefaultArgs<ExtArgs>
  }

  export type $PlantMovementHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantMovementHistory"
    objects: {
      containerPlant: Prisma.$ContainerPlantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      containerPlantId: number
      previousContainerId: number | null
      newContainerId: number | null
      moveDate: Date
      reason: string | null
      plantConditionBefore: string | null
      plantConditionAfter: string | null
    }, ExtArgs["result"]["plantMovementHistory"]>
    composites: {}
  }

  type PlantMovementHistoryGetPayload<S extends boolean | null | undefined | PlantMovementHistoryDefaultArgs> = $Result.GetResult<Prisma.$PlantMovementHistoryPayload, S>

  type PlantMovementHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantMovementHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantMovementHistoryCountAggregateInputType | true
    }

  export interface PlantMovementHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantMovementHistory'], meta: { name: 'PlantMovementHistory' } }
    /**
     * Find zero or one PlantMovementHistory that matches the filter.
     * @param {PlantMovementHistoryFindUniqueArgs} args - Arguments to find a PlantMovementHistory
     * @example
     * // Get one PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantMovementHistoryFindUniqueArgs>(args: SelectSubset<T, PlantMovementHistoryFindUniqueArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantMovementHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantMovementHistoryFindUniqueOrThrowArgs} args - Arguments to find a PlantMovementHistory
     * @example
     * // Get one PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantMovementHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantMovementHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantMovementHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryFindFirstArgs} args - Arguments to find a PlantMovementHistory
     * @example
     * // Get one PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantMovementHistoryFindFirstArgs>(args?: SelectSubset<T, PlantMovementHistoryFindFirstArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantMovementHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryFindFirstOrThrowArgs} args - Arguments to find a PlantMovementHistory
     * @example
     * // Get one PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantMovementHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantMovementHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantMovementHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantMovementHistories
     * const plantMovementHistories = await prisma.plantMovementHistory.findMany()
     * 
     * // Get first 10 PlantMovementHistories
     * const plantMovementHistories = await prisma.plantMovementHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantMovementHistoryWithIdOnly = await prisma.plantMovementHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantMovementHistoryFindManyArgs>(args?: SelectSubset<T, PlantMovementHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantMovementHistory.
     * @param {PlantMovementHistoryCreateArgs} args - Arguments to create a PlantMovementHistory.
     * @example
     * // Create one PlantMovementHistory
     * const PlantMovementHistory = await prisma.plantMovementHistory.create({
     *   data: {
     *     // ... data to create a PlantMovementHistory
     *   }
     * })
     * 
     */
    create<T extends PlantMovementHistoryCreateArgs>(args: SelectSubset<T, PlantMovementHistoryCreateArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantMovementHistories.
     * @param {PlantMovementHistoryCreateManyArgs} args - Arguments to create many PlantMovementHistories.
     * @example
     * // Create many PlantMovementHistories
     * const plantMovementHistory = await prisma.plantMovementHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantMovementHistoryCreateManyArgs>(args?: SelectSubset<T, PlantMovementHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantMovementHistories and returns the data saved in the database.
     * @param {PlantMovementHistoryCreateManyAndReturnArgs} args - Arguments to create many PlantMovementHistories.
     * @example
     * // Create many PlantMovementHistories
     * const plantMovementHistory = await prisma.plantMovementHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantMovementHistories and only return the `id`
     * const plantMovementHistoryWithIdOnly = await prisma.plantMovementHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantMovementHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantMovementHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantMovementHistory.
     * @param {PlantMovementHistoryDeleteArgs} args - Arguments to delete one PlantMovementHistory.
     * @example
     * // Delete one PlantMovementHistory
     * const PlantMovementHistory = await prisma.plantMovementHistory.delete({
     *   where: {
     *     // ... filter to delete one PlantMovementHistory
     *   }
     * })
     * 
     */
    delete<T extends PlantMovementHistoryDeleteArgs>(args: SelectSubset<T, PlantMovementHistoryDeleteArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantMovementHistory.
     * @param {PlantMovementHistoryUpdateArgs} args - Arguments to update one PlantMovementHistory.
     * @example
     * // Update one PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantMovementHistoryUpdateArgs>(args: SelectSubset<T, PlantMovementHistoryUpdateArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantMovementHistories.
     * @param {PlantMovementHistoryDeleteManyArgs} args - Arguments to filter PlantMovementHistories to delete.
     * @example
     * // Delete a few PlantMovementHistories
     * const { count } = await prisma.plantMovementHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantMovementHistoryDeleteManyArgs>(args?: SelectSubset<T, PlantMovementHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantMovementHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantMovementHistories
     * const plantMovementHistory = await prisma.plantMovementHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantMovementHistoryUpdateManyArgs>(args: SelectSubset<T, PlantMovementHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantMovementHistories and returns the data updated in the database.
     * @param {PlantMovementHistoryUpdateManyAndReturnArgs} args - Arguments to update many PlantMovementHistories.
     * @example
     * // Update many PlantMovementHistories
     * const plantMovementHistory = await prisma.plantMovementHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantMovementHistories and only return the `id`
     * const plantMovementHistoryWithIdOnly = await prisma.plantMovementHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantMovementHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantMovementHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantMovementHistory.
     * @param {PlantMovementHistoryUpsertArgs} args - Arguments to update or create a PlantMovementHistory.
     * @example
     * // Update or create a PlantMovementHistory
     * const plantMovementHistory = await prisma.plantMovementHistory.upsert({
     *   create: {
     *     // ... data to create a PlantMovementHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantMovementHistory we want to update
     *   }
     * })
     */
    upsert<T extends PlantMovementHistoryUpsertArgs>(args: SelectSubset<T, PlantMovementHistoryUpsertArgs<ExtArgs>>): Prisma__PlantMovementHistoryClient<$Result.GetResult<Prisma.$PlantMovementHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantMovementHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryCountArgs} args - Arguments to filter PlantMovementHistories to count.
     * @example
     * // Count the number of PlantMovementHistories
     * const count = await prisma.plantMovementHistory.count({
     *   where: {
     *     // ... the filter for the PlantMovementHistories we want to count
     *   }
     * })
    **/
    count<T extends PlantMovementHistoryCountArgs>(
      args?: Subset<T, PlantMovementHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantMovementHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantMovementHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantMovementHistoryAggregateArgs>(args: Subset<T, PlantMovementHistoryAggregateArgs>): Prisma.PrismaPromise<GetPlantMovementHistoryAggregateType<T>>

    /**
     * Group by PlantMovementHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantMovementHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantMovementHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantMovementHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PlantMovementHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantMovementHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantMovementHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantMovementHistory model
   */
  readonly fields: PlantMovementHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantMovementHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantMovementHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    containerPlant<T extends ContainerPlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerPlantDefaultArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantMovementHistory model
   */
  interface PlantMovementHistoryFieldRefs {
    readonly id: FieldRef<"PlantMovementHistory", 'Int'>
    readonly containerPlantId: FieldRef<"PlantMovementHistory", 'Int'>
    readonly previousContainerId: FieldRef<"PlantMovementHistory", 'Int'>
    readonly newContainerId: FieldRef<"PlantMovementHistory", 'Int'>
    readonly moveDate: FieldRef<"PlantMovementHistory", 'DateTime'>
    readonly reason: FieldRef<"PlantMovementHistory", 'String'>
    readonly plantConditionBefore: FieldRef<"PlantMovementHistory", 'String'>
    readonly plantConditionAfter: FieldRef<"PlantMovementHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlantMovementHistory findUnique
   */
  export type PlantMovementHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlantMovementHistory to fetch.
     */
    where: PlantMovementHistoryWhereUniqueInput
  }

  /**
   * PlantMovementHistory findUniqueOrThrow
   */
  export type PlantMovementHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlantMovementHistory to fetch.
     */
    where: PlantMovementHistoryWhereUniqueInput
  }

  /**
   * PlantMovementHistory findFirst
   */
  export type PlantMovementHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlantMovementHistory to fetch.
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantMovementHistories to fetch.
     */
    orderBy?: PlantMovementHistoryOrderByWithRelationInput | PlantMovementHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantMovementHistories.
     */
    cursor?: PlantMovementHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantMovementHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantMovementHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantMovementHistories.
     */
    distinct?: PlantMovementHistoryScalarFieldEnum | PlantMovementHistoryScalarFieldEnum[]
  }

  /**
   * PlantMovementHistory findFirstOrThrow
   */
  export type PlantMovementHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlantMovementHistory to fetch.
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantMovementHistories to fetch.
     */
    orderBy?: PlantMovementHistoryOrderByWithRelationInput | PlantMovementHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantMovementHistories.
     */
    cursor?: PlantMovementHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantMovementHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantMovementHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantMovementHistories.
     */
    distinct?: PlantMovementHistoryScalarFieldEnum | PlantMovementHistoryScalarFieldEnum[]
  }

  /**
   * PlantMovementHistory findMany
   */
  export type PlantMovementHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlantMovementHistories to fetch.
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantMovementHistories to fetch.
     */
    orderBy?: PlantMovementHistoryOrderByWithRelationInput | PlantMovementHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantMovementHistories.
     */
    cursor?: PlantMovementHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantMovementHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantMovementHistories.
     */
    skip?: number
    distinct?: PlantMovementHistoryScalarFieldEnum | PlantMovementHistoryScalarFieldEnum[]
  }

  /**
   * PlantMovementHistory create
   */
  export type PlantMovementHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PlantMovementHistory.
     */
    data: XOR<PlantMovementHistoryCreateInput, PlantMovementHistoryUncheckedCreateInput>
  }

  /**
   * PlantMovementHistory createMany
   */
  export type PlantMovementHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantMovementHistories.
     */
    data: PlantMovementHistoryCreateManyInput | PlantMovementHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantMovementHistory createManyAndReturn
   */
  export type PlantMovementHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PlantMovementHistories.
     */
    data: PlantMovementHistoryCreateManyInput | PlantMovementHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantMovementHistory update
   */
  export type PlantMovementHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PlantMovementHistory.
     */
    data: XOR<PlantMovementHistoryUpdateInput, PlantMovementHistoryUncheckedUpdateInput>
    /**
     * Choose, which PlantMovementHistory to update.
     */
    where: PlantMovementHistoryWhereUniqueInput
  }

  /**
   * PlantMovementHistory updateMany
   */
  export type PlantMovementHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantMovementHistories.
     */
    data: XOR<PlantMovementHistoryUpdateManyMutationInput, PlantMovementHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PlantMovementHistories to update
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * Limit how many PlantMovementHistories to update.
     */
    limit?: number
  }

  /**
   * PlantMovementHistory updateManyAndReturn
   */
  export type PlantMovementHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PlantMovementHistories.
     */
    data: XOR<PlantMovementHistoryUpdateManyMutationInput, PlantMovementHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PlantMovementHistories to update
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * Limit how many PlantMovementHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlantMovementHistory upsert
   */
  export type PlantMovementHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PlantMovementHistory to update in case it exists.
     */
    where: PlantMovementHistoryWhereUniqueInput
    /**
     * In case the PlantMovementHistory found by the `where` argument doesn't exist, create a new PlantMovementHistory with this data.
     */
    create: XOR<PlantMovementHistoryCreateInput, PlantMovementHistoryUncheckedCreateInput>
    /**
     * In case the PlantMovementHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantMovementHistoryUpdateInput, PlantMovementHistoryUncheckedUpdateInput>
  }

  /**
   * PlantMovementHistory delete
   */
  export type PlantMovementHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
    /**
     * Filter which PlantMovementHistory to delete.
     */
    where: PlantMovementHistoryWhereUniqueInput
  }

  /**
   * PlantMovementHistory deleteMany
   */
  export type PlantMovementHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantMovementHistories to delete
     */
    where?: PlantMovementHistoryWhereInput
    /**
     * Limit how many PlantMovementHistories to delete.
     */
    limit?: number
  }

  /**
   * PlantMovementHistory without action
   */
  export type PlantMovementHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantMovementHistory
     */
    select?: PlantMovementHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantMovementHistory
     */
    omit?: PlantMovementHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantMovementHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SeasonalPlan
   */

  export type AggregateSeasonalPlan = {
    _count: SeasonalPlanCountAggregateOutputType | null
    _avg: SeasonalPlanAvgAggregateOutputType | null
    _sum: SeasonalPlanSumAggregateOutputType | null
    _min: SeasonalPlanMinAggregateOutputType | null
    _max: SeasonalPlanMaxAggregateOutputType | null
  }

  export type SeasonalPlanAvgAggregateOutputType = {
    id: number | null
    gardenId: number | null
    year: number | null
  }

  export type SeasonalPlanSumAggregateOutputType = {
    id: number | null
    gardenId: number | null
    year: number | null
  }

  export type SeasonalPlanMinAggregateOutputType = {
    id: number | null
    gardenId: number | null
    season: string | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonalPlanMaxAggregateOutputType = {
    id: number | null
    gardenId: number | null
    season: string | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonalPlanCountAggregateOutputType = {
    id: number
    gardenId: number
    season: number
    year: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeasonalPlanAvgAggregateInputType = {
    id?: true
    gardenId?: true
    year?: true
  }

  export type SeasonalPlanSumAggregateInputType = {
    id?: true
    gardenId?: true
    year?: true
  }

  export type SeasonalPlanMinAggregateInputType = {
    id?: true
    gardenId?: true
    season?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonalPlanMaxAggregateInputType = {
    id?: true
    gardenId?: true
    season?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonalPlanCountAggregateInputType = {
    id?: true
    gardenId?: true
    season?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeasonalPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalPlan to aggregate.
     */
    where?: SeasonalPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPlans to fetch.
     */
    orderBy?: SeasonalPlanOrderByWithRelationInput | SeasonalPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonalPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeasonalPlans
    **/
    _count?: true | SeasonalPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonalPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonalPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonalPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonalPlanMaxAggregateInputType
  }

  export type GetSeasonalPlanAggregateType<T extends SeasonalPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasonalPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasonalPlan[P]>
      : GetScalarType<T[P], AggregateSeasonalPlan[P]>
  }




  export type SeasonalPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonalPlanWhereInput
    orderBy?: SeasonalPlanOrderByWithAggregationInput | SeasonalPlanOrderByWithAggregationInput[]
    by: SeasonalPlanScalarFieldEnum[] | SeasonalPlanScalarFieldEnum
    having?: SeasonalPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonalPlanCountAggregateInputType | true
    _avg?: SeasonalPlanAvgAggregateInputType
    _sum?: SeasonalPlanSumAggregateInputType
    _min?: SeasonalPlanMinAggregateInputType
    _max?: SeasonalPlanMaxAggregateInputType
  }

  export type SeasonalPlanGroupByOutputType = {
    id: number
    gardenId: number
    season: string
    year: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SeasonalPlanCountAggregateOutputType | null
    _avg: SeasonalPlanAvgAggregateOutputType | null
    _sum: SeasonalPlanSumAggregateOutputType | null
    _min: SeasonalPlanMinAggregateOutputType | null
    _max: SeasonalPlanMaxAggregateOutputType | null
  }

  type GetSeasonalPlanGroupByPayload<T extends SeasonalPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonalPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonalPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonalPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonalPlanGroupByOutputType[P]>
        }
      >
    >


  export type SeasonalPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    season?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    plantings?: boolean | SeasonalPlan$plantingsArgs<ExtArgs>
    _count?: boolean | SeasonalPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seasonalPlan"]>

  export type SeasonalPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    season?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seasonalPlan"]>

  export type SeasonalPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gardenId?: boolean
    season?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seasonalPlan"]>

  export type SeasonalPlanSelectScalar = {
    id?: boolean
    gardenId?: boolean
    season?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeasonalPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gardenId" | "season" | "year" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["seasonalPlan"]>
  export type SeasonalPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
    plantings?: boolean | SeasonalPlan$plantingsArgs<ExtArgs>
    _count?: boolean | SeasonalPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeasonalPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }
  export type SeasonalPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    garden?: boolean | GardenDefaultArgs<ExtArgs>
  }

  export type $SeasonalPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeasonalPlan"
    objects: {
      garden: Prisma.$GardenPayload<ExtArgs>
      plantings: Prisma.$PlannedPlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gardenId: number
      season: string
      year: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seasonalPlan"]>
    composites: {}
  }

  type SeasonalPlanGetPayload<S extends boolean | null | undefined | SeasonalPlanDefaultArgs> = $Result.GetResult<Prisma.$SeasonalPlanPayload, S>

  type SeasonalPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonalPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonalPlanCountAggregateInputType | true
    }

  export interface SeasonalPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeasonalPlan'], meta: { name: 'SeasonalPlan' } }
    /**
     * Find zero or one SeasonalPlan that matches the filter.
     * @param {SeasonalPlanFindUniqueArgs} args - Arguments to find a SeasonalPlan
     * @example
     * // Get one SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonalPlanFindUniqueArgs>(args: SelectSubset<T, SeasonalPlanFindUniqueArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeasonalPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonalPlanFindUniqueOrThrowArgs} args - Arguments to find a SeasonalPlan
     * @example
     * // Get one SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonalPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonalPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeasonalPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanFindFirstArgs} args - Arguments to find a SeasonalPlan
     * @example
     * // Get one SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonalPlanFindFirstArgs>(args?: SelectSubset<T, SeasonalPlanFindFirstArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeasonalPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanFindFirstOrThrowArgs} args - Arguments to find a SeasonalPlan
     * @example
     * // Get one SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonalPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonalPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeasonalPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeasonalPlans
     * const seasonalPlans = await prisma.seasonalPlan.findMany()
     * 
     * // Get first 10 SeasonalPlans
     * const seasonalPlans = await prisma.seasonalPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonalPlanWithIdOnly = await prisma.seasonalPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonalPlanFindManyArgs>(args?: SelectSubset<T, SeasonalPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeasonalPlan.
     * @param {SeasonalPlanCreateArgs} args - Arguments to create a SeasonalPlan.
     * @example
     * // Create one SeasonalPlan
     * const SeasonalPlan = await prisma.seasonalPlan.create({
     *   data: {
     *     // ... data to create a SeasonalPlan
     *   }
     * })
     * 
     */
    create<T extends SeasonalPlanCreateArgs>(args: SelectSubset<T, SeasonalPlanCreateArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeasonalPlans.
     * @param {SeasonalPlanCreateManyArgs} args - Arguments to create many SeasonalPlans.
     * @example
     * // Create many SeasonalPlans
     * const seasonalPlan = await prisma.seasonalPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonalPlanCreateManyArgs>(args?: SelectSubset<T, SeasonalPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeasonalPlans and returns the data saved in the database.
     * @param {SeasonalPlanCreateManyAndReturnArgs} args - Arguments to create many SeasonalPlans.
     * @example
     * // Create many SeasonalPlans
     * const seasonalPlan = await prisma.seasonalPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeasonalPlans and only return the `id`
     * const seasonalPlanWithIdOnly = await prisma.seasonalPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonalPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonalPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeasonalPlan.
     * @param {SeasonalPlanDeleteArgs} args - Arguments to delete one SeasonalPlan.
     * @example
     * // Delete one SeasonalPlan
     * const SeasonalPlan = await prisma.seasonalPlan.delete({
     *   where: {
     *     // ... filter to delete one SeasonalPlan
     *   }
     * })
     * 
     */
    delete<T extends SeasonalPlanDeleteArgs>(args: SelectSubset<T, SeasonalPlanDeleteArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeasonalPlan.
     * @param {SeasonalPlanUpdateArgs} args - Arguments to update one SeasonalPlan.
     * @example
     * // Update one SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonalPlanUpdateArgs>(args: SelectSubset<T, SeasonalPlanUpdateArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeasonalPlans.
     * @param {SeasonalPlanDeleteManyArgs} args - Arguments to filter SeasonalPlans to delete.
     * @example
     * // Delete a few SeasonalPlans
     * const { count } = await prisma.seasonalPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonalPlanDeleteManyArgs>(args?: SelectSubset<T, SeasonalPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeasonalPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeasonalPlans
     * const seasonalPlan = await prisma.seasonalPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonalPlanUpdateManyArgs>(args: SelectSubset<T, SeasonalPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeasonalPlans and returns the data updated in the database.
     * @param {SeasonalPlanUpdateManyAndReturnArgs} args - Arguments to update many SeasonalPlans.
     * @example
     * // Update many SeasonalPlans
     * const seasonalPlan = await prisma.seasonalPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeasonalPlans and only return the `id`
     * const seasonalPlanWithIdOnly = await prisma.seasonalPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonalPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonalPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeasonalPlan.
     * @param {SeasonalPlanUpsertArgs} args - Arguments to update or create a SeasonalPlan.
     * @example
     * // Update or create a SeasonalPlan
     * const seasonalPlan = await prisma.seasonalPlan.upsert({
     *   create: {
     *     // ... data to create a SeasonalPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeasonalPlan we want to update
     *   }
     * })
     */
    upsert<T extends SeasonalPlanUpsertArgs>(args: SelectSubset<T, SeasonalPlanUpsertArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeasonalPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanCountArgs} args - Arguments to filter SeasonalPlans to count.
     * @example
     * // Count the number of SeasonalPlans
     * const count = await prisma.seasonalPlan.count({
     *   where: {
     *     // ... the filter for the SeasonalPlans we want to count
     *   }
     * })
    **/
    count<T extends SeasonalPlanCountArgs>(
      args?: Subset<T, SeasonalPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonalPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeasonalPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonalPlanAggregateArgs>(args: Subset<T, SeasonalPlanAggregateArgs>): Prisma.PrismaPromise<GetSeasonalPlanAggregateType<T>>

    /**
     * Group by SeasonalPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonalPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonalPlanGroupByArgs['orderBy'] }
        : { orderBy?: SeasonalPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonalPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonalPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeasonalPlan model
   */
  readonly fields: SeasonalPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeasonalPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonalPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    garden<T extends GardenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GardenDefaultArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plantings<T extends SeasonalPlan$plantingsArgs<ExtArgs> = {}>(args?: Subset<T, SeasonalPlan$plantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeasonalPlan model
   */
  interface SeasonalPlanFieldRefs {
    readonly id: FieldRef<"SeasonalPlan", 'Int'>
    readonly gardenId: FieldRef<"SeasonalPlan", 'Int'>
    readonly season: FieldRef<"SeasonalPlan", 'String'>
    readonly year: FieldRef<"SeasonalPlan", 'Int'>
    readonly description: FieldRef<"SeasonalPlan", 'String'>
    readonly createdAt: FieldRef<"SeasonalPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SeasonalPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeasonalPlan findUnique
   */
  export type SeasonalPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalPlan to fetch.
     */
    where: SeasonalPlanWhereUniqueInput
  }

  /**
   * SeasonalPlan findUniqueOrThrow
   */
  export type SeasonalPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalPlan to fetch.
     */
    where: SeasonalPlanWhereUniqueInput
  }

  /**
   * SeasonalPlan findFirst
   */
  export type SeasonalPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalPlan to fetch.
     */
    where?: SeasonalPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPlans to fetch.
     */
    orderBy?: SeasonalPlanOrderByWithRelationInput | SeasonalPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalPlans.
     */
    cursor?: SeasonalPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalPlans.
     */
    distinct?: SeasonalPlanScalarFieldEnum | SeasonalPlanScalarFieldEnum[]
  }

  /**
   * SeasonalPlan findFirstOrThrow
   */
  export type SeasonalPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalPlan to fetch.
     */
    where?: SeasonalPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPlans to fetch.
     */
    orderBy?: SeasonalPlanOrderByWithRelationInput | SeasonalPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalPlans.
     */
    cursor?: SeasonalPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalPlans.
     */
    distinct?: SeasonalPlanScalarFieldEnum | SeasonalPlanScalarFieldEnum[]
  }

  /**
   * SeasonalPlan findMany
   */
  export type SeasonalPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalPlans to fetch.
     */
    where?: SeasonalPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPlans to fetch.
     */
    orderBy?: SeasonalPlanOrderByWithRelationInput | SeasonalPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeasonalPlans.
     */
    cursor?: SeasonalPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPlans.
     */
    skip?: number
    distinct?: SeasonalPlanScalarFieldEnum | SeasonalPlanScalarFieldEnum[]
  }

  /**
   * SeasonalPlan create
   */
  export type SeasonalPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SeasonalPlan.
     */
    data: XOR<SeasonalPlanCreateInput, SeasonalPlanUncheckedCreateInput>
  }

  /**
   * SeasonalPlan createMany
   */
  export type SeasonalPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeasonalPlans.
     */
    data: SeasonalPlanCreateManyInput | SeasonalPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeasonalPlan createManyAndReturn
   */
  export type SeasonalPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SeasonalPlans.
     */
    data: SeasonalPlanCreateManyInput | SeasonalPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeasonalPlan update
   */
  export type SeasonalPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SeasonalPlan.
     */
    data: XOR<SeasonalPlanUpdateInput, SeasonalPlanUncheckedUpdateInput>
    /**
     * Choose, which SeasonalPlan to update.
     */
    where: SeasonalPlanWhereUniqueInput
  }

  /**
   * SeasonalPlan updateMany
   */
  export type SeasonalPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeasonalPlans.
     */
    data: XOR<SeasonalPlanUpdateManyMutationInput, SeasonalPlanUncheckedUpdateManyInput>
    /**
     * Filter which SeasonalPlans to update
     */
    where?: SeasonalPlanWhereInput
    /**
     * Limit how many SeasonalPlans to update.
     */
    limit?: number
  }

  /**
   * SeasonalPlan updateManyAndReturn
   */
  export type SeasonalPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * The data used to update SeasonalPlans.
     */
    data: XOR<SeasonalPlanUpdateManyMutationInput, SeasonalPlanUncheckedUpdateManyInput>
    /**
     * Filter which SeasonalPlans to update
     */
    where?: SeasonalPlanWhereInput
    /**
     * Limit how many SeasonalPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeasonalPlan upsert
   */
  export type SeasonalPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SeasonalPlan to update in case it exists.
     */
    where: SeasonalPlanWhereUniqueInput
    /**
     * In case the SeasonalPlan found by the `where` argument doesn't exist, create a new SeasonalPlan with this data.
     */
    create: XOR<SeasonalPlanCreateInput, SeasonalPlanUncheckedCreateInput>
    /**
     * In case the SeasonalPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonalPlanUpdateInput, SeasonalPlanUncheckedUpdateInput>
  }

  /**
   * SeasonalPlan delete
   */
  export type SeasonalPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
    /**
     * Filter which SeasonalPlan to delete.
     */
    where: SeasonalPlanWhereUniqueInput
  }

  /**
   * SeasonalPlan deleteMany
   */
  export type SeasonalPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalPlans to delete
     */
    where?: SeasonalPlanWhereInput
    /**
     * Limit how many SeasonalPlans to delete.
     */
    limit?: number
  }

  /**
   * SeasonalPlan.plantings
   */
  export type SeasonalPlan$plantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    where?: PlannedPlantingWhereInput
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    cursor?: PlannedPlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * SeasonalPlan without action
   */
  export type SeasonalPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPlan
     */
    select?: SeasonalPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeasonalPlan
     */
    omit?: SeasonalPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonalPlanInclude<ExtArgs> | null
  }


  /**
   * Model PlannedPlanting
   */

  export type AggregatePlannedPlanting = {
    _count: PlannedPlantingCountAggregateOutputType | null
    _avg: PlannedPlantingAvgAggregateOutputType | null
    _sum: PlannedPlantingSumAggregateOutputType | null
    _min: PlannedPlantingMinAggregateOutputType | null
    _max: PlannedPlantingMaxAggregateOutputType | null
  }

  export type PlannedPlantingAvgAggregateOutputType = {
    id: number | null
    planId: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
  }

  export type PlannedPlantingSumAggregateOutputType = {
    id: number | null
    planId: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    quantity: Decimal | null
  }

  export type PlannedPlantingMinAggregateOutputType = {
    id: number | null
    planId: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    plannedDate: Date | null
    quantity: Decimal | null
    notes: string | null
    status: string | null
  }

  export type PlannedPlantingMaxAggregateOutputType = {
    id: number | null
    planId: number | null
    containerId: number | null
    plantId: number | null
    varietyId: number | null
    plannedDate: Date | null
    quantity: Decimal | null
    notes: string | null
    status: string | null
  }

  export type PlannedPlantingCountAggregateOutputType = {
    id: number
    planId: number
    containerId: number
    plantId: number
    varietyId: number
    plannedDate: number
    quantity: number
    notes: number
    status: number
    _all: number
  }


  export type PlannedPlantingAvgAggregateInputType = {
    id?: true
    planId?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
  }

  export type PlannedPlantingSumAggregateInputType = {
    id?: true
    planId?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    quantity?: true
  }

  export type PlannedPlantingMinAggregateInputType = {
    id?: true
    planId?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    plannedDate?: true
    quantity?: true
    notes?: true
    status?: true
  }

  export type PlannedPlantingMaxAggregateInputType = {
    id?: true
    planId?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    plannedDate?: true
    quantity?: true
    notes?: true
    status?: true
  }

  export type PlannedPlantingCountAggregateInputType = {
    id?: true
    planId?: true
    containerId?: true
    plantId?: true
    varietyId?: true
    plannedDate?: true
    quantity?: true
    notes?: true
    status?: true
    _all?: true
  }

  export type PlannedPlantingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannedPlanting to aggregate.
     */
    where?: PlannedPlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannedPlantings to fetch.
     */
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlannedPlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannedPlantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannedPlantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlannedPlantings
    **/
    _count?: true | PlannedPlantingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlannedPlantingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlannedPlantingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlannedPlantingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlannedPlantingMaxAggregateInputType
  }

  export type GetPlannedPlantingAggregateType<T extends PlannedPlantingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlannedPlanting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlannedPlanting[P]>
      : GetScalarType<T[P], AggregatePlannedPlanting[P]>
  }




  export type PlannedPlantingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannedPlantingWhereInput
    orderBy?: PlannedPlantingOrderByWithAggregationInput | PlannedPlantingOrderByWithAggregationInput[]
    by: PlannedPlantingScalarFieldEnum[] | PlannedPlantingScalarFieldEnum
    having?: PlannedPlantingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlannedPlantingCountAggregateInputType | true
    _avg?: PlannedPlantingAvgAggregateInputType
    _sum?: PlannedPlantingSumAggregateInputType
    _min?: PlannedPlantingMinAggregateInputType
    _max?: PlannedPlantingMaxAggregateInputType
  }

  export type PlannedPlantingGroupByOutputType = {
    id: number
    planId: number
    containerId: number
    plantId: number
    varietyId: number | null
    plannedDate: Date | null
    quantity: Decimal | null
    notes: string | null
    status: string
    _count: PlannedPlantingCountAggregateOutputType | null
    _avg: PlannedPlantingAvgAggregateOutputType | null
    _sum: PlannedPlantingSumAggregateOutputType | null
    _min: PlannedPlantingMinAggregateOutputType | null
    _max: PlannedPlantingMaxAggregateOutputType | null
  }

  type GetPlannedPlantingGroupByPayload<T extends PlannedPlantingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlannedPlantingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlannedPlantingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlannedPlantingGroupByOutputType[P]>
            : GetScalarType<T[P], PlannedPlantingGroupByOutputType[P]>
        }
      >
    >


  export type PlannedPlantingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    plannedDate?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }, ExtArgs["result"]["plannedPlanting"]>

  export type PlannedPlantingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    plannedDate?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }, ExtArgs["result"]["plannedPlanting"]>

  export type PlannedPlantingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    plannedDate?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }, ExtArgs["result"]["plannedPlanting"]>

  export type PlannedPlantingSelectScalar = {
    id?: boolean
    planId?: boolean
    containerId?: boolean
    plantId?: boolean
    varietyId?: boolean
    plannedDate?: boolean
    quantity?: boolean
    notes?: boolean
    status?: boolean
  }

  export type PlannedPlantingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "containerId" | "plantId" | "varietyId" | "plannedDate" | "quantity" | "notes" | "status", ExtArgs["result"]["plannedPlanting"]>
  export type PlannedPlantingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }
  export type PlannedPlantingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }
  export type PlannedPlantingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SeasonalPlanDefaultArgs<ExtArgs>
    container?: boolean | ContainerDefaultArgs<ExtArgs>
    plant?: boolean | PlantCatalogDefaultArgs<ExtArgs>
    variety?: boolean | PlannedPlanting$varietyArgs<ExtArgs>
  }

  export type $PlannedPlantingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlannedPlanting"
    objects: {
      plan: Prisma.$SeasonalPlanPayload<ExtArgs>
      container: Prisma.$ContainerPayload<ExtArgs>
      plant: Prisma.$PlantCatalogPayload<ExtArgs>
      variety: Prisma.$PlantVarietyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      planId: number
      containerId: number
      plantId: number
      varietyId: number | null
      plannedDate: Date | null
      quantity: Prisma.Decimal | null
      notes: string | null
      status: string
    }, ExtArgs["result"]["plannedPlanting"]>
    composites: {}
  }

  type PlannedPlantingGetPayload<S extends boolean | null | undefined | PlannedPlantingDefaultArgs> = $Result.GetResult<Prisma.$PlannedPlantingPayload, S>

  type PlannedPlantingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlannedPlantingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlannedPlantingCountAggregateInputType | true
    }

  export interface PlannedPlantingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlannedPlanting'], meta: { name: 'PlannedPlanting' } }
    /**
     * Find zero or one PlannedPlanting that matches the filter.
     * @param {PlannedPlantingFindUniqueArgs} args - Arguments to find a PlannedPlanting
     * @example
     * // Get one PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlannedPlantingFindUniqueArgs>(args: SelectSubset<T, PlannedPlantingFindUniqueArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlannedPlanting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlannedPlantingFindUniqueOrThrowArgs} args - Arguments to find a PlannedPlanting
     * @example
     * // Get one PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlannedPlantingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlannedPlantingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlannedPlanting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingFindFirstArgs} args - Arguments to find a PlannedPlanting
     * @example
     * // Get one PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlannedPlantingFindFirstArgs>(args?: SelectSubset<T, PlannedPlantingFindFirstArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlannedPlanting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingFindFirstOrThrowArgs} args - Arguments to find a PlannedPlanting
     * @example
     * // Get one PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlannedPlantingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlannedPlantingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlannedPlantings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlannedPlantings
     * const plannedPlantings = await prisma.plannedPlanting.findMany()
     * 
     * // Get first 10 PlannedPlantings
     * const plannedPlantings = await prisma.plannedPlanting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plannedPlantingWithIdOnly = await prisma.plannedPlanting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlannedPlantingFindManyArgs>(args?: SelectSubset<T, PlannedPlantingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlannedPlanting.
     * @param {PlannedPlantingCreateArgs} args - Arguments to create a PlannedPlanting.
     * @example
     * // Create one PlannedPlanting
     * const PlannedPlanting = await prisma.plannedPlanting.create({
     *   data: {
     *     // ... data to create a PlannedPlanting
     *   }
     * })
     * 
     */
    create<T extends PlannedPlantingCreateArgs>(args: SelectSubset<T, PlannedPlantingCreateArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlannedPlantings.
     * @param {PlannedPlantingCreateManyArgs} args - Arguments to create many PlannedPlantings.
     * @example
     * // Create many PlannedPlantings
     * const plannedPlanting = await prisma.plannedPlanting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlannedPlantingCreateManyArgs>(args?: SelectSubset<T, PlannedPlantingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlannedPlantings and returns the data saved in the database.
     * @param {PlannedPlantingCreateManyAndReturnArgs} args - Arguments to create many PlannedPlantings.
     * @example
     * // Create many PlannedPlantings
     * const plannedPlanting = await prisma.plannedPlanting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlannedPlantings and only return the `id`
     * const plannedPlantingWithIdOnly = await prisma.plannedPlanting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlannedPlantingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlannedPlantingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlannedPlanting.
     * @param {PlannedPlantingDeleteArgs} args - Arguments to delete one PlannedPlanting.
     * @example
     * // Delete one PlannedPlanting
     * const PlannedPlanting = await prisma.plannedPlanting.delete({
     *   where: {
     *     // ... filter to delete one PlannedPlanting
     *   }
     * })
     * 
     */
    delete<T extends PlannedPlantingDeleteArgs>(args: SelectSubset<T, PlannedPlantingDeleteArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlannedPlanting.
     * @param {PlannedPlantingUpdateArgs} args - Arguments to update one PlannedPlanting.
     * @example
     * // Update one PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlannedPlantingUpdateArgs>(args: SelectSubset<T, PlannedPlantingUpdateArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlannedPlantings.
     * @param {PlannedPlantingDeleteManyArgs} args - Arguments to filter PlannedPlantings to delete.
     * @example
     * // Delete a few PlannedPlantings
     * const { count } = await prisma.plannedPlanting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlannedPlantingDeleteManyArgs>(args?: SelectSubset<T, PlannedPlantingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlannedPlantings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlannedPlantings
     * const plannedPlanting = await prisma.plannedPlanting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlannedPlantingUpdateManyArgs>(args: SelectSubset<T, PlannedPlantingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlannedPlantings and returns the data updated in the database.
     * @param {PlannedPlantingUpdateManyAndReturnArgs} args - Arguments to update many PlannedPlantings.
     * @example
     * // Update many PlannedPlantings
     * const plannedPlanting = await prisma.plannedPlanting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlannedPlantings and only return the `id`
     * const plannedPlantingWithIdOnly = await prisma.plannedPlanting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlannedPlantingUpdateManyAndReturnArgs>(args: SelectSubset<T, PlannedPlantingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlannedPlanting.
     * @param {PlannedPlantingUpsertArgs} args - Arguments to update or create a PlannedPlanting.
     * @example
     * // Update or create a PlannedPlanting
     * const plannedPlanting = await prisma.plannedPlanting.upsert({
     *   create: {
     *     // ... data to create a PlannedPlanting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlannedPlanting we want to update
     *   }
     * })
     */
    upsert<T extends PlannedPlantingUpsertArgs>(args: SelectSubset<T, PlannedPlantingUpsertArgs<ExtArgs>>): Prisma__PlannedPlantingClient<$Result.GetResult<Prisma.$PlannedPlantingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlannedPlantings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingCountArgs} args - Arguments to filter PlannedPlantings to count.
     * @example
     * // Count the number of PlannedPlantings
     * const count = await prisma.plannedPlanting.count({
     *   where: {
     *     // ... the filter for the PlannedPlantings we want to count
     *   }
     * })
    **/
    count<T extends PlannedPlantingCountArgs>(
      args?: Subset<T, PlannedPlantingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlannedPlantingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlannedPlanting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlannedPlantingAggregateArgs>(args: Subset<T, PlannedPlantingAggregateArgs>): Prisma.PrismaPromise<GetPlannedPlantingAggregateType<T>>

    /**
     * Group by PlannedPlanting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannedPlantingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlannedPlantingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlannedPlantingGroupByArgs['orderBy'] }
        : { orderBy?: PlannedPlantingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlannedPlantingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlannedPlantingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlannedPlanting model
   */
  readonly fields: PlannedPlantingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlannedPlanting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlannedPlantingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SeasonalPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonalPlanDefaultArgs<ExtArgs>>): Prisma__SeasonalPlanClient<$Result.GetResult<Prisma.$SeasonalPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    container<T extends ContainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContainerDefaultArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plant<T extends PlantCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantCatalogDefaultArgs<ExtArgs>>): Prisma__PlantCatalogClient<$Result.GetResult<Prisma.$PlantCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variety<T extends PlannedPlanting$varietyArgs<ExtArgs> = {}>(args?: Subset<T, PlannedPlanting$varietyArgs<ExtArgs>>): Prisma__PlantVarietyClient<$Result.GetResult<Prisma.$PlantVarietyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlannedPlanting model
   */
  interface PlannedPlantingFieldRefs {
    readonly id: FieldRef<"PlannedPlanting", 'Int'>
    readonly planId: FieldRef<"PlannedPlanting", 'Int'>
    readonly containerId: FieldRef<"PlannedPlanting", 'Int'>
    readonly plantId: FieldRef<"PlannedPlanting", 'Int'>
    readonly varietyId: FieldRef<"PlannedPlanting", 'Int'>
    readonly plannedDate: FieldRef<"PlannedPlanting", 'DateTime'>
    readonly quantity: FieldRef<"PlannedPlanting", 'Decimal'>
    readonly notes: FieldRef<"PlannedPlanting", 'String'>
    readonly status: FieldRef<"PlannedPlanting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlannedPlanting findUnique
   */
  export type PlannedPlantingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter, which PlannedPlanting to fetch.
     */
    where: PlannedPlantingWhereUniqueInput
  }

  /**
   * PlannedPlanting findUniqueOrThrow
   */
  export type PlannedPlantingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter, which PlannedPlanting to fetch.
     */
    where: PlannedPlantingWhereUniqueInput
  }

  /**
   * PlannedPlanting findFirst
   */
  export type PlannedPlantingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter, which PlannedPlanting to fetch.
     */
    where?: PlannedPlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannedPlantings to fetch.
     */
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannedPlantings.
     */
    cursor?: PlannedPlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannedPlantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannedPlantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannedPlantings.
     */
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * PlannedPlanting findFirstOrThrow
   */
  export type PlannedPlantingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter, which PlannedPlanting to fetch.
     */
    where?: PlannedPlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannedPlantings to fetch.
     */
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannedPlantings.
     */
    cursor?: PlannedPlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannedPlantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannedPlantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannedPlantings.
     */
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * PlannedPlanting findMany
   */
  export type PlannedPlantingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter, which PlannedPlantings to fetch.
     */
    where?: PlannedPlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannedPlantings to fetch.
     */
    orderBy?: PlannedPlantingOrderByWithRelationInput | PlannedPlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlannedPlantings.
     */
    cursor?: PlannedPlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannedPlantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannedPlantings.
     */
    skip?: number
    distinct?: PlannedPlantingScalarFieldEnum | PlannedPlantingScalarFieldEnum[]
  }

  /**
   * PlannedPlanting create
   */
  export type PlannedPlantingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * The data needed to create a PlannedPlanting.
     */
    data: XOR<PlannedPlantingCreateInput, PlannedPlantingUncheckedCreateInput>
  }

  /**
   * PlannedPlanting createMany
   */
  export type PlannedPlantingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlannedPlantings.
     */
    data: PlannedPlantingCreateManyInput | PlannedPlantingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlannedPlanting createManyAndReturn
   */
  export type PlannedPlantingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * The data used to create many PlannedPlantings.
     */
    data: PlannedPlantingCreateManyInput | PlannedPlantingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlannedPlanting update
   */
  export type PlannedPlantingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * The data needed to update a PlannedPlanting.
     */
    data: XOR<PlannedPlantingUpdateInput, PlannedPlantingUncheckedUpdateInput>
    /**
     * Choose, which PlannedPlanting to update.
     */
    where: PlannedPlantingWhereUniqueInput
  }

  /**
   * PlannedPlanting updateMany
   */
  export type PlannedPlantingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlannedPlantings.
     */
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyInput>
    /**
     * Filter which PlannedPlantings to update
     */
    where?: PlannedPlantingWhereInput
    /**
     * Limit how many PlannedPlantings to update.
     */
    limit?: number
  }

  /**
   * PlannedPlanting updateManyAndReturn
   */
  export type PlannedPlantingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * The data used to update PlannedPlantings.
     */
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyInput>
    /**
     * Filter which PlannedPlantings to update
     */
    where?: PlannedPlantingWhereInput
    /**
     * Limit how many PlannedPlantings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlannedPlanting upsert
   */
  export type PlannedPlantingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * The filter to search for the PlannedPlanting to update in case it exists.
     */
    where: PlannedPlantingWhereUniqueInput
    /**
     * In case the PlannedPlanting found by the `where` argument doesn't exist, create a new PlannedPlanting with this data.
     */
    create: XOR<PlannedPlantingCreateInput, PlannedPlantingUncheckedCreateInput>
    /**
     * In case the PlannedPlanting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlannedPlantingUpdateInput, PlannedPlantingUncheckedUpdateInput>
  }

  /**
   * PlannedPlanting delete
   */
  export type PlannedPlantingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
    /**
     * Filter which PlannedPlanting to delete.
     */
    where: PlannedPlantingWhereUniqueInput
  }

  /**
   * PlannedPlanting deleteMany
   */
  export type PlannedPlantingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannedPlantings to delete
     */
    where?: PlannedPlantingWhereInput
    /**
     * Limit how many PlannedPlantings to delete.
     */
    limit?: number
  }

  /**
   * PlannedPlanting.variety
   */
  export type PlannedPlanting$varietyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantVariety
     */
    select?: PlantVarietySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantVariety
     */
    omit?: PlantVarietyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantVarietyInclude<ExtArgs> | null
    where?: PlantVarietyWhereInput
  }

  /**
   * PlannedPlanting without action
   */
  export type PlannedPlantingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannedPlanting
     */
    select?: PlannedPlantingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannedPlanting
     */
    omit?: PlannedPlantingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannedPlantingInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    estimatedMinutes: number | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    parentTaskId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    estimatedMinutes: number | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    parentTaskId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    category: string | null
    priority: string | null
    difficulty: string | null
    estimatedMinutes: number | null
    startDate: Date | null
    endDate: Date | null
    dateCompleted: Date | null
    userId: string | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isRecurring: boolean | null
    parentTaskId: number | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    category: string | null
    priority: string | null
    difficulty: string | null
    estimatedMinutes: number | null
    startDate: Date | null
    endDate: Date | null
    dateCompleted: Date | null
    userId: string | null
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isRecurring: boolean | null
    parentTaskId: number | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    category: number
    priority: number
    difficulty: number
    estimatedMinutes: number
    startDate: number
    endDate: number
    dateCompleted: number
    userId: number
    gardenId: number
    containerId: number
    containerPlantId: number
    createdAt: number
    updatedAt: number
    isRecurring: number
    parentTaskId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    estimatedMinutes?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    parentTaskId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    estimatedMinutes?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    parentTaskId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedMinutes?: true
    startDate?: true
    endDate?: true
    dateCompleted?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    createdAt?: true
    updatedAt?: true
    isRecurring?: true
    parentTaskId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedMinutes?: true
    startDate?: true
    endDate?: true
    dateCompleted?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    createdAt?: true
    updatedAt?: true
    isRecurring?: true
    parentTaskId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedMinutes?: true
    startDate?: true
    endDate?: true
    dateCompleted?: true
    userId?: true
    gardenId?: true
    containerId?: true
    containerPlantId?: true
    createdAt?: true
    updatedAt?: true
    isRecurring?: true
    parentTaskId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    title: string
    description: string
    status: string
    category: string
    priority: string
    difficulty: string
    estimatedMinutes: number | null
    startDate: Date | null
    endDate: Date
    dateCompleted: Date | null
    userId: string
    gardenId: number | null
    containerId: number | null
    containerPlantId: number | null
    createdAt: Date
    updatedAt: Date
    isRecurring: boolean
    parentTaskId: number | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    startDate?: boolean
    endDate?: boolean
    dateCompleted?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRecurring?: boolean
    parentTaskId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    taskNotes?: boolean | Task$taskNotesArgs<ExtArgs>
    taskCompletionLog?: boolean | Task$taskCompletionLogArgs<ExtArgs>
    notifications?: boolean | Task$notificationsArgs<ExtArgs>
    prerequisites?: boolean | Task$prerequisitesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    recurringPattern?: boolean | Task$recurringPatternArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    startDate?: boolean
    endDate?: boolean
    dateCompleted?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRecurring?: boolean
    parentTaskId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    startDate?: boolean
    endDate?: boolean
    dateCompleted?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRecurring?: boolean
    parentTaskId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedMinutes?: boolean
    startDate?: boolean
    endDate?: boolean
    dateCompleted?: boolean
    userId?: boolean
    gardenId?: boolean
    containerId?: boolean
    containerPlantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRecurring?: boolean
    parentTaskId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "category" | "priority" | "difficulty" | "estimatedMinutes" | "startDate" | "endDate" | "dateCompleted" | "userId" | "gardenId" | "containerId" | "containerPlantId" | "createdAt" | "updatedAt" | "isRecurring" | "parentTaskId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    taskNotes?: boolean | Task$taskNotesArgs<ExtArgs>
    taskCompletionLog?: boolean | Task$taskCompletionLogArgs<ExtArgs>
    notifications?: boolean | Task$notificationsArgs<ExtArgs>
    prerequisites?: boolean | Task$prerequisitesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    recurringPattern?: boolean | Task$recurringPatternArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    garden?: boolean | Task$gardenArgs<ExtArgs>
    container?: boolean | Task$containerArgs<ExtArgs>
    containerPlant?: boolean | Task$containerPlantArgs<ExtArgs>
    parentTask?: boolean | Task$parentTaskArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      garden: Prisma.$GardenPayload<ExtArgs> | null
      container: Prisma.$ContainerPayload<ExtArgs> | null
      containerPlant: Prisma.$ContainerPlantPayload<ExtArgs> | null
      parentTask: Prisma.$TaskPayload<ExtArgs> | null
      subtasks: Prisma.$TaskPayload<ExtArgs>[]
      taskNotes: Prisma.$TaskNotePayload<ExtArgs>[]
      taskCompletionLog: Prisma.$TaskCompletionLogPayload<ExtArgs>[]
      notifications: Prisma.$TaskNotificationPayload<ExtArgs>[]
      prerequisites: Prisma.$TaskPrerequisitePayload<ExtArgs>[]
      dependents: Prisma.$TaskPrerequisitePayload<ExtArgs>[]
      recurringPattern: Prisma.$RecurringTaskPatternPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      status: string
      category: string
      priority: string
      difficulty: string
      estimatedMinutes: number | null
      startDate: Date | null
      endDate: Date
      dateCompleted: Date | null
      userId: string
      gardenId: number | null
      containerId: number | null
      containerPlantId: number | null
      createdAt: Date
      updatedAt: Date
      isRecurring: boolean
      parentTaskId: number | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    garden<T extends Task$gardenArgs<ExtArgs> = {}>(args?: Subset<T, Task$gardenArgs<ExtArgs>>): Prisma__GardenClient<$Result.GetResult<Prisma.$GardenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    container<T extends Task$containerArgs<ExtArgs> = {}>(args?: Subset<T, Task$containerArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    containerPlant<T extends Task$containerPlantArgs<ExtArgs> = {}>(args?: Subset<T, Task$containerPlantArgs<ExtArgs>>): Prisma__ContainerPlantClient<$Result.GetResult<Prisma.$ContainerPlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentTask<T extends Task$parentTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$parentTaskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskNotes<T extends Task$taskNotesArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskCompletionLog<T extends Task$taskCompletionLogArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskCompletionLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Task$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Task$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prerequisites<T extends Task$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Task$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dependents<T extends Task$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringPattern<T extends Task$recurringPatternArgs<ExtArgs> = {}>(args?: Subset<T, Task$recurringPatternArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly category: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly difficulty: FieldRef<"Task", 'String'>
    readonly estimatedMinutes: FieldRef<"Task", 'Int'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly endDate: FieldRef<"Task", 'DateTime'>
    readonly dateCompleted: FieldRef<"Task", 'DateTime'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly gardenId: FieldRef<"Task", 'Int'>
    readonly containerId: FieldRef<"Task", 'Int'>
    readonly containerPlantId: FieldRef<"Task", 'Int'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly isRecurring: FieldRef<"Task", 'Boolean'>
    readonly parentTaskId: FieldRef<"Task", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.garden
   */
  export type Task$gardenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Garden
     */
    select?: GardenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Garden
     */
    omit?: GardenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GardenInclude<ExtArgs> | null
    where?: GardenWhereInput
  }

  /**
   * Task.container
   */
  export type Task$containerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Container
     */
    omit?: ContainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerInclude<ExtArgs> | null
    where?: ContainerWhereInput
  }

  /**
   * Task.containerPlant
   */
  export type Task$containerPlantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerPlant
     */
    select?: ContainerPlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContainerPlant
     */
    omit?: ContainerPlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContainerPlantInclude<ExtArgs> | null
    where?: ContainerPlantWhereInput
  }

  /**
   * Task.parentTask
   */
  export type Task$parentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Task.subtasks
   */
  export type Task$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task.taskNotes
   */
  export type Task$taskNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    cursor?: TaskNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * Task.taskCompletionLog
   */
  export type Task$taskCompletionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    where?: TaskCompletionLogWhereInput
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    cursor?: TaskCompletionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCompletionLogScalarFieldEnum | TaskCompletionLogScalarFieldEnum[]
  }

  /**
   * Task.notifications
   */
  export type Task$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    where?: TaskNotificationWhereInput
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    cursor?: TaskNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskNotificationScalarFieldEnum | TaskNotificationScalarFieldEnum[]
  }

  /**
   * Task.prerequisites
   */
  export type Task$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    where?: TaskPrerequisiteWhereInput
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    cursor?: TaskPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskPrerequisiteScalarFieldEnum | TaskPrerequisiteScalarFieldEnum[]
  }

  /**
   * Task.dependents
   */
  export type Task$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    where?: TaskPrerequisiteWhereInput
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    cursor?: TaskPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskPrerequisiteScalarFieldEnum | TaskPrerequisiteScalarFieldEnum[]
  }

  /**
   * Task.recurringPattern
   */
  export type Task$recurringPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    where?: RecurringTaskPatternWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskPrerequisite
   */

  export type AggregateTaskPrerequisite = {
    _count: TaskPrerequisiteCountAggregateOutputType | null
    _avg: TaskPrerequisiteAvgAggregateOutputType | null
    _sum: TaskPrerequisiteSumAggregateOutputType | null
    _min: TaskPrerequisiteMinAggregateOutputType | null
    _max: TaskPrerequisiteMaxAggregateOutputType | null
  }

  export type TaskPrerequisiteAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    prerequisiteTaskId: number | null
  }

  export type TaskPrerequisiteSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    prerequisiteTaskId: number | null
  }

  export type TaskPrerequisiteMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    prerequisiteTaskId: number | null
    createdAt: Date | null
  }

  export type TaskPrerequisiteMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    prerequisiteTaskId: number | null
    createdAt: Date | null
  }

  export type TaskPrerequisiteCountAggregateOutputType = {
    id: number
    taskId: number
    prerequisiteTaskId: number
    createdAt: number
    _all: number
  }


  export type TaskPrerequisiteAvgAggregateInputType = {
    id?: true
    taskId?: true
    prerequisiteTaskId?: true
  }

  export type TaskPrerequisiteSumAggregateInputType = {
    id?: true
    taskId?: true
    prerequisiteTaskId?: true
  }

  export type TaskPrerequisiteMinAggregateInputType = {
    id?: true
    taskId?: true
    prerequisiteTaskId?: true
    createdAt?: true
  }

  export type TaskPrerequisiteMaxAggregateInputType = {
    id?: true
    taskId?: true
    prerequisiteTaskId?: true
    createdAt?: true
  }

  export type TaskPrerequisiteCountAggregateInputType = {
    id?: true
    taskId?: true
    prerequisiteTaskId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskPrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskPrerequisite to aggregate.
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPrerequisites to fetch.
     */
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskPrerequisites
    **/
    _count?: true | TaskPrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskPrerequisiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskPrerequisiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskPrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskPrerequisiteMaxAggregateInputType
  }

  export type GetTaskPrerequisiteAggregateType<T extends TaskPrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskPrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskPrerequisite[P]>
      : GetScalarType<T[P], AggregateTaskPrerequisite[P]>
  }




  export type TaskPrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskPrerequisiteWhereInput
    orderBy?: TaskPrerequisiteOrderByWithAggregationInput | TaskPrerequisiteOrderByWithAggregationInput[]
    by: TaskPrerequisiteScalarFieldEnum[] | TaskPrerequisiteScalarFieldEnum
    having?: TaskPrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskPrerequisiteCountAggregateInputType | true
    _avg?: TaskPrerequisiteAvgAggregateInputType
    _sum?: TaskPrerequisiteSumAggregateInputType
    _min?: TaskPrerequisiteMinAggregateInputType
    _max?: TaskPrerequisiteMaxAggregateInputType
  }

  export type TaskPrerequisiteGroupByOutputType = {
    id: number
    taskId: number
    prerequisiteTaskId: number
    createdAt: Date
    _count: TaskPrerequisiteCountAggregateOutputType | null
    _avg: TaskPrerequisiteAvgAggregateOutputType | null
    _sum: TaskPrerequisiteSumAggregateOutputType | null
    _min: TaskPrerequisiteMinAggregateOutputType | null
    _max: TaskPrerequisiteMaxAggregateOutputType | null
  }

  type GetTaskPrerequisiteGroupByPayload<T extends TaskPrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskPrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskPrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskPrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], TaskPrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type TaskPrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    prerequisiteTaskId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPrerequisite"]>

  export type TaskPrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    prerequisiteTaskId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPrerequisite"]>

  export type TaskPrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    prerequisiteTaskId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskPrerequisite"]>

  export type TaskPrerequisiteSelectScalar = {
    id?: boolean
    taskId?: boolean
    prerequisiteTaskId?: boolean
    createdAt?: boolean
  }

  export type TaskPrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "prerequisiteTaskId" | "createdAt", ExtArgs["result"]["taskPrerequisite"]>
  export type TaskPrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskPrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskPrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    prerequisiteTask?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskPrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskPrerequisite"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      prerequisiteTask: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      prerequisiteTaskId: number
      createdAt: Date
    }, ExtArgs["result"]["taskPrerequisite"]>
    composites: {}
  }

  type TaskPrerequisiteGetPayload<S extends boolean | null | undefined | TaskPrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$TaskPrerequisitePayload, S>

  type TaskPrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskPrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskPrerequisiteCountAggregateInputType | true
    }

  export interface TaskPrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskPrerequisite'], meta: { name: 'TaskPrerequisite' } }
    /**
     * Find zero or one TaskPrerequisite that matches the filter.
     * @param {TaskPrerequisiteFindUniqueArgs} args - Arguments to find a TaskPrerequisite
     * @example
     * // Get one TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskPrerequisiteFindUniqueArgs>(args: SelectSubset<T, TaskPrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskPrerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskPrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a TaskPrerequisite
     * @example
     * // Get one TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskPrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskPrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteFindFirstArgs} args - Arguments to find a TaskPrerequisite
     * @example
     * // Get one TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskPrerequisiteFindFirstArgs>(args?: SelectSubset<T, TaskPrerequisiteFindFirstArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskPrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteFindFirstOrThrowArgs} args - Arguments to find a TaskPrerequisite
     * @example
     * // Get one TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskPrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskPrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskPrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskPrerequisites
     * const taskPrerequisites = await prisma.taskPrerequisite.findMany()
     * 
     * // Get first 10 TaskPrerequisites
     * const taskPrerequisites = await prisma.taskPrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskPrerequisiteWithIdOnly = await prisma.taskPrerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskPrerequisiteFindManyArgs>(args?: SelectSubset<T, TaskPrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskPrerequisite.
     * @param {TaskPrerequisiteCreateArgs} args - Arguments to create a TaskPrerequisite.
     * @example
     * // Create one TaskPrerequisite
     * const TaskPrerequisite = await prisma.taskPrerequisite.create({
     *   data: {
     *     // ... data to create a TaskPrerequisite
     *   }
     * })
     * 
     */
    create<T extends TaskPrerequisiteCreateArgs>(args: SelectSubset<T, TaskPrerequisiteCreateArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskPrerequisites.
     * @param {TaskPrerequisiteCreateManyArgs} args - Arguments to create many TaskPrerequisites.
     * @example
     * // Create many TaskPrerequisites
     * const taskPrerequisite = await prisma.taskPrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskPrerequisiteCreateManyArgs>(args?: SelectSubset<T, TaskPrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskPrerequisites and returns the data saved in the database.
     * @param {TaskPrerequisiteCreateManyAndReturnArgs} args - Arguments to create many TaskPrerequisites.
     * @example
     * // Create many TaskPrerequisites
     * const taskPrerequisite = await prisma.taskPrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskPrerequisites and only return the `id`
     * const taskPrerequisiteWithIdOnly = await prisma.taskPrerequisite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskPrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskPrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskPrerequisite.
     * @param {TaskPrerequisiteDeleteArgs} args - Arguments to delete one TaskPrerequisite.
     * @example
     * // Delete one TaskPrerequisite
     * const TaskPrerequisite = await prisma.taskPrerequisite.delete({
     *   where: {
     *     // ... filter to delete one TaskPrerequisite
     *   }
     * })
     * 
     */
    delete<T extends TaskPrerequisiteDeleteArgs>(args: SelectSubset<T, TaskPrerequisiteDeleteArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskPrerequisite.
     * @param {TaskPrerequisiteUpdateArgs} args - Arguments to update one TaskPrerequisite.
     * @example
     * // Update one TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskPrerequisiteUpdateArgs>(args: SelectSubset<T, TaskPrerequisiteUpdateArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskPrerequisites.
     * @param {TaskPrerequisiteDeleteManyArgs} args - Arguments to filter TaskPrerequisites to delete.
     * @example
     * // Delete a few TaskPrerequisites
     * const { count } = await prisma.taskPrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskPrerequisiteDeleteManyArgs>(args?: SelectSubset<T, TaskPrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskPrerequisites
     * const taskPrerequisite = await prisma.taskPrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskPrerequisiteUpdateManyArgs>(args: SelectSubset<T, TaskPrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskPrerequisites and returns the data updated in the database.
     * @param {TaskPrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many TaskPrerequisites.
     * @example
     * // Update many TaskPrerequisites
     * const taskPrerequisite = await prisma.taskPrerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskPrerequisites and only return the `id`
     * const taskPrerequisiteWithIdOnly = await prisma.taskPrerequisite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskPrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskPrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskPrerequisite.
     * @param {TaskPrerequisiteUpsertArgs} args - Arguments to update or create a TaskPrerequisite.
     * @example
     * // Update or create a TaskPrerequisite
     * const taskPrerequisite = await prisma.taskPrerequisite.upsert({
     *   create: {
     *     // ... data to create a TaskPrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskPrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends TaskPrerequisiteUpsertArgs>(args: SelectSubset<T, TaskPrerequisiteUpsertArgs<ExtArgs>>): Prisma__TaskPrerequisiteClient<$Result.GetResult<Prisma.$TaskPrerequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteCountArgs} args - Arguments to filter TaskPrerequisites to count.
     * @example
     * // Count the number of TaskPrerequisites
     * const count = await prisma.taskPrerequisite.count({
     *   where: {
     *     // ... the filter for the TaskPrerequisites we want to count
     *   }
     * })
    **/
    count<T extends TaskPrerequisiteCountArgs>(
      args?: Subset<T, TaskPrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskPrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskPrerequisiteAggregateArgs>(args: Subset<T, TaskPrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetTaskPrerequisiteAggregateType<T>>

    /**
     * Group by TaskPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskPrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskPrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskPrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: TaskPrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskPrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskPrerequisite model
   */
  readonly fields: TaskPrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskPrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskPrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prerequisiteTask<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskPrerequisite model
   */
  interface TaskPrerequisiteFieldRefs {
    readonly id: FieldRef<"TaskPrerequisite", 'Int'>
    readonly taskId: FieldRef<"TaskPrerequisite", 'Int'>
    readonly prerequisiteTaskId: FieldRef<"TaskPrerequisite", 'Int'>
    readonly createdAt: FieldRef<"TaskPrerequisite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskPrerequisite findUnique
   */
  export type TaskPrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which TaskPrerequisite to fetch.
     */
    where: TaskPrerequisiteWhereUniqueInput
  }

  /**
   * TaskPrerequisite findUniqueOrThrow
   */
  export type TaskPrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which TaskPrerequisite to fetch.
     */
    where: TaskPrerequisiteWhereUniqueInput
  }

  /**
   * TaskPrerequisite findFirst
   */
  export type TaskPrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which TaskPrerequisite to fetch.
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPrerequisites to fetch.
     */
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskPrerequisites.
     */
    cursor?: TaskPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskPrerequisites.
     */
    distinct?: TaskPrerequisiteScalarFieldEnum | TaskPrerequisiteScalarFieldEnum[]
  }

  /**
   * TaskPrerequisite findFirstOrThrow
   */
  export type TaskPrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which TaskPrerequisite to fetch.
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPrerequisites to fetch.
     */
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskPrerequisites.
     */
    cursor?: TaskPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskPrerequisites.
     */
    distinct?: TaskPrerequisiteScalarFieldEnum | TaskPrerequisiteScalarFieldEnum[]
  }

  /**
   * TaskPrerequisite findMany
   */
  export type TaskPrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which TaskPrerequisites to fetch.
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskPrerequisites to fetch.
     */
    orderBy?: TaskPrerequisiteOrderByWithRelationInput | TaskPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskPrerequisites.
     */
    cursor?: TaskPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskPrerequisites.
     */
    skip?: number
    distinct?: TaskPrerequisiteScalarFieldEnum | TaskPrerequisiteScalarFieldEnum[]
  }

  /**
   * TaskPrerequisite create
   */
  export type TaskPrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskPrerequisite.
     */
    data: XOR<TaskPrerequisiteCreateInput, TaskPrerequisiteUncheckedCreateInput>
  }

  /**
   * TaskPrerequisite createMany
   */
  export type TaskPrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskPrerequisites.
     */
    data: TaskPrerequisiteCreateManyInput | TaskPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskPrerequisite createManyAndReturn
   */
  export type TaskPrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many TaskPrerequisites.
     */
    data: TaskPrerequisiteCreateManyInput | TaskPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskPrerequisite update
   */
  export type TaskPrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskPrerequisite.
     */
    data: XOR<TaskPrerequisiteUpdateInput, TaskPrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which TaskPrerequisite to update.
     */
    where: TaskPrerequisiteWhereUniqueInput
  }

  /**
   * TaskPrerequisite updateMany
   */
  export type TaskPrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskPrerequisites.
     */
    data: XOR<TaskPrerequisiteUpdateManyMutationInput, TaskPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which TaskPrerequisites to update
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * Limit how many TaskPrerequisites to update.
     */
    limit?: number
  }

  /**
   * TaskPrerequisite updateManyAndReturn
   */
  export type TaskPrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update TaskPrerequisites.
     */
    data: XOR<TaskPrerequisiteUpdateManyMutationInput, TaskPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which TaskPrerequisites to update
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * Limit how many TaskPrerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskPrerequisite upsert
   */
  export type TaskPrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskPrerequisite to update in case it exists.
     */
    where: TaskPrerequisiteWhereUniqueInput
    /**
     * In case the TaskPrerequisite found by the `where` argument doesn't exist, create a new TaskPrerequisite with this data.
     */
    create: XOR<TaskPrerequisiteCreateInput, TaskPrerequisiteUncheckedCreateInput>
    /**
     * In case the TaskPrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskPrerequisiteUpdateInput, TaskPrerequisiteUncheckedUpdateInput>
  }

  /**
   * TaskPrerequisite delete
   */
  export type TaskPrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which TaskPrerequisite to delete.
     */
    where: TaskPrerequisiteWhereUniqueInput
  }

  /**
   * TaskPrerequisite deleteMany
   */
  export type TaskPrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskPrerequisites to delete
     */
    where?: TaskPrerequisiteWhereInput
    /**
     * Limit how many TaskPrerequisites to delete.
     */
    limit?: number
  }

  /**
   * TaskPrerequisite without action
   */
  export type TaskPrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskPrerequisite
     */
    select?: TaskPrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskPrerequisite
     */
    omit?: TaskPrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskPrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model TaskNote
   */

  export type AggregateTaskNote = {
    _count: TaskNoteCountAggregateOutputType | null
    _avg: TaskNoteAvgAggregateOutputType | null
    _sum: TaskNoteSumAggregateOutputType | null
    _min: TaskNoteMinAggregateOutputType | null
    _max: TaskNoteMaxAggregateOutputType | null
  }

  export type TaskNoteAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskNoteSumAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskNoteMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskNoteMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskNoteCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskNoteAvgAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskNoteSumAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskNoteMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskNoteMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskNoteCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNote to aggregate.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskNotes
    **/
    _count?: true | TaskNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskNoteMaxAggregateInputType
  }

  export type GetTaskNoteAggregateType<T extends TaskNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskNote[P]>
      : GetScalarType<T[P], AggregateTaskNote[P]>
  }




  export type TaskNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNoteWhereInput
    orderBy?: TaskNoteOrderByWithAggregationInput | TaskNoteOrderByWithAggregationInput[]
    by: TaskNoteScalarFieldEnum[] | TaskNoteScalarFieldEnum
    having?: TaskNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskNoteCountAggregateInputType | true
    _avg?: TaskNoteAvgAggregateInputType
    _sum?: TaskNoteSumAggregateInputType
    _min?: TaskNoteMinAggregateInputType
    _max?: TaskNoteMaxAggregateInputType
  }

  export type TaskNoteGroupByOutputType = {
    id: number
    taskId: number
    userId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: TaskNoteCountAggregateOutputType | null
    _avg: TaskNoteAvgAggregateOutputType | null
    _sum: TaskNoteSumAggregateOutputType | null
    _min: TaskNoteMinAggregateOutputType | null
    _max: TaskNoteMaxAggregateOutputType | null
  }

  type GetTaskNoteGroupByPayload<T extends TaskNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskNoteGroupByOutputType[P]>
            : GetScalarType<T[P], TaskNoteGroupByOutputType[P]>
        }
      >
    >


  export type TaskNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNote"]>

  export type TaskNoteSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["taskNote"]>
  export type TaskNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskNote"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskNote"]>
    composites: {}
  }

  type TaskNoteGetPayload<S extends boolean | null | undefined | TaskNoteDefaultArgs> = $Result.GetResult<Prisma.$TaskNotePayload, S>

  type TaskNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskNoteCountAggregateInputType | true
    }

  export interface TaskNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskNote'], meta: { name: 'TaskNote' } }
    /**
     * Find zero or one TaskNote that matches the filter.
     * @param {TaskNoteFindUniqueArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskNoteFindUniqueArgs>(args: SelectSubset<T, TaskNoteFindUniqueArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskNoteFindUniqueOrThrowArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindFirstArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskNoteFindFirstArgs>(args?: SelectSubset<T, TaskNoteFindFirstArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindFirstOrThrowArgs} args - Arguments to find a TaskNote
     * @example
     * // Get one TaskNote
     * const taskNote = await prisma.taskNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskNotes
     * const taskNotes = await prisma.taskNote.findMany()
     * 
     * // Get first 10 TaskNotes
     * const taskNotes = await prisma.taskNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskNoteFindManyArgs>(args?: SelectSubset<T, TaskNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskNote.
     * @param {TaskNoteCreateArgs} args - Arguments to create a TaskNote.
     * @example
     * // Create one TaskNote
     * const TaskNote = await prisma.taskNote.create({
     *   data: {
     *     // ... data to create a TaskNote
     *   }
     * })
     * 
     */
    create<T extends TaskNoteCreateArgs>(args: SelectSubset<T, TaskNoteCreateArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskNotes.
     * @param {TaskNoteCreateManyArgs} args - Arguments to create many TaskNotes.
     * @example
     * // Create many TaskNotes
     * const taskNote = await prisma.taskNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskNoteCreateManyArgs>(args?: SelectSubset<T, TaskNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskNotes and returns the data saved in the database.
     * @param {TaskNoteCreateManyAndReturnArgs} args - Arguments to create many TaskNotes.
     * @example
     * // Create many TaskNotes
     * const taskNote = await prisma.taskNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskNotes and only return the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskNote.
     * @param {TaskNoteDeleteArgs} args - Arguments to delete one TaskNote.
     * @example
     * // Delete one TaskNote
     * const TaskNote = await prisma.taskNote.delete({
     *   where: {
     *     // ... filter to delete one TaskNote
     *   }
     * })
     * 
     */
    delete<T extends TaskNoteDeleteArgs>(args: SelectSubset<T, TaskNoteDeleteArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskNote.
     * @param {TaskNoteUpdateArgs} args - Arguments to update one TaskNote.
     * @example
     * // Update one TaskNote
     * const taskNote = await prisma.taskNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskNoteUpdateArgs>(args: SelectSubset<T, TaskNoteUpdateArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskNotes.
     * @param {TaskNoteDeleteManyArgs} args - Arguments to filter TaskNotes to delete.
     * @example
     * // Delete a few TaskNotes
     * const { count } = await prisma.taskNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskNoteDeleteManyArgs>(args?: SelectSubset<T, TaskNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskNotes
     * const taskNote = await prisma.taskNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskNoteUpdateManyArgs>(args: SelectSubset<T, TaskNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotes and returns the data updated in the database.
     * @param {TaskNoteUpdateManyAndReturnArgs} args - Arguments to update many TaskNotes.
     * @example
     * // Update many TaskNotes
     * const taskNote = await prisma.taskNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskNotes and only return the `id`
     * const taskNoteWithIdOnly = await prisma.taskNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskNote.
     * @param {TaskNoteUpsertArgs} args - Arguments to update or create a TaskNote.
     * @example
     * // Update or create a TaskNote
     * const taskNote = await prisma.taskNote.upsert({
     *   create: {
     *     // ... data to create a TaskNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskNote we want to update
     *   }
     * })
     */
    upsert<T extends TaskNoteUpsertArgs>(args: SelectSubset<T, TaskNoteUpsertArgs<ExtArgs>>): Prisma__TaskNoteClient<$Result.GetResult<Prisma.$TaskNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteCountArgs} args - Arguments to filter TaskNotes to count.
     * @example
     * // Count the number of TaskNotes
     * const count = await prisma.taskNote.count({
     *   where: {
     *     // ... the filter for the TaskNotes we want to count
     *   }
     * })
    **/
    count<T extends TaskNoteCountArgs>(
      args?: Subset<T, TaskNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskNoteAggregateArgs>(args: Subset<T, TaskNoteAggregateArgs>): Prisma.PrismaPromise<GetTaskNoteAggregateType<T>>

    /**
     * Group by TaskNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskNoteGroupByArgs['orderBy'] }
        : { orderBy?: TaskNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskNote model
   */
  readonly fields: TaskNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskNote model
   */
  interface TaskNoteFieldRefs {
    readonly id: FieldRef<"TaskNote", 'Int'>
    readonly taskId: FieldRef<"TaskNote", 'Int'>
    readonly userId: FieldRef<"TaskNote", 'String'>
    readonly content: FieldRef<"TaskNote", 'String'>
    readonly createdAt: FieldRef<"TaskNote", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskNote findUnique
   */
  export type TaskNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote findUniqueOrThrow
   */
  export type TaskNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote findFirst
   */
  export type TaskNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotes.
     */
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote findFirstOrThrow
   */
  export type TaskNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNote to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotes.
     */
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote findMany
   */
  export type TaskNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotes to fetch.
     */
    where?: TaskNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotes to fetch.
     */
    orderBy?: TaskNoteOrderByWithRelationInput | TaskNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskNotes.
     */
    cursor?: TaskNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotes.
     */
    skip?: number
    distinct?: TaskNoteScalarFieldEnum | TaskNoteScalarFieldEnum[]
  }

  /**
   * TaskNote create
   */
  export type TaskNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskNote.
     */
    data: XOR<TaskNoteCreateInput, TaskNoteUncheckedCreateInput>
  }

  /**
   * TaskNote createMany
   */
  export type TaskNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskNotes.
     */
    data: TaskNoteCreateManyInput | TaskNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskNote createManyAndReturn
   */
  export type TaskNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * The data used to create many TaskNotes.
     */
    data: TaskNoteCreateManyInput | TaskNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNote update
   */
  export type TaskNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskNote.
     */
    data: XOR<TaskNoteUpdateInput, TaskNoteUncheckedUpdateInput>
    /**
     * Choose, which TaskNote to update.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote updateMany
   */
  export type TaskNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskNotes.
     */
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotes to update
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to update.
     */
    limit?: number
  }

  /**
   * TaskNote updateManyAndReturn
   */
  export type TaskNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * The data used to update TaskNotes.
     */
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotes to update
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNote upsert
   */
  export type TaskNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskNote to update in case it exists.
     */
    where: TaskNoteWhereUniqueInput
    /**
     * In case the TaskNote found by the `where` argument doesn't exist, create a new TaskNote with this data.
     */
    create: XOR<TaskNoteCreateInput, TaskNoteUncheckedCreateInput>
    /**
     * In case the TaskNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskNoteUpdateInput, TaskNoteUncheckedUpdateInput>
  }

  /**
   * TaskNote delete
   */
  export type TaskNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
    /**
     * Filter which TaskNote to delete.
     */
    where: TaskNoteWhereUniqueInput
  }

  /**
   * TaskNote deleteMany
   */
  export type TaskNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNotes to delete
     */
    where?: TaskNoteWhereInput
    /**
     * Limit how many TaskNotes to delete.
     */
    limit?: number
  }

  /**
   * TaskNote without action
   */
  export type TaskNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNote
     */
    select?: TaskNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNote
     */
    omit?: TaskNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNoteInclude<ExtArgs> | null
  }


  /**
   * Model TaskCompletionLog
   */

  export type AggregateTaskCompletionLog = {
    _count: TaskCompletionLogCountAggregateOutputType | null
    _avg: TaskCompletionLogAvgAggregateOutputType | null
    _sum: TaskCompletionLogSumAggregateOutputType | null
    _min: TaskCompletionLogMinAggregateOutputType | null
    _max: TaskCompletionLogMaxAggregateOutputType | null
  }

  export type TaskCompletionLogAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    percentDone: number | null
    timeSpentMinutes: number | null
  }

  export type TaskCompletionLogSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    percentDone: number | null
    timeSpentMinutes: number | null
  }

  export type TaskCompletionLogMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    status: string | null
    completedAt: Date | null
    notes: string | null
    percentDone: number | null
    timeSpentMinutes: number | null
  }

  export type TaskCompletionLogMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    status: string | null
    completedAt: Date | null
    notes: string | null
    percentDone: number | null
    timeSpentMinutes: number | null
  }

  export type TaskCompletionLogCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    status: number
    completedAt: number
    notes: number
    percentDone: number
    timeSpentMinutes: number
    _all: number
  }


  export type TaskCompletionLogAvgAggregateInputType = {
    id?: true
    taskId?: true
    percentDone?: true
    timeSpentMinutes?: true
  }

  export type TaskCompletionLogSumAggregateInputType = {
    id?: true
    taskId?: true
    percentDone?: true
    timeSpentMinutes?: true
  }

  export type TaskCompletionLogMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    status?: true
    completedAt?: true
    notes?: true
    percentDone?: true
    timeSpentMinutes?: true
  }

  export type TaskCompletionLogMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    status?: true
    completedAt?: true
    notes?: true
    percentDone?: true
    timeSpentMinutes?: true
  }

  export type TaskCompletionLogCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    status?: true
    completedAt?: true
    notes?: true
    percentDone?: true
    timeSpentMinutes?: true
    _all?: true
  }

  export type TaskCompletionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCompletionLog to aggregate.
     */
    where?: TaskCompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletionLogs to fetch.
     */
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCompletionLogs
    **/
    _count?: true | TaskCompletionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskCompletionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskCompletionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCompletionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCompletionLogMaxAggregateInputType
  }

  export type GetTaskCompletionLogAggregateType<T extends TaskCompletionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCompletionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCompletionLog[P]>
      : GetScalarType<T[P], AggregateTaskCompletionLog[P]>
  }




  export type TaskCompletionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionLogWhereInput
    orderBy?: TaskCompletionLogOrderByWithAggregationInput | TaskCompletionLogOrderByWithAggregationInput[]
    by: TaskCompletionLogScalarFieldEnum[] | TaskCompletionLogScalarFieldEnum
    having?: TaskCompletionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCompletionLogCountAggregateInputType | true
    _avg?: TaskCompletionLogAvgAggregateInputType
    _sum?: TaskCompletionLogSumAggregateInputType
    _min?: TaskCompletionLogMinAggregateInputType
    _max?: TaskCompletionLogMaxAggregateInputType
  }

  export type TaskCompletionLogGroupByOutputType = {
    id: number
    taskId: number
    userId: string
    status: string
    completedAt: Date
    notes: string | null
    percentDone: number | null
    timeSpentMinutes: number | null
    _count: TaskCompletionLogCountAggregateOutputType | null
    _avg: TaskCompletionLogAvgAggregateOutputType | null
    _sum: TaskCompletionLogSumAggregateOutputType | null
    _min: TaskCompletionLogMinAggregateOutputType | null
    _max: TaskCompletionLogMaxAggregateOutputType | null
  }

  type GetTaskCompletionLogGroupByPayload<T extends TaskCompletionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCompletionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCompletionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCompletionLogGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCompletionLogGroupByOutputType[P]>
        }
      >
    >


  export type TaskCompletionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    status?: boolean
    completedAt?: boolean
    notes?: boolean
    percentDone?: boolean
    timeSpentMinutes?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletionLog"]>

  export type TaskCompletionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    status?: boolean
    completedAt?: boolean
    notes?: boolean
    percentDone?: boolean
    timeSpentMinutes?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletionLog"]>

  export type TaskCompletionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    status?: boolean
    completedAt?: boolean
    notes?: boolean
    percentDone?: boolean
    timeSpentMinutes?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletionLog"]>

  export type TaskCompletionLogSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    status?: boolean
    completedAt?: boolean
    notes?: boolean
    percentDone?: boolean
    timeSpentMinutes?: boolean
  }

  export type TaskCompletionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "status" | "completedAt" | "notes" | "percentDone" | "timeSpentMinutes", ExtArgs["result"]["taskCompletionLog"]>
  export type TaskCompletionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskCompletionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskCompletionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskCompletionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCompletionLog"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: string
      status: string
      completedAt: Date
      notes: string | null
      percentDone: number | null
      timeSpentMinutes: number | null
    }, ExtArgs["result"]["taskCompletionLog"]>
    composites: {}
  }

  type TaskCompletionLogGetPayload<S extends boolean | null | undefined | TaskCompletionLogDefaultArgs> = $Result.GetResult<Prisma.$TaskCompletionLogPayload, S>

  type TaskCompletionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCompletionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCompletionLogCountAggregateInputType | true
    }

  export interface TaskCompletionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCompletionLog'], meta: { name: 'TaskCompletionLog' } }
    /**
     * Find zero or one TaskCompletionLog that matches the filter.
     * @param {TaskCompletionLogFindUniqueArgs} args - Arguments to find a TaskCompletionLog
     * @example
     * // Get one TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCompletionLogFindUniqueArgs>(args: SelectSubset<T, TaskCompletionLogFindUniqueArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskCompletionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCompletionLogFindUniqueOrThrowArgs} args - Arguments to find a TaskCompletionLog
     * @example
     * // Get one TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCompletionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCompletionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCompletionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogFindFirstArgs} args - Arguments to find a TaskCompletionLog
     * @example
     * // Get one TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCompletionLogFindFirstArgs>(args?: SelectSubset<T, TaskCompletionLogFindFirstArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCompletionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogFindFirstOrThrowArgs} args - Arguments to find a TaskCompletionLog
     * @example
     * // Get one TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCompletionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCompletionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskCompletionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCompletionLogs
     * const taskCompletionLogs = await prisma.taskCompletionLog.findMany()
     * 
     * // Get first 10 TaskCompletionLogs
     * const taskCompletionLogs = await prisma.taskCompletionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCompletionLogWithIdOnly = await prisma.taskCompletionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCompletionLogFindManyArgs>(args?: SelectSubset<T, TaskCompletionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskCompletionLog.
     * @param {TaskCompletionLogCreateArgs} args - Arguments to create a TaskCompletionLog.
     * @example
     * // Create one TaskCompletionLog
     * const TaskCompletionLog = await prisma.taskCompletionLog.create({
     *   data: {
     *     // ... data to create a TaskCompletionLog
     *   }
     * })
     * 
     */
    create<T extends TaskCompletionLogCreateArgs>(args: SelectSubset<T, TaskCompletionLogCreateArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskCompletionLogs.
     * @param {TaskCompletionLogCreateManyArgs} args - Arguments to create many TaskCompletionLogs.
     * @example
     * // Create many TaskCompletionLogs
     * const taskCompletionLog = await prisma.taskCompletionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCompletionLogCreateManyArgs>(args?: SelectSubset<T, TaskCompletionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskCompletionLogs and returns the data saved in the database.
     * @param {TaskCompletionLogCreateManyAndReturnArgs} args - Arguments to create many TaskCompletionLogs.
     * @example
     * // Create many TaskCompletionLogs
     * const taskCompletionLog = await prisma.taskCompletionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskCompletionLogs and only return the `id`
     * const taskCompletionLogWithIdOnly = await prisma.taskCompletionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCompletionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCompletionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskCompletionLog.
     * @param {TaskCompletionLogDeleteArgs} args - Arguments to delete one TaskCompletionLog.
     * @example
     * // Delete one TaskCompletionLog
     * const TaskCompletionLog = await prisma.taskCompletionLog.delete({
     *   where: {
     *     // ... filter to delete one TaskCompletionLog
     *   }
     * })
     * 
     */
    delete<T extends TaskCompletionLogDeleteArgs>(args: SelectSubset<T, TaskCompletionLogDeleteArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskCompletionLog.
     * @param {TaskCompletionLogUpdateArgs} args - Arguments to update one TaskCompletionLog.
     * @example
     * // Update one TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCompletionLogUpdateArgs>(args: SelectSubset<T, TaskCompletionLogUpdateArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskCompletionLogs.
     * @param {TaskCompletionLogDeleteManyArgs} args - Arguments to filter TaskCompletionLogs to delete.
     * @example
     * // Delete a few TaskCompletionLogs
     * const { count } = await prisma.taskCompletionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCompletionLogDeleteManyArgs>(args?: SelectSubset<T, TaskCompletionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCompletionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCompletionLogs
     * const taskCompletionLog = await prisma.taskCompletionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCompletionLogUpdateManyArgs>(args: SelectSubset<T, TaskCompletionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCompletionLogs and returns the data updated in the database.
     * @param {TaskCompletionLogUpdateManyAndReturnArgs} args - Arguments to update many TaskCompletionLogs.
     * @example
     * // Update many TaskCompletionLogs
     * const taskCompletionLog = await prisma.taskCompletionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskCompletionLogs and only return the `id`
     * const taskCompletionLogWithIdOnly = await prisma.taskCompletionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCompletionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCompletionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskCompletionLog.
     * @param {TaskCompletionLogUpsertArgs} args - Arguments to update or create a TaskCompletionLog.
     * @example
     * // Update or create a TaskCompletionLog
     * const taskCompletionLog = await prisma.taskCompletionLog.upsert({
     *   create: {
     *     // ... data to create a TaskCompletionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCompletionLog we want to update
     *   }
     * })
     */
    upsert<T extends TaskCompletionLogUpsertArgs>(args: SelectSubset<T, TaskCompletionLogUpsertArgs<ExtArgs>>): Prisma__TaskCompletionLogClient<$Result.GetResult<Prisma.$TaskCompletionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskCompletionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogCountArgs} args - Arguments to filter TaskCompletionLogs to count.
     * @example
     * // Count the number of TaskCompletionLogs
     * const count = await prisma.taskCompletionLog.count({
     *   where: {
     *     // ... the filter for the TaskCompletionLogs we want to count
     *   }
     * })
    **/
    count<T extends TaskCompletionLogCountArgs>(
      args?: Subset<T, TaskCompletionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCompletionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCompletionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCompletionLogAggregateArgs>(args: Subset<T, TaskCompletionLogAggregateArgs>): Prisma.PrismaPromise<GetTaskCompletionLogAggregateType<T>>

    /**
     * Group by TaskCompletionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCompletionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCompletionLogGroupByArgs['orderBy'] }
        : { orderBy?: TaskCompletionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCompletionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCompletionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCompletionLog model
   */
  readonly fields: TaskCompletionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCompletionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCompletionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCompletionLog model
   */
  interface TaskCompletionLogFieldRefs {
    readonly id: FieldRef<"TaskCompletionLog", 'Int'>
    readonly taskId: FieldRef<"TaskCompletionLog", 'Int'>
    readonly userId: FieldRef<"TaskCompletionLog", 'String'>
    readonly status: FieldRef<"TaskCompletionLog", 'String'>
    readonly completedAt: FieldRef<"TaskCompletionLog", 'DateTime'>
    readonly notes: FieldRef<"TaskCompletionLog", 'String'>
    readonly percentDone: FieldRef<"TaskCompletionLog", 'Int'>
    readonly timeSpentMinutes: FieldRef<"TaskCompletionLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TaskCompletionLog findUnique
   */
  export type TaskCompletionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletionLog to fetch.
     */
    where: TaskCompletionLogWhereUniqueInput
  }

  /**
   * TaskCompletionLog findUniqueOrThrow
   */
  export type TaskCompletionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletionLog to fetch.
     */
    where: TaskCompletionLogWhereUniqueInput
  }

  /**
   * TaskCompletionLog findFirst
   */
  export type TaskCompletionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletionLog to fetch.
     */
    where?: TaskCompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletionLogs to fetch.
     */
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCompletionLogs.
     */
    cursor?: TaskCompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCompletionLogs.
     */
    distinct?: TaskCompletionLogScalarFieldEnum | TaskCompletionLogScalarFieldEnum[]
  }

  /**
   * TaskCompletionLog findFirstOrThrow
   */
  export type TaskCompletionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletionLog to fetch.
     */
    where?: TaskCompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletionLogs to fetch.
     */
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCompletionLogs.
     */
    cursor?: TaskCompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCompletionLogs.
     */
    distinct?: TaskCompletionLogScalarFieldEnum | TaskCompletionLogScalarFieldEnum[]
  }

  /**
   * TaskCompletionLog findMany
   */
  export type TaskCompletionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletionLogs to fetch.
     */
    where?: TaskCompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletionLogs to fetch.
     */
    orderBy?: TaskCompletionLogOrderByWithRelationInput | TaskCompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCompletionLogs.
     */
    cursor?: TaskCompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletionLogs.
     */
    skip?: number
    distinct?: TaskCompletionLogScalarFieldEnum | TaskCompletionLogScalarFieldEnum[]
  }

  /**
   * TaskCompletionLog create
   */
  export type TaskCompletionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCompletionLog.
     */
    data: XOR<TaskCompletionLogCreateInput, TaskCompletionLogUncheckedCreateInput>
  }

  /**
   * TaskCompletionLog createMany
   */
  export type TaskCompletionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCompletionLogs.
     */
    data: TaskCompletionLogCreateManyInput | TaskCompletionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCompletionLog createManyAndReturn
   */
  export type TaskCompletionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * The data used to create many TaskCompletionLogs.
     */
    data: TaskCompletionLogCreateManyInput | TaskCompletionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCompletionLog update
   */
  export type TaskCompletionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCompletionLog.
     */
    data: XOR<TaskCompletionLogUpdateInput, TaskCompletionLogUncheckedUpdateInput>
    /**
     * Choose, which TaskCompletionLog to update.
     */
    where: TaskCompletionLogWhereUniqueInput
  }

  /**
   * TaskCompletionLog updateMany
   */
  export type TaskCompletionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCompletionLogs.
     */
    data: XOR<TaskCompletionLogUpdateManyMutationInput, TaskCompletionLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskCompletionLogs to update
     */
    where?: TaskCompletionLogWhereInput
    /**
     * Limit how many TaskCompletionLogs to update.
     */
    limit?: number
  }

  /**
   * TaskCompletionLog updateManyAndReturn
   */
  export type TaskCompletionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * The data used to update TaskCompletionLogs.
     */
    data: XOR<TaskCompletionLogUpdateManyMutationInput, TaskCompletionLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskCompletionLogs to update
     */
    where?: TaskCompletionLogWhereInput
    /**
     * Limit how many TaskCompletionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCompletionLog upsert
   */
  export type TaskCompletionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCompletionLog to update in case it exists.
     */
    where: TaskCompletionLogWhereUniqueInput
    /**
     * In case the TaskCompletionLog found by the `where` argument doesn't exist, create a new TaskCompletionLog with this data.
     */
    create: XOR<TaskCompletionLogCreateInput, TaskCompletionLogUncheckedCreateInput>
    /**
     * In case the TaskCompletionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCompletionLogUpdateInput, TaskCompletionLogUncheckedUpdateInput>
  }

  /**
   * TaskCompletionLog delete
   */
  export type TaskCompletionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
    /**
     * Filter which TaskCompletionLog to delete.
     */
    where: TaskCompletionLogWhereUniqueInput
  }

  /**
   * TaskCompletionLog deleteMany
   */
  export type TaskCompletionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCompletionLogs to delete
     */
    where?: TaskCompletionLogWhereInput
    /**
     * Limit how many TaskCompletionLogs to delete.
     */
    limit?: number
  }

  /**
   * TaskCompletionLog without action
   */
  export type TaskCompletionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletionLog
     */
    select?: TaskCompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletionLog
     */
    omit?: TaskCompletionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionLogInclude<ExtArgs> | null
  }


  /**
   * Model RecurringTaskPattern
   */

  export type AggregateRecurringTaskPattern = {
    _count: RecurringTaskPatternCountAggregateOutputType | null
    _avg: RecurringTaskPatternAvgAggregateOutputType | null
    _sum: RecurringTaskPatternSumAggregateOutputType | null
    _min: RecurringTaskPatternMinAggregateOutputType | null
    _max: RecurringTaskPatternMaxAggregateOutputType | null
  }

  export type RecurringTaskPatternAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    interval: number | null
    endAfterCount: number | null
    dayOfMonth: number | null
    monthOfYear: number | null
  }

  export type RecurringTaskPatternSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    interval: number | null
    endAfterCount: number | null
    dayOfMonth: number | null
    monthOfYear: number | null
  }

  export type RecurringTaskPatternMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    frequency: string | null
    interval: number | null
    endAfterCount: number | null
    endByDate: Date | null
    daysOfWeek: string | null
    dayOfMonth: number | null
    monthOfYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTaskPatternMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    frequency: string | null
    interval: number | null
    endAfterCount: number | null
    endByDate: Date | null
    daysOfWeek: string | null
    dayOfMonth: number | null
    monthOfYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTaskPatternCountAggregateOutputType = {
    id: number
    taskId: number
    frequency: number
    interval: number
    endAfterCount: number
    endByDate: number
    daysOfWeek: number
    dayOfMonth: number
    monthOfYear: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringTaskPatternAvgAggregateInputType = {
    id?: true
    taskId?: true
    interval?: true
    endAfterCount?: true
    dayOfMonth?: true
    monthOfYear?: true
  }

  export type RecurringTaskPatternSumAggregateInputType = {
    id?: true
    taskId?: true
    interval?: true
    endAfterCount?: true
    dayOfMonth?: true
    monthOfYear?: true
  }

  export type RecurringTaskPatternMinAggregateInputType = {
    id?: true
    taskId?: true
    frequency?: true
    interval?: true
    endAfterCount?: true
    endByDate?: true
    daysOfWeek?: true
    dayOfMonth?: true
    monthOfYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTaskPatternMaxAggregateInputType = {
    id?: true
    taskId?: true
    frequency?: true
    interval?: true
    endAfterCount?: true
    endByDate?: true
    daysOfWeek?: true
    dayOfMonth?: true
    monthOfYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTaskPatternCountAggregateInputType = {
    id?: true
    taskId?: true
    frequency?: true
    interval?: true
    endAfterCount?: true
    endByDate?: true
    daysOfWeek?: true
    dayOfMonth?: true
    monthOfYear?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringTaskPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTaskPattern to aggregate.
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTaskPatterns to fetch.
     */
    orderBy?: RecurringTaskPatternOrderByWithRelationInput | RecurringTaskPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringTaskPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTaskPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTaskPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringTaskPatterns
    **/
    _count?: true | RecurringTaskPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringTaskPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringTaskPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringTaskPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringTaskPatternMaxAggregateInputType
  }

  export type GetRecurringTaskPatternAggregateType<T extends RecurringTaskPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringTaskPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringTaskPattern[P]>
      : GetScalarType<T[P], AggregateRecurringTaskPattern[P]>
  }




  export type RecurringTaskPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTaskPatternWhereInput
    orderBy?: RecurringTaskPatternOrderByWithAggregationInput | RecurringTaskPatternOrderByWithAggregationInput[]
    by: RecurringTaskPatternScalarFieldEnum[] | RecurringTaskPatternScalarFieldEnum
    having?: RecurringTaskPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringTaskPatternCountAggregateInputType | true
    _avg?: RecurringTaskPatternAvgAggregateInputType
    _sum?: RecurringTaskPatternSumAggregateInputType
    _min?: RecurringTaskPatternMinAggregateInputType
    _max?: RecurringTaskPatternMaxAggregateInputType
  }

  export type RecurringTaskPatternGroupByOutputType = {
    id: number
    taskId: number
    frequency: string
    interval: number
    endAfterCount: number | null
    endByDate: Date | null
    daysOfWeek: string | null
    dayOfMonth: number | null
    monthOfYear: number | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringTaskPatternCountAggregateOutputType | null
    _avg: RecurringTaskPatternAvgAggregateOutputType | null
    _sum: RecurringTaskPatternSumAggregateOutputType | null
    _min: RecurringTaskPatternMinAggregateOutputType | null
    _max: RecurringTaskPatternMaxAggregateOutputType | null
  }

  type GetRecurringTaskPatternGroupByPayload<T extends RecurringTaskPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringTaskPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringTaskPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringTaskPatternGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringTaskPatternGroupByOutputType[P]>
        }
      >
    >


  export type RecurringTaskPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    frequency?: boolean
    interval?: boolean
    endAfterCount?: boolean
    endByDate?: boolean
    daysOfWeek?: boolean
    dayOfMonth?: boolean
    monthOfYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTaskPattern"]>

  export type RecurringTaskPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    frequency?: boolean
    interval?: boolean
    endAfterCount?: boolean
    endByDate?: boolean
    daysOfWeek?: boolean
    dayOfMonth?: boolean
    monthOfYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTaskPattern"]>

  export type RecurringTaskPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    frequency?: boolean
    interval?: boolean
    endAfterCount?: boolean
    endByDate?: boolean
    daysOfWeek?: boolean
    dayOfMonth?: boolean
    monthOfYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTaskPattern"]>

  export type RecurringTaskPatternSelectScalar = {
    id?: boolean
    taskId?: boolean
    frequency?: boolean
    interval?: boolean
    endAfterCount?: boolean
    endByDate?: boolean
    daysOfWeek?: boolean
    dayOfMonth?: boolean
    monthOfYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringTaskPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "frequency" | "interval" | "endAfterCount" | "endByDate" | "daysOfWeek" | "dayOfMonth" | "monthOfYear" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringTaskPattern"]>
  export type RecurringTaskPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type RecurringTaskPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type RecurringTaskPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $RecurringTaskPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringTaskPattern"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      frequency: string
      interval: number
      endAfterCount: number | null
      endByDate: Date | null
      daysOfWeek: string | null
      dayOfMonth: number | null
      monthOfYear: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringTaskPattern"]>
    composites: {}
  }

  type RecurringTaskPatternGetPayload<S extends boolean | null | undefined | RecurringTaskPatternDefaultArgs> = $Result.GetResult<Prisma.$RecurringTaskPatternPayload, S>

  type RecurringTaskPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringTaskPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringTaskPatternCountAggregateInputType | true
    }

  export interface RecurringTaskPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringTaskPattern'], meta: { name: 'RecurringTaskPattern' } }
    /**
     * Find zero or one RecurringTaskPattern that matches the filter.
     * @param {RecurringTaskPatternFindUniqueArgs} args - Arguments to find a RecurringTaskPattern
     * @example
     * // Get one RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringTaskPatternFindUniqueArgs>(args: SelectSubset<T, RecurringTaskPatternFindUniqueArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringTaskPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringTaskPatternFindUniqueOrThrowArgs} args - Arguments to find a RecurringTaskPattern
     * @example
     * // Get one RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringTaskPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringTaskPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTaskPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternFindFirstArgs} args - Arguments to find a RecurringTaskPattern
     * @example
     * // Get one RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringTaskPatternFindFirstArgs>(args?: SelectSubset<T, RecurringTaskPatternFindFirstArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTaskPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternFindFirstOrThrowArgs} args - Arguments to find a RecurringTaskPattern
     * @example
     * // Get one RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringTaskPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringTaskPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringTaskPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringTaskPatterns
     * const recurringTaskPatterns = await prisma.recurringTaskPattern.findMany()
     * 
     * // Get first 10 RecurringTaskPatterns
     * const recurringTaskPatterns = await prisma.recurringTaskPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringTaskPatternWithIdOnly = await prisma.recurringTaskPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringTaskPatternFindManyArgs>(args?: SelectSubset<T, RecurringTaskPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringTaskPattern.
     * @param {RecurringTaskPatternCreateArgs} args - Arguments to create a RecurringTaskPattern.
     * @example
     * // Create one RecurringTaskPattern
     * const RecurringTaskPattern = await prisma.recurringTaskPattern.create({
     *   data: {
     *     // ... data to create a RecurringTaskPattern
     *   }
     * })
     * 
     */
    create<T extends RecurringTaskPatternCreateArgs>(args: SelectSubset<T, RecurringTaskPatternCreateArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringTaskPatterns.
     * @param {RecurringTaskPatternCreateManyArgs} args - Arguments to create many RecurringTaskPatterns.
     * @example
     * // Create many RecurringTaskPatterns
     * const recurringTaskPattern = await prisma.recurringTaskPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringTaskPatternCreateManyArgs>(args?: SelectSubset<T, RecurringTaskPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringTaskPatterns and returns the data saved in the database.
     * @param {RecurringTaskPatternCreateManyAndReturnArgs} args - Arguments to create many RecurringTaskPatterns.
     * @example
     * // Create many RecurringTaskPatterns
     * const recurringTaskPattern = await prisma.recurringTaskPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringTaskPatterns and only return the `id`
     * const recurringTaskPatternWithIdOnly = await prisma.recurringTaskPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringTaskPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringTaskPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringTaskPattern.
     * @param {RecurringTaskPatternDeleteArgs} args - Arguments to delete one RecurringTaskPattern.
     * @example
     * // Delete one RecurringTaskPattern
     * const RecurringTaskPattern = await prisma.recurringTaskPattern.delete({
     *   where: {
     *     // ... filter to delete one RecurringTaskPattern
     *   }
     * })
     * 
     */
    delete<T extends RecurringTaskPatternDeleteArgs>(args: SelectSubset<T, RecurringTaskPatternDeleteArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringTaskPattern.
     * @param {RecurringTaskPatternUpdateArgs} args - Arguments to update one RecurringTaskPattern.
     * @example
     * // Update one RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringTaskPatternUpdateArgs>(args: SelectSubset<T, RecurringTaskPatternUpdateArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringTaskPatterns.
     * @param {RecurringTaskPatternDeleteManyArgs} args - Arguments to filter RecurringTaskPatterns to delete.
     * @example
     * // Delete a few RecurringTaskPatterns
     * const { count } = await prisma.recurringTaskPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringTaskPatternDeleteManyArgs>(args?: SelectSubset<T, RecurringTaskPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTaskPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringTaskPatterns
     * const recurringTaskPattern = await prisma.recurringTaskPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringTaskPatternUpdateManyArgs>(args: SelectSubset<T, RecurringTaskPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTaskPatterns and returns the data updated in the database.
     * @param {RecurringTaskPatternUpdateManyAndReturnArgs} args - Arguments to update many RecurringTaskPatterns.
     * @example
     * // Update many RecurringTaskPatterns
     * const recurringTaskPattern = await prisma.recurringTaskPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringTaskPatterns and only return the `id`
     * const recurringTaskPatternWithIdOnly = await prisma.recurringTaskPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringTaskPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringTaskPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringTaskPattern.
     * @param {RecurringTaskPatternUpsertArgs} args - Arguments to update or create a RecurringTaskPattern.
     * @example
     * // Update or create a RecurringTaskPattern
     * const recurringTaskPattern = await prisma.recurringTaskPattern.upsert({
     *   create: {
     *     // ... data to create a RecurringTaskPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringTaskPattern we want to update
     *   }
     * })
     */
    upsert<T extends RecurringTaskPatternUpsertArgs>(args: SelectSubset<T, RecurringTaskPatternUpsertArgs<ExtArgs>>): Prisma__RecurringTaskPatternClient<$Result.GetResult<Prisma.$RecurringTaskPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringTaskPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternCountArgs} args - Arguments to filter RecurringTaskPatterns to count.
     * @example
     * // Count the number of RecurringTaskPatterns
     * const count = await prisma.recurringTaskPattern.count({
     *   where: {
     *     // ... the filter for the RecurringTaskPatterns we want to count
     *   }
     * })
    **/
    count<T extends RecurringTaskPatternCountArgs>(
      args?: Subset<T, RecurringTaskPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringTaskPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringTaskPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringTaskPatternAggregateArgs>(args: Subset<T, RecurringTaskPatternAggregateArgs>): Prisma.PrismaPromise<GetRecurringTaskPatternAggregateType<T>>

    /**
     * Group by RecurringTaskPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTaskPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringTaskPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringTaskPatternGroupByArgs['orderBy'] }
        : { orderBy?: RecurringTaskPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringTaskPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringTaskPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringTaskPattern model
   */
  readonly fields: RecurringTaskPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringTaskPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringTaskPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringTaskPattern model
   */
  interface RecurringTaskPatternFieldRefs {
    readonly id: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly taskId: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly frequency: FieldRef<"RecurringTaskPattern", 'String'>
    readonly interval: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly endAfterCount: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly endByDate: FieldRef<"RecurringTaskPattern", 'DateTime'>
    readonly daysOfWeek: FieldRef<"RecurringTaskPattern", 'String'>
    readonly dayOfMonth: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly monthOfYear: FieldRef<"RecurringTaskPattern", 'Int'>
    readonly createdAt: FieldRef<"RecurringTaskPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringTaskPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringTaskPattern findUnique
   */
  export type RecurringTaskPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTaskPattern to fetch.
     */
    where: RecurringTaskPatternWhereUniqueInput
  }

  /**
   * RecurringTaskPattern findUniqueOrThrow
   */
  export type RecurringTaskPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTaskPattern to fetch.
     */
    where: RecurringTaskPatternWhereUniqueInput
  }

  /**
   * RecurringTaskPattern findFirst
   */
  export type RecurringTaskPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTaskPattern to fetch.
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTaskPatterns to fetch.
     */
    orderBy?: RecurringTaskPatternOrderByWithRelationInput | RecurringTaskPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTaskPatterns.
     */
    cursor?: RecurringTaskPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTaskPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTaskPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTaskPatterns.
     */
    distinct?: RecurringTaskPatternScalarFieldEnum | RecurringTaskPatternScalarFieldEnum[]
  }

  /**
   * RecurringTaskPattern findFirstOrThrow
   */
  export type RecurringTaskPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTaskPattern to fetch.
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTaskPatterns to fetch.
     */
    orderBy?: RecurringTaskPatternOrderByWithRelationInput | RecurringTaskPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTaskPatterns.
     */
    cursor?: RecurringTaskPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTaskPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTaskPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTaskPatterns.
     */
    distinct?: RecurringTaskPatternScalarFieldEnum | RecurringTaskPatternScalarFieldEnum[]
  }

  /**
   * RecurringTaskPattern findMany
   */
  export type RecurringTaskPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTaskPatterns to fetch.
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTaskPatterns to fetch.
     */
    orderBy?: RecurringTaskPatternOrderByWithRelationInput | RecurringTaskPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringTaskPatterns.
     */
    cursor?: RecurringTaskPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTaskPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTaskPatterns.
     */
    skip?: number
    distinct?: RecurringTaskPatternScalarFieldEnum | RecurringTaskPatternScalarFieldEnum[]
  }

  /**
   * RecurringTaskPattern create
   */
  export type RecurringTaskPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringTaskPattern.
     */
    data: XOR<RecurringTaskPatternCreateInput, RecurringTaskPatternUncheckedCreateInput>
  }

  /**
   * RecurringTaskPattern createMany
   */
  export type RecurringTaskPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringTaskPatterns.
     */
    data: RecurringTaskPatternCreateManyInput | RecurringTaskPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringTaskPattern createManyAndReturn
   */
  export type RecurringTaskPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringTaskPatterns.
     */
    data: RecurringTaskPatternCreateManyInput | RecurringTaskPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTaskPattern update
   */
  export type RecurringTaskPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringTaskPattern.
     */
    data: XOR<RecurringTaskPatternUpdateInput, RecurringTaskPatternUncheckedUpdateInput>
    /**
     * Choose, which RecurringTaskPattern to update.
     */
    where: RecurringTaskPatternWhereUniqueInput
  }

  /**
   * RecurringTaskPattern updateMany
   */
  export type RecurringTaskPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringTaskPatterns.
     */
    data: XOR<RecurringTaskPatternUpdateManyMutationInput, RecurringTaskPatternUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTaskPatterns to update
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * Limit how many RecurringTaskPatterns to update.
     */
    limit?: number
  }

  /**
   * RecurringTaskPattern updateManyAndReturn
   */
  export type RecurringTaskPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * The data used to update RecurringTaskPatterns.
     */
    data: XOR<RecurringTaskPatternUpdateManyMutationInput, RecurringTaskPatternUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTaskPatterns to update
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * Limit how many RecurringTaskPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTaskPattern upsert
   */
  export type RecurringTaskPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringTaskPattern to update in case it exists.
     */
    where: RecurringTaskPatternWhereUniqueInput
    /**
     * In case the RecurringTaskPattern found by the `where` argument doesn't exist, create a new RecurringTaskPattern with this data.
     */
    create: XOR<RecurringTaskPatternCreateInput, RecurringTaskPatternUncheckedCreateInput>
    /**
     * In case the RecurringTaskPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringTaskPatternUpdateInput, RecurringTaskPatternUncheckedUpdateInput>
  }

  /**
   * RecurringTaskPattern delete
   */
  export type RecurringTaskPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
    /**
     * Filter which RecurringTaskPattern to delete.
     */
    where: RecurringTaskPatternWhereUniqueInput
  }

  /**
   * RecurringTaskPattern deleteMany
   */
  export type RecurringTaskPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTaskPatterns to delete
     */
    where?: RecurringTaskPatternWhereInput
    /**
     * Limit how many RecurringTaskPatterns to delete.
     */
    limit?: number
  }

  /**
   * RecurringTaskPattern without action
   */
  export type RecurringTaskPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTaskPattern
     */
    select?: RecurringTaskPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTaskPattern
     */
    omit?: RecurringTaskPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTaskPatternInclude<ExtArgs> | null
  }


  /**
   * Model TaskNotification
   */

  export type AggregateTaskNotification = {
    _count: TaskNotificationCountAggregateOutputType | null
    _avg: TaskNotificationAvgAggregateOutputType | null
    _sum: TaskNotificationSumAggregateOutputType | null
    _min: TaskNotificationMinAggregateOutputType | null
    _max: TaskNotificationMaxAggregateOutputType | null
  }

  export type TaskNotificationAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskNotificationSumAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskNotificationMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type TaskNotificationMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type TaskNotificationCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    message: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type TaskNotificationAvgAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskNotificationSumAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskNotificationMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type TaskNotificationMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type TaskNotificationCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type TaskNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNotification to aggregate.
     */
    where?: TaskNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotifications to fetch.
     */
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskNotifications
    **/
    _count?: true | TaskNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskNotificationMaxAggregateInputType
  }

  export type GetTaskNotificationAggregateType<T extends TaskNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskNotification[P]>
      : GetScalarType<T[P], AggregateTaskNotification[P]>
  }




  export type TaskNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskNotificationWhereInput
    orderBy?: TaskNotificationOrderByWithAggregationInput | TaskNotificationOrderByWithAggregationInput[]
    by: TaskNotificationScalarFieldEnum[] | TaskNotificationScalarFieldEnum
    having?: TaskNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskNotificationCountAggregateInputType | true
    _avg?: TaskNotificationAvgAggregateInputType
    _sum?: TaskNotificationSumAggregateInputType
    _min?: TaskNotificationMinAggregateInputType
    _max?: TaskNotificationMaxAggregateInputType
  }

  export type TaskNotificationGroupByOutputType = {
    id: number
    taskId: number
    userId: string
    message: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: TaskNotificationCountAggregateOutputType | null
    _avg: TaskNotificationAvgAggregateOutputType | null
    _sum: TaskNotificationSumAggregateOutputType | null
    _min: TaskNotificationMinAggregateOutputType | null
    _max: TaskNotificationMaxAggregateOutputType | null
  }

  type GetTaskNotificationGroupByPayload<T extends TaskNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], TaskNotificationGroupByOutputType[P]>
        }
      >
    >


  export type TaskNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNotification"]>

  export type TaskNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNotification"]>

  export type TaskNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskNotification"]>

  export type TaskNotificationSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type TaskNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "message" | "isRead" | "readAt" | "createdAt", ExtArgs["result"]["taskNotification"]>
  export type TaskNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskNotification"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: string
      message: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["taskNotification"]>
    composites: {}
  }

  type TaskNotificationGetPayload<S extends boolean | null | undefined | TaskNotificationDefaultArgs> = $Result.GetResult<Prisma.$TaskNotificationPayload, S>

  type TaskNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskNotificationCountAggregateInputType | true
    }

  export interface TaskNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskNotification'], meta: { name: 'TaskNotification' } }
    /**
     * Find zero or one TaskNotification that matches the filter.
     * @param {TaskNotificationFindUniqueArgs} args - Arguments to find a TaskNotification
     * @example
     * // Get one TaskNotification
     * const taskNotification = await prisma.taskNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskNotificationFindUniqueArgs>(args: SelectSubset<T, TaskNotificationFindUniqueArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskNotificationFindUniqueOrThrowArgs} args - Arguments to find a TaskNotification
     * @example
     * // Get one TaskNotification
     * const taskNotification = await prisma.taskNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationFindFirstArgs} args - Arguments to find a TaskNotification
     * @example
     * // Get one TaskNotification
     * const taskNotification = await prisma.taskNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskNotificationFindFirstArgs>(args?: SelectSubset<T, TaskNotificationFindFirstArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationFindFirstOrThrowArgs} args - Arguments to find a TaskNotification
     * @example
     * // Get one TaskNotification
     * const taskNotification = await prisma.taskNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskNotifications
     * const taskNotifications = await prisma.taskNotification.findMany()
     * 
     * // Get first 10 TaskNotifications
     * const taskNotifications = await prisma.taskNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskNotificationWithIdOnly = await prisma.taskNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskNotificationFindManyArgs>(args?: SelectSubset<T, TaskNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskNotification.
     * @param {TaskNotificationCreateArgs} args - Arguments to create a TaskNotification.
     * @example
     * // Create one TaskNotification
     * const TaskNotification = await prisma.taskNotification.create({
     *   data: {
     *     // ... data to create a TaskNotification
     *   }
     * })
     * 
     */
    create<T extends TaskNotificationCreateArgs>(args: SelectSubset<T, TaskNotificationCreateArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskNotifications.
     * @param {TaskNotificationCreateManyArgs} args - Arguments to create many TaskNotifications.
     * @example
     * // Create many TaskNotifications
     * const taskNotification = await prisma.taskNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskNotificationCreateManyArgs>(args?: SelectSubset<T, TaskNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskNotifications and returns the data saved in the database.
     * @param {TaskNotificationCreateManyAndReturnArgs} args - Arguments to create many TaskNotifications.
     * @example
     * // Create many TaskNotifications
     * const taskNotification = await prisma.taskNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskNotifications and only return the `id`
     * const taskNotificationWithIdOnly = await prisma.taskNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskNotification.
     * @param {TaskNotificationDeleteArgs} args - Arguments to delete one TaskNotification.
     * @example
     * // Delete one TaskNotification
     * const TaskNotification = await prisma.taskNotification.delete({
     *   where: {
     *     // ... filter to delete one TaskNotification
     *   }
     * })
     * 
     */
    delete<T extends TaskNotificationDeleteArgs>(args: SelectSubset<T, TaskNotificationDeleteArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskNotification.
     * @param {TaskNotificationUpdateArgs} args - Arguments to update one TaskNotification.
     * @example
     * // Update one TaskNotification
     * const taskNotification = await prisma.taskNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskNotificationUpdateArgs>(args: SelectSubset<T, TaskNotificationUpdateArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskNotifications.
     * @param {TaskNotificationDeleteManyArgs} args - Arguments to filter TaskNotifications to delete.
     * @example
     * // Delete a few TaskNotifications
     * const { count } = await prisma.taskNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskNotificationDeleteManyArgs>(args?: SelectSubset<T, TaskNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskNotifications
     * const taskNotification = await prisma.taskNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskNotificationUpdateManyArgs>(args: SelectSubset<T, TaskNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskNotifications and returns the data updated in the database.
     * @param {TaskNotificationUpdateManyAndReturnArgs} args - Arguments to update many TaskNotifications.
     * @example
     * // Update many TaskNotifications
     * const taskNotification = await prisma.taskNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskNotifications and only return the `id`
     * const taskNotificationWithIdOnly = await prisma.taskNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskNotification.
     * @param {TaskNotificationUpsertArgs} args - Arguments to update or create a TaskNotification.
     * @example
     * // Update or create a TaskNotification
     * const taskNotification = await prisma.taskNotification.upsert({
     *   create: {
     *     // ... data to create a TaskNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskNotification we want to update
     *   }
     * })
     */
    upsert<T extends TaskNotificationUpsertArgs>(args: SelectSubset<T, TaskNotificationUpsertArgs<ExtArgs>>): Prisma__TaskNotificationClient<$Result.GetResult<Prisma.$TaskNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationCountArgs} args - Arguments to filter TaskNotifications to count.
     * @example
     * // Count the number of TaskNotifications
     * const count = await prisma.taskNotification.count({
     *   where: {
     *     // ... the filter for the TaskNotifications we want to count
     *   }
     * })
    **/
    count<T extends TaskNotificationCountArgs>(
      args?: Subset<T, TaskNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskNotificationAggregateArgs>(args: Subset<T, TaskNotificationAggregateArgs>): Prisma.PrismaPromise<GetTaskNotificationAggregateType<T>>

    /**
     * Group by TaskNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskNotificationGroupByArgs['orderBy'] }
        : { orderBy?: TaskNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskNotification model
   */
  readonly fields: TaskNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskNotification model
   */
  interface TaskNotificationFieldRefs {
    readonly id: FieldRef<"TaskNotification", 'Int'>
    readonly taskId: FieldRef<"TaskNotification", 'Int'>
    readonly userId: FieldRef<"TaskNotification", 'String'>
    readonly message: FieldRef<"TaskNotification", 'String'>
    readonly isRead: FieldRef<"TaskNotification", 'Boolean'>
    readonly readAt: FieldRef<"TaskNotification", 'DateTime'>
    readonly createdAt: FieldRef<"TaskNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskNotification findUnique
   */
  export type TaskNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotification to fetch.
     */
    where: TaskNotificationWhereUniqueInput
  }

  /**
   * TaskNotification findUniqueOrThrow
   */
  export type TaskNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotification to fetch.
     */
    where: TaskNotificationWhereUniqueInput
  }

  /**
   * TaskNotification findFirst
   */
  export type TaskNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotification to fetch.
     */
    where?: TaskNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotifications to fetch.
     */
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotifications.
     */
    cursor?: TaskNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotifications.
     */
    distinct?: TaskNotificationScalarFieldEnum | TaskNotificationScalarFieldEnum[]
  }

  /**
   * TaskNotification findFirstOrThrow
   */
  export type TaskNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotification to fetch.
     */
    where?: TaskNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotifications to fetch.
     */
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskNotifications.
     */
    cursor?: TaskNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskNotifications.
     */
    distinct?: TaskNotificationScalarFieldEnum | TaskNotificationScalarFieldEnum[]
  }

  /**
   * TaskNotification findMany
   */
  export type TaskNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TaskNotifications to fetch.
     */
    where?: TaskNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskNotifications to fetch.
     */
    orderBy?: TaskNotificationOrderByWithRelationInput | TaskNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskNotifications.
     */
    cursor?: TaskNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskNotifications.
     */
    skip?: number
    distinct?: TaskNotificationScalarFieldEnum | TaskNotificationScalarFieldEnum[]
  }

  /**
   * TaskNotification create
   */
  export type TaskNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskNotification.
     */
    data: XOR<TaskNotificationCreateInput, TaskNotificationUncheckedCreateInput>
  }

  /**
   * TaskNotification createMany
   */
  export type TaskNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskNotifications.
     */
    data: TaskNotificationCreateManyInput | TaskNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskNotification createManyAndReturn
   */
  export type TaskNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many TaskNotifications.
     */
    data: TaskNotificationCreateManyInput | TaskNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNotification update
   */
  export type TaskNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskNotification.
     */
    data: XOR<TaskNotificationUpdateInput, TaskNotificationUncheckedUpdateInput>
    /**
     * Choose, which TaskNotification to update.
     */
    where: TaskNotificationWhereUniqueInput
  }

  /**
   * TaskNotification updateMany
   */
  export type TaskNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskNotifications.
     */
    data: XOR<TaskNotificationUpdateManyMutationInput, TaskNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotifications to update
     */
    where?: TaskNotificationWhereInput
    /**
     * Limit how many TaskNotifications to update.
     */
    limit?: number
  }

  /**
   * TaskNotification updateManyAndReturn
   */
  export type TaskNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * The data used to update TaskNotifications.
     */
    data: XOR<TaskNotificationUpdateManyMutationInput, TaskNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TaskNotifications to update
     */
    where?: TaskNotificationWhereInput
    /**
     * Limit how many TaskNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskNotification upsert
   */
  export type TaskNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskNotification to update in case it exists.
     */
    where: TaskNotificationWhereUniqueInput
    /**
     * In case the TaskNotification found by the `where` argument doesn't exist, create a new TaskNotification with this data.
     */
    create: XOR<TaskNotificationCreateInput, TaskNotificationUncheckedCreateInput>
    /**
     * In case the TaskNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskNotificationUpdateInput, TaskNotificationUncheckedUpdateInput>
  }

  /**
   * TaskNotification delete
   */
  export type TaskNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
    /**
     * Filter which TaskNotification to delete.
     */
    where: TaskNotificationWhereUniqueInput
  }

  /**
   * TaskNotification deleteMany
   */
  export type TaskNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskNotifications to delete
     */
    where?: TaskNotificationWhereInput
    /**
     * Limit how many TaskNotifications to delete.
     */
    limit?: number
  }

  /**
   * TaskNotification without action
   */
  export type TaskNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskNotification
     */
    select?: TaskNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskNotification
     */
    omit?: TaskNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskNotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const GardenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    location: 'location',
    sizeSqFeet: 'sizeSqFeet',
    gardenType: 'gardenType',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GardenScalarFieldEnum = (typeof GardenScalarFieldEnum)[keyof typeof GardenScalarFieldEnum]


  export const GardenConditionScalarFieldEnum: {
    id: 'id',
    gardenId: 'gardenId',
    climateZone: 'climateZone',
    sunlightExposure: 'sunlightExposure',
    avgTemperatureF: 'avgTemperatureF',
    humidityPct: 'humidityPct',
    soilType: 'soilType',
    annualRainfall: 'annualRainfall',
    additionalNotes: 'additionalNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GardenConditionScalarFieldEnum = (typeof GardenConditionScalarFieldEnum)[keyof typeof GardenConditionScalarFieldEnum]


  export const ContainerTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    typicalDimensions: 'typicalDimensions'
  };

  export type ContainerTypeScalarFieldEnum = (typeof ContainerTypeScalarFieldEnum)[keyof typeof ContainerTypeScalarFieldEnum]


  export const ContainerScalarFieldEnum: {
    id: 'id',
    gardenId: 'gardenId',
    containerTypeId: 'containerTypeId',
    name: 'name',
    material: 'material',
    widthInches: 'widthInches',
    lengthInches: 'lengthInches',
    heightInches: 'heightInches',
    diameterInches: 'diameterInches',
    volumeGallons: 'volumeGallons',
    positionX: 'positionX',
    positionY: 'positionY',
    soilType: 'soilType',
    drainageQuality: 'drainageQuality',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContainerScalarFieldEnum = (typeof ContainerScalarFieldEnum)[keyof typeof ContainerScalarFieldEnum]


  export const PlantCatalogScalarFieldEnum: {
    id: 'id',
    commonName: 'commonName',
    scientificName: 'scientificName',
    plantType: 'plantType',
    lifeCycle: 'lifeCycle',
    growthHabit: 'growthHabit',
    edible: 'edible',
    description: 'description',
    plantingInstructions: 'plantingInstructions',
    careInstructions: 'careInstructions',
    daysToGerminationMin: 'daysToGerminationMin',
    daysToGerminationMax: 'daysToGerminationMax',
    daysToMaturityMin: 'daysToMaturityMin',
    daysToMaturityMax: 'daysToMaturityMax',
    harvestSeason: 'harvestSeason',
    heightInchesMin: 'heightInchesMin',
    heightInchesMax: 'heightInchesMax',
    widthInchesMin: 'widthInchesMin',
    widthInchesMax: 'widthInchesMax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlantCatalogScalarFieldEnum = (typeof PlantCatalogScalarFieldEnum)[keyof typeof PlantCatalogScalarFieldEnum]


  export const PlantGrowingConditionScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    minTemperatureF: 'minTemperatureF',
    maxTemperatureF: 'maxTemperatureF',
    sunlightNeeds: 'sunlightNeeds',
    waterNeeds: 'waterNeeds',
    soilPhMin: 'soilPhMin',
    soilPhMax: 'soilPhMax',
    soilTypePreference: 'soilTypePreference',
    fertilizerNeeds: 'fertilizerNeeds',
    spacingInches: 'spacingInches',
    containerSuitable: 'containerSuitable',
    minContainerDepthInches: 'minContainerDepthInches',
    minContainerVolumeGallons: 'minContainerVolumeGallons'
  };

  export type PlantGrowingConditionScalarFieldEnum = (typeof PlantGrowingConditionScalarFieldEnum)[keyof typeof PlantGrowingConditionScalarFieldEnum]


  export const PlantClimateZoneScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    climateZone: 'climateZone',
    notes: 'notes'
  };

  export type PlantClimateZoneScalarFieldEnum = (typeof PlantClimateZoneScalarFieldEnum)[keyof typeof PlantClimateZoneScalarFieldEnum]


  export const PlantVarietyScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    varietyName: 'varietyName',
    description: 'description',
    specificTraits: 'specificTraits',
    specificCareNeeds: 'specificCareNeeds',
    imageUrl: 'imageUrl'
  };

  export type PlantVarietyScalarFieldEnum = (typeof PlantVarietyScalarFieldEnum)[keyof typeof PlantVarietyScalarFieldEnum]


  export const PlantCompanionScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    companionPlantId: 'companionPlantId',
    relationshipType: 'relationshipType',
    effectDescription: 'effectDescription'
  };

  export type PlantCompanionScalarFieldEnum = (typeof PlantCompanionScalarFieldEnum)[keyof typeof PlantCompanionScalarFieldEnum]


  export const ContainerPlantScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    plantId: 'plantId',
    varietyId: 'varietyId',
    quantity: 'quantity',
    plantDate: 'plantDate',
    initialStage: 'initialStage',
    currentStage: 'currentStage',
    status: 'status',
    positionX: 'positionX',
    positionY: 'positionY',
    expectedHarvestDate: 'expectedHarvestDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContainerPlantScalarFieldEnum = (typeof ContainerPlantScalarFieldEnum)[keyof typeof ContainerPlantScalarFieldEnum]


  export const PlantGrowthStageScalarFieldEnum: {
    id: 'id',
    containerPlantId: 'containerPlantId',
    stageName: 'stageName',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes',
    imageUrl: 'imageUrl'
  };

  export type PlantGrowthStageScalarFieldEnum = (typeof PlantGrowthStageScalarFieldEnum)[keyof typeof PlantGrowthStageScalarFieldEnum]


  export const ActionTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type ActionTypeScalarFieldEnum = (typeof ActionTypeScalarFieldEnum)[keyof typeof ActionTypeScalarFieldEnum]


  export const GardenActionScalarFieldEnum: {
    id: 'id',
    actionTypeId: 'actionTypeId',
    userId: 'userId',
    gardenId: 'gardenId',
    containerId: 'containerId',
    containerPlantId: 'containerPlantId',
    actionDate: 'actionDate',
    quantity: 'quantity',
    unit: 'unit',
    notes: 'notes',
    successRating: 'successRating',
    createdAt: 'createdAt'
  };

  export type GardenActionScalarFieldEnum = (typeof GardenActionScalarFieldEnum)[keyof typeof GardenActionScalarFieldEnum]


  export const HarvestScalarFieldEnum: {
    id: 'id',
    containerPlantId: 'containerPlantId',
    harvestDate: 'harvestDate',
    quantity: 'quantity',
    unit: 'unit',
    qualityRating: 'qualityRating',
    notes: 'notes',
    imageUrl: 'imageUrl'
  };

  export type HarvestScalarFieldEnum = (typeof HarvestScalarFieldEnum)[keyof typeof HarvestScalarFieldEnum]


  export const ContainerHistoryScalarFieldEnum: {
    id: 'id',
    containerId: 'containerId',
    previousContainerId: 'previousContainerId',
    previousGardenId: 'previousGardenId',
    newGardenId: 'newGardenId',
    moveDate: 'moveDate',
    reason: 'reason'
  };

  export type ContainerHistoryScalarFieldEnum = (typeof ContainerHistoryScalarFieldEnum)[keyof typeof ContainerHistoryScalarFieldEnum]


  export const PlantMovementHistoryScalarFieldEnum: {
    id: 'id',
    containerPlantId: 'containerPlantId',
    previousContainerId: 'previousContainerId',
    newContainerId: 'newContainerId',
    moveDate: 'moveDate',
    reason: 'reason',
    plantConditionBefore: 'plantConditionBefore',
    plantConditionAfter: 'plantConditionAfter'
  };

  export type PlantMovementHistoryScalarFieldEnum = (typeof PlantMovementHistoryScalarFieldEnum)[keyof typeof PlantMovementHistoryScalarFieldEnum]


  export const SeasonalPlanScalarFieldEnum: {
    id: 'id',
    gardenId: 'gardenId',
    season: 'season',
    year: 'year',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeasonalPlanScalarFieldEnum = (typeof SeasonalPlanScalarFieldEnum)[keyof typeof SeasonalPlanScalarFieldEnum]


  export const PlannedPlantingScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    containerId: 'containerId',
    plantId: 'plantId',
    varietyId: 'varietyId',
    plannedDate: 'plannedDate',
    quantity: 'quantity',
    notes: 'notes',
    status: 'status'
  };

  export type PlannedPlantingScalarFieldEnum = (typeof PlannedPlantingScalarFieldEnum)[keyof typeof PlannedPlantingScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    category: 'category',
    priority: 'priority',
    difficulty: 'difficulty',
    estimatedMinutes: 'estimatedMinutes',
    startDate: 'startDate',
    endDate: 'endDate',
    dateCompleted: 'dateCompleted',
    userId: 'userId',
    gardenId: 'gardenId',
    containerId: 'containerId',
    containerPlantId: 'containerPlantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isRecurring: 'isRecurring',
    parentTaskId: 'parentTaskId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskPrerequisiteScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    prerequisiteTaskId: 'prerequisiteTaskId',
    createdAt: 'createdAt'
  };

  export type TaskPrerequisiteScalarFieldEnum = (typeof TaskPrerequisiteScalarFieldEnum)[keyof typeof TaskPrerequisiteScalarFieldEnum]


  export const TaskNoteScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskNoteScalarFieldEnum = (typeof TaskNoteScalarFieldEnum)[keyof typeof TaskNoteScalarFieldEnum]


  export const TaskCompletionLogScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    status: 'status',
    completedAt: 'completedAt',
    notes: 'notes',
    percentDone: 'percentDone',
    timeSpentMinutes: 'timeSpentMinutes'
  };

  export type TaskCompletionLogScalarFieldEnum = (typeof TaskCompletionLogScalarFieldEnum)[keyof typeof TaskCompletionLogScalarFieldEnum]


  export const RecurringTaskPatternScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    frequency: 'frequency',
    interval: 'interval',
    endAfterCount: 'endAfterCount',
    endByDate: 'endByDate',
    daysOfWeek: 'daysOfWeek',
    dayOfMonth: 'dayOfMonth',
    monthOfYear: 'monthOfYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringTaskPatternScalarFieldEnum = (typeof RecurringTaskPatternScalarFieldEnum)[keyof typeof RecurringTaskPatternScalarFieldEnum]


  export const TaskNotificationScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type TaskNotificationScalarFieldEnum = (typeof TaskNotificationScalarFieldEnum)[keyof typeof TaskNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    gardens?: GardenListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    tasks?: TaskListRelationFilter
    taskNotes?: TaskNoteListRelationFilter
    taskCompletionLogs?: TaskCompletionLogListRelationFilter
    taskNotifications?: TaskNotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    gardens?: GardenOrderByRelationAggregateInput
    gardenActions?: GardenActionOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    taskNotes?: TaskNoteOrderByRelationAggregateInput
    taskCompletionLogs?: TaskCompletionLogOrderByRelationAggregateInput
    taskNotifications?: TaskNotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    gardens?: GardenListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    tasks?: TaskListRelationFilter
    taskNotes?: TaskNoteListRelationFilter
    taskCompletionLogs?: TaskCompletionLogListRelationFilter
    taskNotifications?: TaskNotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type GardenWhereInput = {
    AND?: GardenWhereInput | GardenWhereInput[]
    OR?: GardenWhereInput[]
    NOT?: GardenWhereInput | GardenWhereInput[]
    id?: IntFilter<"Garden"> | number
    userId?: StringFilter<"Garden"> | string
    name?: StringFilter<"Garden"> | string
    location?: StringNullableFilter<"Garden"> | string | null
    sizeSqFeet?: DecimalNullableFilter<"Garden"> | Decimal | DecimalJsLike | number | string | null
    gardenType?: StringNullableFilter<"Garden"> | string | null
    description?: StringNullableFilter<"Garden"> | string | null
    createdAt?: DateTimeFilter<"Garden"> | Date | string
    updatedAt?: DateTimeFilter<"Garden"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    conditions?: GardenConditionListRelationFilter
    containers?: ContainerListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    seasonalPlans?: SeasonalPlanListRelationFilter
    previousContainers?: ContainerHistoryListRelationFilter
    newContainers?: ContainerHistoryListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type GardenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    sizeSqFeet?: SortOrderInput | SortOrder
    gardenType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    conditions?: GardenConditionOrderByRelationAggregateInput
    containers?: ContainerOrderByRelationAggregateInput
    gardenActions?: GardenActionOrderByRelationAggregateInput
    seasonalPlans?: SeasonalPlanOrderByRelationAggregateInput
    previousContainers?: ContainerHistoryOrderByRelationAggregateInput
    newContainers?: ContainerHistoryOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type GardenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GardenWhereInput | GardenWhereInput[]
    OR?: GardenWhereInput[]
    NOT?: GardenWhereInput | GardenWhereInput[]
    userId?: StringFilter<"Garden"> | string
    name?: StringFilter<"Garden"> | string
    location?: StringNullableFilter<"Garden"> | string | null
    sizeSqFeet?: DecimalNullableFilter<"Garden"> | Decimal | DecimalJsLike | number | string | null
    gardenType?: StringNullableFilter<"Garden"> | string | null
    description?: StringNullableFilter<"Garden"> | string | null
    createdAt?: DateTimeFilter<"Garden"> | Date | string
    updatedAt?: DateTimeFilter<"Garden"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    conditions?: GardenConditionListRelationFilter
    containers?: ContainerListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    seasonalPlans?: SeasonalPlanListRelationFilter
    previousContainers?: ContainerHistoryListRelationFilter
    newContainers?: ContainerHistoryListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type GardenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    sizeSqFeet?: SortOrderInput | SortOrder
    gardenType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GardenCountOrderByAggregateInput
    _avg?: GardenAvgOrderByAggregateInput
    _max?: GardenMaxOrderByAggregateInput
    _min?: GardenMinOrderByAggregateInput
    _sum?: GardenSumOrderByAggregateInput
  }

  export type GardenScalarWhereWithAggregatesInput = {
    AND?: GardenScalarWhereWithAggregatesInput | GardenScalarWhereWithAggregatesInput[]
    OR?: GardenScalarWhereWithAggregatesInput[]
    NOT?: GardenScalarWhereWithAggregatesInput | GardenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Garden"> | number
    userId?: StringWithAggregatesFilter<"Garden"> | string
    name?: StringWithAggregatesFilter<"Garden"> | string
    location?: StringNullableWithAggregatesFilter<"Garden"> | string | null
    sizeSqFeet?: DecimalNullableWithAggregatesFilter<"Garden"> | Decimal | DecimalJsLike | number | string | null
    gardenType?: StringNullableWithAggregatesFilter<"Garden"> | string | null
    description?: StringNullableWithAggregatesFilter<"Garden"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Garden"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Garden"> | Date | string
  }

  export type GardenConditionWhereInput = {
    AND?: GardenConditionWhereInput | GardenConditionWhereInput[]
    OR?: GardenConditionWhereInput[]
    NOT?: GardenConditionWhereInput | GardenConditionWhereInput[]
    id?: IntFilter<"GardenCondition"> | number
    gardenId?: IntFilter<"GardenCondition"> | number
    climateZone?: StringNullableFilter<"GardenCondition"> | string | null
    sunlightExposure?: StringNullableFilter<"GardenCondition"> | string | null
    avgTemperatureF?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    humidityPct?: IntNullableFilter<"GardenCondition"> | number | null
    soilType?: StringNullableFilter<"GardenCondition"> | string | null
    annualRainfall?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: StringNullableFilter<"GardenCondition"> | string | null
    createdAt?: DateTimeFilter<"GardenCondition"> | Date | string
    updatedAt?: DateTimeFilter<"GardenCondition"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
  }

  export type GardenConditionOrderByWithRelationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    climateZone?: SortOrderInput | SortOrder
    sunlightExposure?: SortOrderInput | SortOrder
    avgTemperatureF?: SortOrderInput | SortOrder
    humidityPct?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    annualRainfall?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    garden?: GardenOrderByWithRelationInput
  }

  export type GardenConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GardenConditionWhereInput | GardenConditionWhereInput[]
    OR?: GardenConditionWhereInput[]
    NOT?: GardenConditionWhereInput | GardenConditionWhereInput[]
    gardenId?: IntFilter<"GardenCondition"> | number
    climateZone?: StringNullableFilter<"GardenCondition"> | string | null
    sunlightExposure?: StringNullableFilter<"GardenCondition"> | string | null
    avgTemperatureF?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    humidityPct?: IntNullableFilter<"GardenCondition"> | number | null
    soilType?: StringNullableFilter<"GardenCondition"> | string | null
    annualRainfall?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: StringNullableFilter<"GardenCondition"> | string | null
    createdAt?: DateTimeFilter<"GardenCondition"> | Date | string
    updatedAt?: DateTimeFilter<"GardenCondition"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
  }, "id">

  export type GardenConditionOrderByWithAggregationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    climateZone?: SortOrderInput | SortOrder
    sunlightExposure?: SortOrderInput | SortOrder
    avgTemperatureF?: SortOrderInput | SortOrder
    humidityPct?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    annualRainfall?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GardenConditionCountOrderByAggregateInput
    _avg?: GardenConditionAvgOrderByAggregateInput
    _max?: GardenConditionMaxOrderByAggregateInput
    _min?: GardenConditionMinOrderByAggregateInput
    _sum?: GardenConditionSumOrderByAggregateInput
  }

  export type GardenConditionScalarWhereWithAggregatesInput = {
    AND?: GardenConditionScalarWhereWithAggregatesInput | GardenConditionScalarWhereWithAggregatesInput[]
    OR?: GardenConditionScalarWhereWithAggregatesInput[]
    NOT?: GardenConditionScalarWhereWithAggregatesInput | GardenConditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GardenCondition"> | number
    gardenId?: IntWithAggregatesFilter<"GardenCondition"> | number
    climateZone?: StringNullableWithAggregatesFilter<"GardenCondition"> | string | null
    sunlightExposure?: StringNullableWithAggregatesFilter<"GardenCondition"> | string | null
    avgTemperatureF?: DecimalNullableWithAggregatesFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    humidityPct?: IntNullableWithAggregatesFilter<"GardenCondition"> | number | null
    soilType?: StringNullableWithAggregatesFilter<"GardenCondition"> | string | null
    annualRainfall?: DecimalNullableWithAggregatesFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: StringNullableWithAggregatesFilter<"GardenCondition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GardenCondition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GardenCondition"> | Date | string
  }

  export type ContainerTypeWhereInput = {
    AND?: ContainerTypeWhereInput | ContainerTypeWhereInput[]
    OR?: ContainerTypeWhereInput[]
    NOT?: ContainerTypeWhereInput | ContainerTypeWhereInput[]
    id?: IntFilter<"ContainerType"> | number
    name?: StringFilter<"ContainerType"> | string
    description?: StringNullableFilter<"ContainerType"> | string | null
    typicalDimensions?: StringNullableFilter<"ContainerType"> | string | null
    containers?: ContainerListRelationFilter
  }

  export type ContainerTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    typicalDimensions?: SortOrderInput | SortOrder
    containers?: ContainerOrderByRelationAggregateInput
  }

  export type ContainerTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContainerTypeWhereInput | ContainerTypeWhereInput[]
    OR?: ContainerTypeWhereInput[]
    NOT?: ContainerTypeWhereInput | ContainerTypeWhereInput[]
    name?: StringFilter<"ContainerType"> | string
    description?: StringNullableFilter<"ContainerType"> | string | null
    typicalDimensions?: StringNullableFilter<"ContainerType"> | string | null
    containers?: ContainerListRelationFilter
  }, "id">

  export type ContainerTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    typicalDimensions?: SortOrderInput | SortOrder
    _count?: ContainerTypeCountOrderByAggregateInput
    _avg?: ContainerTypeAvgOrderByAggregateInput
    _max?: ContainerTypeMaxOrderByAggregateInput
    _min?: ContainerTypeMinOrderByAggregateInput
    _sum?: ContainerTypeSumOrderByAggregateInput
  }

  export type ContainerTypeScalarWhereWithAggregatesInput = {
    AND?: ContainerTypeScalarWhereWithAggregatesInput | ContainerTypeScalarWhereWithAggregatesInput[]
    OR?: ContainerTypeScalarWhereWithAggregatesInput[]
    NOT?: ContainerTypeScalarWhereWithAggregatesInput | ContainerTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContainerType"> | number
    name?: StringWithAggregatesFilter<"ContainerType"> | string
    description?: StringNullableWithAggregatesFilter<"ContainerType"> | string | null
    typicalDimensions?: StringNullableWithAggregatesFilter<"ContainerType"> | string | null
  }

  export type ContainerWhereInput = {
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    id?: IntFilter<"Container"> | number
    gardenId?: IntFilter<"Container"> | number
    containerTypeId?: IntFilter<"Container"> | number
    name?: StringNullableFilter<"Container"> | string | null
    material?: StringNullableFilter<"Container"> | string | null
    widthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    lengthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    heightInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    diameterInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionX?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"Container"> | string | null
    drainageQuality?: StringNullableFilter<"Container"> | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
    containerType?: XOR<ContainerTypeScalarRelationFilter, ContainerTypeWhereInput>
    containerPlants?: ContainerPlantListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    containerHistory?: ContainerHistoryListRelationFilter
    previousContainers?: ContainerHistoryListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ContainerOrderByWithRelationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    name?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    widthInches?: SortOrderInput | SortOrder
    lengthInches?: SortOrderInput | SortOrder
    heightInches?: SortOrderInput | SortOrder
    diameterInches?: SortOrderInput | SortOrder
    volumeGallons?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    drainageQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    garden?: GardenOrderByWithRelationInput
    containerType?: ContainerTypeOrderByWithRelationInput
    containerPlants?: ContainerPlantOrderByRelationAggregateInput
    gardenActions?: GardenActionOrderByRelationAggregateInput
    containerHistory?: ContainerHistoryOrderByRelationAggregateInput
    previousContainers?: ContainerHistoryOrderByRelationAggregateInput
    plannedPlantings?: PlannedPlantingOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ContainerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    gardenId?: IntFilter<"Container"> | number
    containerTypeId?: IntFilter<"Container"> | number
    name?: StringNullableFilter<"Container"> | string | null
    material?: StringNullableFilter<"Container"> | string | null
    widthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    lengthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    heightInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    diameterInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionX?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"Container"> | string | null
    drainageQuality?: StringNullableFilter<"Container"> | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
    containerType?: XOR<ContainerTypeScalarRelationFilter, ContainerTypeWhereInput>
    containerPlants?: ContainerPlantListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    containerHistory?: ContainerHistoryListRelationFilter
    previousContainers?: ContainerHistoryListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type ContainerOrderByWithAggregationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    name?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    widthInches?: SortOrderInput | SortOrder
    lengthInches?: SortOrderInput | SortOrder
    heightInches?: SortOrderInput | SortOrder
    diameterInches?: SortOrderInput | SortOrder
    volumeGallons?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    drainageQuality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContainerCountOrderByAggregateInput
    _avg?: ContainerAvgOrderByAggregateInput
    _max?: ContainerMaxOrderByAggregateInput
    _min?: ContainerMinOrderByAggregateInput
    _sum?: ContainerSumOrderByAggregateInput
  }

  export type ContainerScalarWhereWithAggregatesInput = {
    AND?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    OR?: ContainerScalarWhereWithAggregatesInput[]
    NOT?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Container"> | number
    gardenId?: IntWithAggregatesFilter<"Container"> | number
    containerTypeId?: IntWithAggregatesFilter<"Container"> | number
    name?: StringNullableWithAggregatesFilter<"Container"> | string | null
    material?: StringNullableWithAggregatesFilter<"Container"> | string | null
    widthInches?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    lengthInches?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    heightInches?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    diameterInches?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionX?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableWithAggregatesFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableWithAggregatesFilter<"Container"> | string | null
    drainageQuality?: StringNullableWithAggregatesFilter<"Container"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Container"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Container"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Container"> | Date | string
  }

  export type PlantCatalogWhereInput = {
    AND?: PlantCatalogWhereInput | PlantCatalogWhereInput[]
    OR?: PlantCatalogWhereInput[]
    NOT?: PlantCatalogWhereInput | PlantCatalogWhereInput[]
    id?: IntFilter<"PlantCatalog"> | number
    commonName?: StringFilter<"PlantCatalog"> | string
    scientificName?: StringNullableFilter<"PlantCatalog"> | string | null
    plantType?: StringNullableFilter<"PlantCatalog"> | string | null
    lifeCycle?: StringNullableFilter<"PlantCatalog"> | string | null
    growthHabit?: StringNullableFilter<"PlantCatalog"> | string | null
    edible?: BoolFilter<"PlantCatalog"> | boolean
    description?: StringNullableFilter<"PlantCatalog"> | string | null
    plantingInstructions?: StringNullableFilter<"PlantCatalog"> | string | null
    careInstructions?: StringNullableFilter<"PlantCatalog"> | string | null
    daysToGerminationMin?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToGerminationMax?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToMaturityMin?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToMaturityMax?: IntNullableFilter<"PlantCatalog"> | number | null
    harvestSeason?: StringNullableFilter<"PlantCatalog"> | string | null
    heightInchesMin?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlantCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"PlantCatalog"> | Date | string
    growingConditions?: XOR<PlantGrowingConditionNullableScalarRelationFilter, PlantGrowingConditionWhereInput> | null
    climateZones?: PlantClimateZoneListRelationFilter
    varieties?: PlantVarietyListRelationFilter
    companions?: PlantCompanionListRelationFilter
    companionTo?: PlantCompanionListRelationFilter
    containerPlants?: ContainerPlantListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
  }

  export type PlantCatalogOrderByWithRelationInput = {
    id?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrderInput | SortOrder
    plantType?: SortOrderInput | SortOrder
    lifeCycle?: SortOrderInput | SortOrder
    growthHabit?: SortOrderInput | SortOrder
    edible?: SortOrder
    description?: SortOrderInput | SortOrder
    plantingInstructions?: SortOrderInput | SortOrder
    careInstructions?: SortOrderInput | SortOrder
    daysToGerminationMin?: SortOrderInput | SortOrder
    daysToGerminationMax?: SortOrderInput | SortOrder
    daysToMaturityMin?: SortOrderInput | SortOrder
    daysToMaturityMax?: SortOrderInput | SortOrder
    harvestSeason?: SortOrderInput | SortOrder
    heightInchesMin?: SortOrderInput | SortOrder
    heightInchesMax?: SortOrderInput | SortOrder
    widthInchesMin?: SortOrderInput | SortOrder
    widthInchesMax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    growingConditions?: PlantGrowingConditionOrderByWithRelationInput
    climateZones?: PlantClimateZoneOrderByRelationAggregateInput
    varieties?: PlantVarietyOrderByRelationAggregateInput
    companions?: PlantCompanionOrderByRelationAggregateInput
    companionTo?: PlantCompanionOrderByRelationAggregateInput
    containerPlants?: ContainerPlantOrderByRelationAggregateInput
    plannedPlantings?: PlannedPlantingOrderByRelationAggregateInput
  }

  export type PlantCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantCatalogWhereInput | PlantCatalogWhereInput[]
    OR?: PlantCatalogWhereInput[]
    NOT?: PlantCatalogWhereInput | PlantCatalogWhereInput[]
    commonName?: StringFilter<"PlantCatalog"> | string
    scientificName?: StringNullableFilter<"PlantCatalog"> | string | null
    plantType?: StringNullableFilter<"PlantCatalog"> | string | null
    lifeCycle?: StringNullableFilter<"PlantCatalog"> | string | null
    growthHabit?: StringNullableFilter<"PlantCatalog"> | string | null
    edible?: BoolFilter<"PlantCatalog"> | boolean
    description?: StringNullableFilter<"PlantCatalog"> | string | null
    plantingInstructions?: StringNullableFilter<"PlantCatalog"> | string | null
    careInstructions?: StringNullableFilter<"PlantCatalog"> | string | null
    daysToGerminationMin?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToGerminationMax?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToMaturityMin?: IntNullableFilter<"PlantCatalog"> | number | null
    daysToMaturityMax?: IntNullableFilter<"PlantCatalog"> | number | null
    harvestSeason?: StringNullableFilter<"PlantCatalog"> | string | null
    heightInchesMin?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: DecimalNullableFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PlantCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"PlantCatalog"> | Date | string
    growingConditions?: XOR<PlantGrowingConditionNullableScalarRelationFilter, PlantGrowingConditionWhereInput> | null
    climateZones?: PlantClimateZoneListRelationFilter
    varieties?: PlantVarietyListRelationFilter
    companions?: PlantCompanionListRelationFilter
    companionTo?: PlantCompanionListRelationFilter
    containerPlants?: ContainerPlantListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
  }, "id">

  export type PlantCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrderInput | SortOrder
    plantType?: SortOrderInput | SortOrder
    lifeCycle?: SortOrderInput | SortOrder
    growthHabit?: SortOrderInput | SortOrder
    edible?: SortOrder
    description?: SortOrderInput | SortOrder
    plantingInstructions?: SortOrderInput | SortOrder
    careInstructions?: SortOrderInput | SortOrder
    daysToGerminationMin?: SortOrderInput | SortOrder
    daysToGerminationMax?: SortOrderInput | SortOrder
    daysToMaturityMin?: SortOrderInput | SortOrder
    daysToMaturityMax?: SortOrderInput | SortOrder
    harvestSeason?: SortOrderInput | SortOrder
    heightInchesMin?: SortOrderInput | SortOrder
    heightInchesMax?: SortOrderInput | SortOrder
    widthInchesMin?: SortOrderInput | SortOrder
    widthInchesMax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlantCatalogCountOrderByAggregateInput
    _avg?: PlantCatalogAvgOrderByAggregateInput
    _max?: PlantCatalogMaxOrderByAggregateInput
    _min?: PlantCatalogMinOrderByAggregateInput
    _sum?: PlantCatalogSumOrderByAggregateInput
  }

  export type PlantCatalogScalarWhereWithAggregatesInput = {
    AND?: PlantCatalogScalarWhereWithAggregatesInput | PlantCatalogScalarWhereWithAggregatesInput[]
    OR?: PlantCatalogScalarWhereWithAggregatesInput[]
    NOT?: PlantCatalogScalarWhereWithAggregatesInput | PlantCatalogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantCatalog"> | number
    commonName?: StringWithAggregatesFilter<"PlantCatalog"> | string
    scientificName?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    plantType?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    lifeCycle?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    growthHabit?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    edible?: BoolWithAggregatesFilter<"PlantCatalog"> | boolean
    description?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    plantingInstructions?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    careInstructions?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    daysToGerminationMin?: IntNullableWithAggregatesFilter<"PlantCatalog"> | number | null
    daysToGerminationMax?: IntNullableWithAggregatesFilter<"PlantCatalog"> | number | null
    daysToMaturityMin?: IntNullableWithAggregatesFilter<"PlantCatalog"> | number | null
    daysToMaturityMax?: IntNullableWithAggregatesFilter<"PlantCatalog"> | number | null
    harvestSeason?: StringNullableWithAggregatesFilter<"PlantCatalog"> | string | null
    heightInchesMin?: DecimalNullableWithAggregatesFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: DecimalNullableWithAggregatesFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: DecimalNullableWithAggregatesFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: DecimalNullableWithAggregatesFilter<"PlantCatalog"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlantCatalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlantCatalog"> | Date | string
  }

  export type PlantGrowingConditionWhereInput = {
    AND?: PlantGrowingConditionWhereInput | PlantGrowingConditionWhereInput[]
    OR?: PlantGrowingConditionWhereInput[]
    NOT?: PlantGrowingConditionWhereInput | PlantGrowingConditionWhereInput[]
    id?: IntFilter<"PlantGrowingCondition"> | number
    plantId?: IntFilter<"PlantGrowingCondition"> | number
    minTemperatureF?: IntNullableFilter<"PlantGrowingCondition"> | number | null
    maxTemperatureF?: IntNullableFilter<"PlantGrowingCondition"> | number | null
    sunlightNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    waterNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    soilPhMin?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    fertilizerNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    spacingInches?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFilter<"PlantGrowingCondition"> | boolean
    minContainerDepthInches?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }

  export type PlantGrowingConditionOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrderInput | SortOrder
    maxTemperatureF?: SortOrderInput | SortOrder
    sunlightNeeds?: SortOrderInput | SortOrder
    waterNeeds?: SortOrderInput | SortOrder
    soilPhMin?: SortOrderInput | SortOrder
    soilPhMax?: SortOrderInput | SortOrder
    soilTypePreference?: SortOrderInput | SortOrder
    fertilizerNeeds?: SortOrderInput | SortOrder
    spacingInches?: SortOrderInput | SortOrder
    containerSuitable?: SortOrder
    minContainerDepthInches?: SortOrderInput | SortOrder
    minContainerVolumeGallons?: SortOrderInput | SortOrder
    plant?: PlantCatalogOrderByWithRelationInput
  }

  export type PlantGrowingConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    plantId?: number
    AND?: PlantGrowingConditionWhereInput | PlantGrowingConditionWhereInput[]
    OR?: PlantGrowingConditionWhereInput[]
    NOT?: PlantGrowingConditionWhereInput | PlantGrowingConditionWhereInput[]
    minTemperatureF?: IntNullableFilter<"PlantGrowingCondition"> | number | null
    maxTemperatureF?: IntNullableFilter<"PlantGrowingCondition"> | number | null
    sunlightNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    waterNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    soilPhMin?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    fertilizerNeeds?: StringNullableFilter<"PlantGrowingCondition"> | string | null
    spacingInches?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFilter<"PlantGrowingCondition"> | boolean
    minContainerDepthInches?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: DecimalNullableFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }, "id" | "plantId">

  export type PlantGrowingConditionOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrderInput | SortOrder
    maxTemperatureF?: SortOrderInput | SortOrder
    sunlightNeeds?: SortOrderInput | SortOrder
    waterNeeds?: SortOrderInput | SortOrder
    soilPhMin?: SortOrderInput | SortOrder
    soilPhMax?: SortOrderInput | SortOrder
    soilTypePreference?: SortOrderInput | SortOrder
    fertilizerNeeds?: SortOrderInput | SortOrder
    spacingInches?: SortOrderInput | SortOrder
    containerSuitable?: SortOrder
    minContainerDepthInches?: SortOrderInput | SortOrder
    minContainerVolumeGallons?: SortOrderInput | SortOrder
    _count?: PlantGrowingConditionCountOrderByAggregateInput
    _avg?: PlantGrowingConditionAvgOrderByAggregateInput
    _max?: PlantGrowingConditionMaxOrderByAggregateInput
    _min?: PlantGrowingConditionMinOrderByAggregateInput
    _sum?: PlantGrowingConditionSumOrderByAggregateInput
  }

  export type PlantGrowingConditionScalarWhereWithAggregatesInput = {
    AND?: PlantGrowingConditionScalarWhereWithAggregatesInput | PlantGrowingConditionScalarWhereWithAggregatesInput[]
    OR?: PlantGrowingConditionScalarWhereWithAggregatesInput[]
    NOT?: PlantGrowingConditionScalarWhereWithAggregatesInput | PlantGrowingConditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantGrowingCondition"> | number
    plantId?: IntWithAggregatesFilter<"PlantGrowingCondition"> | number
    minTemperatureF?: IntNullableWithAggregatesFilter<"PlantGrowingCondition"> | number | null
    maxTemperatureF?: IntNullableWithAggregatesFilter<"PlantGrowingCondition"> | number | null
    sunlightNeeds?: StringNullableWithAggregatesFilter<"PlantGrowingCondition"> | string | null
    waterNeeds?: StringNullableWithAggregatesFilter<"PlantGrowingCondition"> | string | null
    soilPhMin?: DecimalNullableWithAggregatesFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: DecimalNullableWithAggregatesFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: StringNullableWithAggregatesFilter<"PlantGrowingCondition"> | string | null
    fertilizerNeeds?: StringNullableWithAggregatesFilter<"PlantGrowingCondition"> | string | null
    spacingInches?: DecimalNullableWithAggregatesFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolWithAggregatesFilter<"PlantGrowingCondition"> | boolean
    minContainerDepthInches?: DecimalNullableWithAggregatesFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: DecimalNullableWithAggregatesFilter<"PlantGrowingCondition"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantClimateZoneWhereInput = {
    AND?: PlantClimateZoneWhereInput | PlantClimateZoneWhereInput[]
    OR?: PlantClimateZoneWhereInput[]
    NOT?: PlantClimateZoneWhereInput | PlantClimateZoneWhereInput[]
    id?: IntFilter<"PlantClimateZone"> | number
    plantId?: IntFilter<"PlantClimateZone"> | number
    climateZone?: StringFilter<"PlantClimateZone"> | string
    notes?: StringNullableFilter<"PlantClimateZone"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }

  export type PlantClimateZoneOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    climateZone?: SortOrder
    notes?: SortOrderInput | SortOrder
    plant?: PlantCatalogOrderByWithRelationInput
  }

  export type PlantClimateZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantClimateZoneWhereInput | PlantClimateZoneWhereInput[]
    OR?: PlantClimateZoneWhereInput[]
    NOT?: PlantClimateZoneWhereInput | PlantClimateZoneWhereInput[]
    plantId?: IntFilter<"PlantClimateZone"> | number
    climateZone?: StringFilter<"PlantClimateZone"> | string
    notes?: StringNullableFilter<"PlantClimateZone"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }, "id">

  export type PlantClimateZoneOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    climateZone?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PlantClimateZoneCountOrderByAggregateInput
    _avg?: PlantClimateZoneAvgOrderByAggregateInput
    _max?: PlantClimateZoneMaxOrderByAggregateInput
    _min?: PlantClimateZoneMinOrderByAggregateInput
    _sum?: PlantClimateZoneSumOrderByAggregateInput
  }

  export type PlantClimateZoneScalarWhereWithAggregatesInput = {
    AND?: PlantClimateZoneScalarWhereWithAggregatesInput | PlantClimateZoneScalarWhereWithAggregatesInput[]
    OR?: PlantClimateZoneScalarWhereWithAggregatesInput[]
    NOT?: PlantClimateZoneScalarWhereWithAggregatesInput | PlantClimateZoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantClimateZone"> | number
    plantId?: IntWithAggregatesFilter<"PlantClimateZone"> | number
    climateZone?: StringWithAggregatesFilter<"PlantClimateZone"> | string
    notes?: StringNullableWithAggregatesFilter<"PlantClimateZone"> | string | null
  }

  export type PlantVarietyWhereInput = {
    AND?: PlantVarietyWhereInput | PlantVarietyWhereInput[]
    OR?: PlantVarietyWhereInput[]
    NOT?: PlantVarietyWhereInput | PlantVarietyWhereInput[]
    id?: IntFilter<"PlantVariety"> | number
    plantId?: IntFilter<"PlantVariety"> | number
    varietyName?: StringFilter<"PlantVariety"> | string
    description?: StringNullableFilter<"PlantVariety"> | string | null
    specificTraits?: StringNullableFilter<"PlantVariety"> | string | null
    specificCareNeeds?: StringNullableFilter<"PlantVariety"> | string | null
    imageUrl?: StringNullableFilter<"PlantVariety"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    containerPlants?: ContainerPlantListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
  }

  export type PlantVarietyOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    varietyName?: SortOrder
    description?: SortOrderInput | SortOrder
    specificTraits?: SortOrderInput | SortOrder
    specificCareNeeds?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    plant?: PlantCatalogOrderByWithRelationInput
    containerPlants?: ContainerPlantOrderByRelationAggregateInput
    plannedPlantings?: PlannedPlantingOrderByRelationAggregateInput
  }

  export type PlantVarietyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantVarietyWhereInput | PlantVarietyWhereInput[]
    OR?: PlantVarietyWhereInput[]
    NOT?: PlantVarietyWhereInput | PlantVarietyWhereInput[]
    plantId?: IntFilter<"PlantVariety"> | number
    varietyName?: StringFilter<"PlantVariety"> | string
    description?: StringNullableFilter<"PlantVariety"> | string | null
    specificTraits?: StringNullableFilter<"PlantVariety"> | string | null
    specificCareNeeds?: StringNullableFilter<"PlantVariety"> | string | null
    imageUrl?: StringNullableFilter<"PlantVariety"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    containerPlants?: ContainerPlantListRelationFilter
    plannedPlantings?: PlannedPlantingListRelationFilter
  }, "id">

  export type PlantVarietyOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    varietyName?: SortOrder
    description?: SortOrderInput | SortOrder
    specificTraits?: SortOrderInput | SortOrder
    specificCareNeeds?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: PlantVarietyCountOrderByAggregateInput
    _avg?: PlantVarietyAvgOrderByAggregateInput
    _max?: PlantVarietyMaxOrderByAggregateInput
    _min?: PlantVarietyMinOrderByAggregateInput
    _sum?: PlantVarietySumOrderByAggregateInput
  }

  export type PlantVarietyScalarWhereWithAggregatesInput = {
    AND?: PlantVarietyScalarWhereWithAggregatesInput | PlantVarietyScalarWhereWithAggregatesInput[]
    OR?: PlantVarietyScalarWhereWithAggregatesInput[]
    NOT?: PlantVarietyScalarWhereWithAggregatesInput | PlantVarietyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantVariety"> | number
    plantId?: IntWithAggregatesFilter<"PlantVariety"> | number
    varietyName?: StringWithAggregatesFilter<"PlantVariety"> | string
    description?: StringNullableWithAggregatesFilter<"PlantVariety"> | string | null
    specificTraits?: StringNullableWithAggregatesFilter<"PlantVariety"> | string | null
    specificCareNeeds?: StringNullableWithAggregatesFilter<"PlantVariety"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"PlantVariety"> | string | null
  }

  export type PlantCompanionWhereInput = {
    AND?: PlantCompanionWhereInput | PlantCompanionWhereInput[]
    OR?: PlantCompanionWhereInput[]
    NOT?: PlantCompanionWhereInput | PlantCompanionWhereInput[]
    id?: IntFilter<"PlantCompanion"> | number
    plantId?: IntFilter<"PlantCompanion"> | number
    companionPlantId?: IntFilter<"PlantCompanion"> | number
    relationshipType?: StringFilter<"PlantCompanion"> | string
    effectDescription?: StringNullableFilter<"PlantCompanion"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    companionPlant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }

  export type PlantCompanionOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
    relationshipType?: SortOrder
    effectDescription?: SortOrderInput | SortOrder
    plant?: PlantCatalogOrderByWithRelationInput
    companionPlant?: PlantCatalogOrderByWithRelationInput
  }

  export type PlantCompanionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantCompanionWhereInput | PlantCompanionWhereInput[]
    OR?: PlantCompanionWhereInput[]
    NOT?: PlantCompanionWhereInput | PlantCompanionWhereInput[]
    plantId?: IntFilter<"PlantCompanion"> | number
    companionPlantId?: IntFilter<"PlantCompanion"> | number
    relationshipType?: StringFilter<"PlantCompanion"> | string
    effectDescription?: StringNullableFilter<"PlantCompanion"> | string | null
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    companionPlant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
  }, "id">

  export type PlantCompanionOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
    relationshipType?: SortOrder
    effectDescription?: SortOrderInput | SortOrder
    _count?: PlantCompanionCountOrderByAggregateInput
    _avg?: PlantCompanionAvgOrderByAggregateInput
    _max?: PlantCompanionMaxOrderByAggregateInput
    _min?: PlantCompanionMinOrderByAggregateInput
    _sum?: PlantCompanionSumOrderByAggregateInput
  }

  export type PlantCompanionScalarWhereWithAggregatesInput = {
    AND?: PlantCompanionScalarWhereWithAggregatesInput | PlantCompanionScalarWhereWithAggregatesInput[]
    OR?: PlantCompanionScalarWhereWithAggregatesInput[]
    NOT?: PlantCompanionScalarWhereWithAggregatesInput | PlantCompanionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantCompanion"> | number
    plantId?: IntWithAggregatesFilter<"PlantCompanion"> | number
    companionPlantId?: IntWithAggregatesFilter<"PlantCompanion"> | number
    relationshipType?: StringWithAggregatesFilter<"PlantCompanion"> | string
    effectDescription?: StringNullableWithAggregatesFilter<"PlantCompanion"> | string | null
  }

  export type ContainerPlantWhereInput = {
    AND?: ContainerPlantWhereInput | ContainerPlantWhereInput[]
    OR?: ContainerPlantWhereInput[]
    NOT?: ContainerPlantWhereInput | ContainerPlantWhereInput[]
    id?: IntFilter<"ContainerPlant"> | number
    containerId?: IntFilter<"ContainerPlant"> | number
    plantId?: IntFilter<"ContainerPlant"> | number
    varietyId?: IntNullableFilter<"ContainerPlant"> | number | null
    quantity?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFilter<"ContainerPlant"> | Date | string
    initialStage?: StringFilter<"ContainerPlant"> | string
    currentStage?: StringFilter<"ContainerPlant"> | string
    status?: StringFilter<"ContainerPlant"> | string
    positionX?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: DateTimeNullableFilter<"ContainerPlant"> | Date | string | null
    notes?: StringNullableFilter<"ContainerPlant"> | string | null
    createdAt?: DateTimeFilter<"ContainerPlant"> | Date | string
    updatedAt?: DateTimeFilter<"ContainerPlant"> | Date | string
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    variety?: XOR<PlantVarietyNullableScalarRelationFilter, PlantVarietyWhereInput> | null
    growthStages?: PlantGrowthStageListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    harvests?: HarvestListRelationFilter
    movementHistory?: PlantMovementHistoryListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ContainerPlantOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    plantDate?: SortOrder
    initialStage?: SortOrder
    currentStage?: SortOrder
    status?: SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    expectedHarvestDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    container?: ContainerOrderByWithRelationInput
    plant?: PlantCatalogOrderByWithRelationInput
    variety?: PlantVarietyOrderByWithRelationInput
    growthStages?: PlantGrowthStageOrderByRelationAggregateInput
    gardenActions?: GardenActionOrderByRelationAggregateInput
    harvests?: HarvestOrderByRelationAggregateInput
    movementHistory?: PlantMovementHistoryOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ContainerPlantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContainerPlantWhereInput | ContainerPlantWhereInput[]
    OR?: ContainerPlantWhereInput[]
    NOT?: ContainerPlantWhereInput | ContainerPlantWhereInput[]
    containerId?: IntFilter<"ContainerPlant"> | number
    plantId?: IntFilter<"ContainerPlant"> | number
    varietyId?: IntNullableFilter<"ContainerPlant"> | number | null
    quantity?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFilter<"ContainerPlant"> | Date | string
    initialStage?: StringFilter<"ContainerPlant"> | string
    currentStage?: StringFilter<"ContainerPlant"> | string
    status?: StringFilter<"ContainerPlant"> | string
    positionX?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: DateTimeNullableFilter<"ContainerPlant"> | Date | string | null
    notes?: StringNullableFilter<"ContainerPlant"> | string | null
    createdAt?: DateTimeFilter<"ContainerPlant"> | Date | string
    updatedAt?: DateTimeFilter<"ContainerPlant"> | Date | string
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    variety?: XOR<PlantVarietyNullableScalarRelationFilter, PlantVarietyWhereInput> | null
    growthStages?: PlantGrowthStageListRelationFilter
    gardenActions?: GardenActionListRelationFilter
    harvests?: HarvestListRelationFilter
    movementHistory?: PlantMovementHistoryListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type ContainerPlantOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    plantDate?: SortOrder
    initialStage?: SortOrder
    currentStage?: SortOrder
    status?: SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    expectedHarvestDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContainerPlantCountOrderByAggregateInput
    _avg?: ContainerPlantAvgOrderByAggregateInput
    _max?: ContainerPlantMaxOrderByAggregateInput
    _min?: ContainerPlantMinOrderByAggregateInput
    _sum?: ContainerPlantSumOrderByAggregateInput
  }

  export type ContainerPlantScalarWhereWithAggregatesInput = {
    AND?: ContainerPlantScalarWhereWithAggregatesInput | ContainerPlantScalarWhereWithAggregatesInput[]
    OR?: ContainerPlantScalarWhereWithAggregatesInput[]
    NOT?: ContainerPlantScalarWhereWithAggregatesInput | ContainerPlantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContainerPlant"> | number
    containerId?: IntWithAggregatesFilter<"ContainerPlant"> | number
    plantId?: IntWithAggregatesFilter<"ContainerPlant"> | number
    varietyId?: IntNullableWithAggregatesFilter<"ContainerPlant"> | number | null
    quantity?: DecimalNullableWithAggregatesFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeWithAggregatesFilter<"ContainerPlant"> | Date | string
    initialStage?: StringWithAggregatesFilter<"ContainerPlant"> | string
    currentStage?: StringWithAggregatesFilter<"ContainerPlant"> | string
    status?: StringWithAggregatesFilter<"ContainerPlant"> | string
    positionX?: DecimalNullableWithAggregatesFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableWithAggregatesFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: DateTimeNullableWithAggregatesFilter<"ContainerPlant"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ContainerPlant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContainerPlant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContainerPlant"> | Date | string
  }

  export type PlantGrowthStageWhereInput = {
    AND?: PlantGrowthStageWhereInput | PlantGrowthStageWhereInput[]
    OR?: PlantGrowthStageWhereInput[]
    NOT?: PlantGrowthStageWhereInput | PlantGrowthStageWhereInput[]
    id?: IntFilter<"PlantGrowthStage"> | number
    containerPlantId?: IntFilter<"PlantGrowthStage"> | number
    stageName?: StringFilter<"PlantGrowthStage"> | string
    startDate?: DateTimeFilter<"PlantGrowthStage"> | Date | string
    endDate?: DateTimeNullableFilter<"PlantGrowthStage"> | Date | string | null
    notes?: StringNullableFilter<"PlantGrowthStage"> | string | null
    imageUrl?: StringNullableFilter<"PlantGrowthStage"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }

  export type PlantGrowthStageOrderByWithRelationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    stageName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    containerPlant?: ContainerPlantOrderByWithRelationInput
  }

  export type PlantGrowthStageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantGrowthStageWhereInput | PlantGrowthStageWhereInput[]
    OR?: PlantGrowthStageWhereInput[]
    NOT?: PlantGrowthStageWhereInput | PlantGrowthStageWhereInput[]
    containerPlantId?: IntFilter<"PlantGrowthStage"> | number
    stageName?: StringFilter<"PlantGrowthStage"> | string
    startDate?: DateTimeFilter<"PlantGrowthStage"> | Date | string
    endDate?: DateTimeNullableFilter<"PlantGrowthStage"> | Date | string | null
    notes?: StringNullableFilter<"PlantGrowthStage"> | string | null
    imageUrl?: StringNullableFilter<"PlantGrowthStage"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }, "id">

  export type PlantGrowthStageOrderByWithAggregationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    stageName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: PlantGrowthStageCountOrderByAggregateInput
    _avg?: PlantGrowthStageAvgOrderByAggregateInput
    _max?: PlantGrowthStageMaxOrderByAggregateInput
    _min?: PlantGrowthStageMinOrderByAggregateInput
    _sum?: PlantGrowthStageSumOrderByAggregateInput
  }

  export type PlantGrowthStageScalarWhereWithAggregatesInput = {
    AND?: PlantGrowthStageScalarWhereWithAggregatesInput | PlantGrowthStageScalarWhereWithAggregatesInput[]
    OR?: PlantGrowthStageScalarWhereWithAggregatesInput[]
    NOT?: PlantGrowthStageScalarWhereWithAggregatesInput | PlantGrowthStageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantGrowthStage"> | number
    containerPlantId?: IntWithAggregatesFilter<"PlantGrowthStage"> | number
    stageName?: StringWithAggregatesFilter<"PlantGrowthStage"> | string
    startDate?: DateTimeWithAggregatesFilter<"PlantGrowthStage"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"PlantGrowthStage"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PlantGrowthStage"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"PlantGrowthStage"> | string | null
  }

  export type ActionTypeWhereInput = {
    AND?: ActionTypeWhereInput | ActionTypeWhereInput[]
    OR?: ActionTypeWhereInput[]
    NOT?: ActionTypeWhereInput | ActionTypeWhereInput[]
    id?: IntFilter<"ActionType"> | number
    name?: StringFilter<"ActionType"> | string
    description?: StringNullableFilter<"ActionType"> | string | null
    category?: StringNullableFilter<"ActionType"> | string | null
    actions?: GardenActionListRelationFilter
  }

  export type ActionTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    actions?: GardenActionOrderByRelationAggregateInput
  }

  export type ActionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActionTypeWhereInput | ActionTypeWhereInput[]
    OR?: ActionTypeWhereInput[]
    NOT?: ActionTypeWhereInput | ActionTypeWhereInput[]
    name?: StringFilter<"ActionType"> | string
    description?: StringNullableFilter<"ActionType"> | string | null
    category?: StringNullableFilter<"ActionType"> | string | null
    actions?: GardenActionListRelationFilter
  }, "id">

  export type ActionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    _count?: ActionTypeCountOrderByAggregateInput
    _avg?: ActionTypeAvgOrderByAggregateInput
    _max?: ActionTypeMaxOrderByAggregateInput
    _min?: ActionTypeMinOrderByAggregateInput
    _sum?: ActionTypeSumOrderByAggregateInput
  }

  export type ActionTypeScalarWhereWithAggregatesInput = {
    AND?: ActionTypeScalarWhereWithAggregatesInput | ActionTypeScalarWhereWithAggregatesInput[]
    OR?: ActionTypeScalarWhereWithAggregatesInput[]
    NOT?: ActionTypeScalarWhereWithAggregatesInput | ActionTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActionType"> | number
    name?: StringWithAggregatesFilter<"ActionType"> | string
    description?: StringNullableWithAggregatesFilter<"ActionType"> | string | null
    category?: StringNullableWithAggregatesFilter<"ActionType"> | string | null
  }

  export type GardenActionWhereInput = {
    AND?: GardenActionWhereInput | GardenActionWhereInput[]
    OR?: GardenActionWhereInput[]
    NOT?: GardenActionWhereInput | GardenActionWhereInput[]
    id?: IntFilter<"GardenAction"> | number
    actionTypeId?: IntFilter<"GardenAction"> | number
    userId?: StringFilter<"GardenAction"> | string
    gardenId?: IntNullableFilter<"GardenAction"> | number | null
    containerId?: IntNullableFilter<"GardenAction"> | number | null
    containerPlantId?: IntNullableFilter<"GardenAction"> | number | null
    actionDate?: DateTimeFilter<"GardenAction"> | Date | string
    quantity?: DecimalNullableFilter<"GardenAction"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"GardenAction"> | string | null
    notes?: StringNullableFilter<"GardenAction"> | string | null
    successRating?: IntNullableFilter<"GardenAction"> | number | null
    createdAt?: DateTimeFilter<"GardenAction"> | Date | string
    actionType?: XOR<ActionTypeScalarRelationFilter, ActionTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    garden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    container?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    containerPlant?: XOR<ContainerPlantNullableScalarRelationFilter, ContainerPlantWhereInput> | null
  }

  export type GardenActionOrderByWithRelationInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrderInput | SortOrder
    containerId?: SortOrderInput | SortOrder
    containerPlantId?: SortOrderInput | SortOrder
    actionDate?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    successRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actionType?: ActionTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    garden?: GardenOrderByWithRelationInput
    container?: ContainerOrderByWithRelationInput
    containerPlant?: ContainerPlantOrderByWithRelationInput
  }

  export type GardenActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GardenActionWhereInput | GardenActionWhereInput[]
    OR?: GardenActionWhereInput[]
    NOT?: GardenActionWhereInput | GardenActionWhereInput[]
    actionTypeId?: IntFilter<"GardenAction"> | number
    userId?: StringFilter<"GardenAction"> | string
    gardenId?: IntNullableFilter<"GardenAction"> | number | null
    containerId?: IntNullableFilter<"GardenAction"> | number | null
    containerPlantId?: IntNullableFilter<"GardenAction"> | number | null
    actionDate?: DateTimeFilter<"GardenAction"> | Date | string
    quantity?: DecimalNullableFilter<"GardenAction"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"GardenAction"> | string | null
    notes?: StringNullableFilter<"GardenAction"> | string | null
    successRating?: IntNullableFilter<"GardenAction"> | number | null
    createdAt?: DateTimeFilter<"GardenAction"> | Date | string
    actionType?: XOR<ActionTypeScalarRelationFilter, ActionTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    garden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    container?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    containerPlant?: XOR<ContainerPlantNullableScalarRelationFilter, ContainerPlantWhereInput> | null
  }, "id">

  export type GardenActionOrderByWithAggregationInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrderInput | SortOrder
    containerId?: SortOrderInput | SortOrder
    containerPlantId?: SortOrderInput | SortOrder
    actionDate?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    successRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GardenActionCountOrderByAggregateInput
    _avg?: GardenActionAvgOrderByAggregateInput
    _max?: GardenActionMaxOrderByAggregateInput
    _min?: GardenActionMinOrderByAggregateInput
    _sum?: GardenActionSumOrderByAggregateInput
  }

  export type GardenActionScalarWhereWithAggregatesInput = {
    AND?: GardenActionScalarWhereWithAggregatesInput | GardenActionScalarWhereWithAggregatesInput[]
    OR?: GardenActionScalarWhereWithAggregatesInput[]
    NOT?: GardenActionScalarWhereWithAggregatesInput | GardenActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GardenAction"> | number
    actionTypeId?: IntWithAggregatesFilter<"GardenAction"> | number
    userId?: StringWithAggregatesFilter<"GardenAction"> | string
    gardenId?: IntNullableWithAggregatesFilter<"GardenAction"> | number | null
    containerId?: IntNullableWithAggregatesFilter<"GardenAction"> | number | null
    containerPlantId?: IntNullableWithAggregatesFilter<"GardenAction"> | number | null
    actionDate?: DateTimeWithAggregatesFilter<"GardenAction"> | Date | string
    quantity?: DecimalNullableWithAggregatesFilter<"GardenAction"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"GardenAction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"GardenAction"> | string | null
    successRating?: IntNullableWithAggregatesFilter<"GardenAction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GardenAction"> | Date | string
  }

  export type HarvestWhereInput = {
    AND?: HarvestWhereInput | HarvestWhereInput[]
    OR?: HarvestWhereInput[]
    NOT?: HarvestWhereInput | HarvestWhereInput[]
    id?: IntFilter<"Harvest"> | number
    containerPlantId?: IntFilter<"Harvest"> | number
    harvestDate?: DateTimeFilter<"Harvest"> | Date | string
    quantity?: DecimalNullableFilter<"Harvest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Harvest"> | string | null
    qualityRating?: IntNullableFilter<"Harvest"> | number | null
    notes?: StringNullableFilter<"Harvest"> | string | null
    imageUrl?: StringNullableFilter<"Harvest"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }

  export type HarvestOrderByWithRelationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    harvestDate?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    qualityRating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    containerPlant?: ContainerPlantOrderByWithRelationInput
  }

  export type HarvestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HarvestWhereInput | HarvestWhereInput[]
    OR?: HarvestWhereInput[]
    NOT?: HarvestWhereInput | HarvestWhereInput[]
    containerPlantId?: IntFilter<"Harvest"> | number
    harvestDate?: DateTimeFilter<"Harvest"> | Date | string
    quantity?: DecimalNullableFilter<"Harvest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Harvest"> | string | null
    qualityRating?: IntNullableFilter<"Harvest"> | number | null
    notes?: StringNullableFilter<"Harvest"> | string | null
    imageUrl?: StringNullableFilter<"Harvest"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }, "id">

  export type HarvestOrderByWithAggregationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    harvestDate?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    qualityRating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: HarvestCountOrderByAggregateInput
    _avg?: HarvestAvgOrderByAggregateInput
    _max?: HarvestMaxOrderByAggregateInput
    _min?: HarvestMinOrderByAggregateInput
    _sum?: HarvestSumOrderByAggregateInput
  }

  export type HarvestScalarWhereWithAggregatesInput = {
    AND?: HarvestScalarWhereWithAggregatesInput | HarvestScalarWhereWithAggregatesInput[]
    OR?: HarvestScalarWhereWithAggregatesInput[]
    NOT?: HarvestScalarWhereWithAggregatesInput | HarvestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Harvest"> | number
    containerPlantId?: IntWithAggregatesFilter<"Harvest"> | number
    harvestDate?: DateTimeWithAggregatesFilter<"Harvest"> | Date | string
    quantity?: DecimalNullableWithAggregatesFilter<"Harvest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"Harvest"> | string | null
    qualityRating?: IntNullableWithAggregatesFilter<"Harvest"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Harvest"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Harvest"> | string | null
  }

  export type ContainerHistoryWhereInput = {
    AND?: ContainerHistoryWhereInput | ContainerHistoryWhereInput[]
    OR?: ContainerHistoryWhereInput[]
    NOT?: ContainerHistoryWhereInput | ContainerHistoryWhereInput[]
    id?: IntFilter<"ContainerHistory"> | number
    containerId?: IntFilter<"ContainerHistory"> | number
    previousContainerId?: IntNullableFilter<"ContainerHistory"> | number | null
    previousGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    newGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    moveDate?: DateTimeFilter<"ContainerHistory"> | Date | string
    reason?: StringNullableFilter<"ContainerHistory"> | string | null
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    previousContainer?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    previousGarden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    newGarden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
  }

  export type ContainerHistoryOrderByWithRelationInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrderInput | SortOrder
    previousGardenId?: SortOrderInput | SortOrder
    newGardenId?: SortOrderInput | SortOrder
    moveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    container?: ContainerOrderByWithRelationInput
    previousContainer?: ContainerOrderByWithRelationInput
    previousGarden?: GardenOrderByWithRelationInput
    newGarden?: GardenOrderByWithRelationInput
  }

  export type ContainerHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContainerHistoryWhereInput | ContainerHistoryWhereInput[]
    OR?: ContainerHistoryWhereInput[]
    NOT?: ContainerHistoryWhereInput | ContainerHistoryWhereInput[]
    containerId?: IntFilter<"ContainerHistory"> | number
    previousContainerId?: IntNullableFilter<"ContainerHistory"> | number | null
    previousGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    newGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    moveDate?: DateTimeFilter<"ContainerHistory"> | Date | string
    reason?: StringNullableFilter<"ContainerHistory"> | string | null
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    previousContainer?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    previousGarden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    newGarden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
  }, "id">

  export type ContainerHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrderInput | SortOrder
    previousGardenId?: SortOrderInput | SortOrder
    newGardenId?: SortOrderInput | SortOrder
    moveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: ContainerHistoryCountOrderByAggregateInput
    _avg?: ContainerHistoryAvgOrderByAggregateInput
    _max?: ContainerHistoryMaxOrderByAggregateInput
    _min?: ContainerHistoryMinOrderByAggregateInput
    _sum?: ContainerHistorySumOrderByAggregateInput
  }

  export type ContainerHistoryScalarWhereWithAggregatesInput = {
    AND?: ContainerHistoryScalarWhereWithAggregatesInput | ContainerHistoryScalarWhereWithAggregatesInput[]
    OR?: ContainerHistoryScalarWhereWithAggregatesInput[]
    NOT?: ContainerHistoryScalarWhereWithAggregatesInput | ContainerHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContainerHistory"> | number
    containerId?: IntWithAggregatesFilter<"ContainerHistory"> | number
    previousContainerId?: IntNullableWithAggregatesFilter<"ContainerHistory"> | number | null
    previousGardenId?: IntNullableWithAggregatesFilter<"ContainerHistory"> | number | null
    newGardenId?: IntNullableWithAggregatesFilter<"ContainerHistory"> | number | null
    moveDate?: DateTimeWithAggregatesFilter<"ContainerHistory"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"ContainerHistory"> | string | null
  }

  export type PlantMovementHistoryWhereInput = {
    AND?: PlantMovementHistoryWhereInput | PlantMovementHistoryWhereInput[]
    OR?: PlantMovementHistoryWhereInput[]
    NOT?: PlantMovementHistoryWhereInput | PlantMovementHistoryWhereInput[]
    id?: IntFilter<"PlantMovementHistory"> | number
    containerPlantId?: IntFilter<"PlantMovementHistory"> | number
    previousContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    newContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    moveDate?: DateTimeFilter<"PlantMovementHistory"> | Date | string
    reason?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionBefore?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionAfter?: StringNullableFilter<"PlantMovementHistory"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }

  export type PlantMovementHistoryOrderByWithRelationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrderInput | SortOrder
    newContainerId?: SortOrderInput | SortOrder
    moveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    plantConditionBefore?: SortOrderInput | SortOrder
    plantConditionAfter?: SortOrderInput | SortOrder
    containerPlant?: ContainerPlantOrderByWithRelationInput
  }

  export type PlantMovementHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantMovementHistoryWhereInput | PlantMovementHistoryWhereInput[]
    OR?: PlantMovementHistoryWhereInput[]
    NOT?: PlantMovementHistoryWhereInput | PlantMovementHistoryWhereInput[]
    containerPlantId?: IntFilter<"PlantMovementHistory"> | number
    previousContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    newContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    moveDate?: DateTimeFilter<"PlantMovementHistory"> | Date | string
    reason?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionBefore?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionAfter?: StringNullableFilter<"PlantMovementHistory"> | string | null
    containerPlant?: XOR<ContainerPlantScalarRelationFilter, ContainerPlantWhereInput>
  }, "id">

  export type PlantMovementHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrderInput | SortOrder
    newContainerId?: SortOrderInput | SortOrder
    moveDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    plantConditionBefore?: SortOrderInput | SortOrder
    plantConditionAfter?: SortOrderInput | SortOrder
    _count?: PlantMovementHistoryCountOrderByAggregateInput
    _avg?: PlantMovementHistoryAvgOrderByAggregateInput
    _max?: PlantMovementHistoryMaxOrderByAggregateInput
    _min?: PlantMovementHistoryMinOrderByAggregateInput
    _sum?: PlantMovementHistorySumOrderByAggregateInput
  }

  export type PlantMovementHistoryScalarWhereWithAggregatesInput = {
    AND?: PlantMovementHistoryScalarWhereWithAggregatesInput | PlantMovementHistoryScalarWhereWithAggregatesInput[]
    OR?: PlantMovementHistoryScalarWhereWithAggregatesInput[]
    NOT?: PlantMovementHistoryScalarWhereWithAggregatesInput | PlantMovementHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlantMovementHistory"> | number
    containerPlantId?: IntWithAggregatesFilter<"PlantMovementHistory"> | number
    previousContainerId?: IntNullableWithAggregatesFilter<"PlantMovementHistory"> | number | null
    newContainerId?: IntNullableWithAggregatesFilter<"PlantMovementHistory"> | number | null
    moveDate?: DateTimeWithAggregatesFilter<"PlantMovementHistory"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"PlantMovementHistory"> | string | null
    plantConditionBefore?: StringNullableWithAggregatesFilter<"PlantMovementHistory"> | string | null
    plantConditionAfter?: StringNullableWithAggregatesFilter<"PlantMovementHistory"> | string | null
  }

  export type SeasonalPlanWhereInput = {
    AND?: SeasonalPlanWhereInput | SeasonalPlanWhereInput[]
    OR?: SeasonalPlanWhereInput[]
    NOT?: SeasonalPlanWhereInput | SeasonalPlanWhereInput[]
    id?: IntFilter<"SeasonalPlan"> | number
    gardenId?: IntFilter<"SeasonalPlan"> | number
    season?: StringFilter<"SeasonalPlan"> | string
    year?: IntFilter<"SeasonalPlan"> | number
    description?: StringNullableFilter<"SeasonalPlan"> | string | null
    createdAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
    plantings?: PlannedPlantingListRelationFilter
  }

  export type SeasonalPlanOrderByWithRelationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    season?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    garden?: GardenOrderByWithRelationInput
    plantings?: PlannedPlantingOrderByRelationAggregateInput
  }

  export type SeasonalPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeasonalPlanWhereInput | SeasonalPlanWhereInput[]
    OR?: SeasonalPlanWhereInput[]
    NOT?: SeasonalPlanWhereInput | SeasonalPlanWhereInput[]
    gardenId?: IntFilter<"SeasonalPlan"> | number
    season?: StringFilter<"SeasonalPlan"> | string
    year?: IntFilter<"SeasonalPlan"> | number
    description?: StringNullableFilter<"SeasonalPlan"> | string | null
    createdAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
    garden?: XOR<GardenScalarRelationFilter, GardenWhereInput>
    plantings?: PlannedPlantingListRelationFilter
  }, "id">

  export type SeasonalPlanOrderByWithAggregationInput = {
    id?: SortOrder
    gardenId?: SortOrder
    season?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeasonalPlanCountOrderByAggregateInput
    _avg?: SeasonalPlanAvgOrderByAggregateInput
    _max?: SeasonalPlanMaxOrderByAggregateInput
    _min?: SeasonalPlanMinOrderByAggregateInput
    _sum?: SeasonalPlanSumOrderByAggregateInput
  }

  export type SeasonalPlanScalarWhereWithAggregatesInput = {
    AND?: SeasonalPlanScalarWhereWithAggregatesInput | SeasonalPlanScalarWhereWithAggregatesInput[]
    OR?: SeasonalPlanScalarWhereWithAggregatesInput[]
    NOT?: SeasonalPlanScalarWhereWithAggregatesInput | SeasonalPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeasonalPlan"> | number
    gardenId?: IntWithAggregatesFilter<"SeasonalPlan"> | number
    season?: StringWithAggregatesFilter<"SeasonalPlan"> | string
    year?: IntWithAggregatesFilter<"SeasonalPlan"> | number
    description?: StringNullableWithAggregatesFilter<"SeasonalPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SeasonalPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeasonalPlan"> | Date | string
  }

  export type PlannedPlantingWhereInput = {
    AND?: PlannedPlantingWhereInput | PlannedPlantingWhereInput[]
    OR?: PlannedPlantingWhereInput[]
    NOT?: PlannedPlantingWhereInput | PlannedPlantingWhereInput[]
    id?: IntFilter<"PlannedPlanting"> | number
    planId?: IntFilter<"PlannedPlanting"> | number
    containerId?: IntFilter<"PlannedPlanting"> | number
    plantId?: IntFilter<"PlannedPlanting"> | number
    varietyId?: IntNullableFilter<"PlannedPlanting"> | number | null
    plannedDate?: DateTimeNullableFilter<"PlannedPlanting"> | Date | string | null
    quantity?: DecimalNullableFilter<"PlannedPlanting"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlannedPlanting"> | string | null
    status?: StringFilter<"PlannedPlanting"> | string
    plan?: XOR<SeasonalPlanScalarRelationFilter, SeasonalPlanWhereInput>
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    variety?: XOR<PlantVarietyNullableScalarRelationFilter, PlantVarietyWhereInput> | null
  }

  export type PlannedPlantingOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    plan?: SeasonalPlanOrderByWithRelationInput
    container?: ContainerOrderByWithRelationInput
    plant?: PlantCatalogOrderByWithRelationInput
    variety?: PlantVarietyOrderByWithRelationInput
  }

  export type PlannedPlantingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlannedPlantingWhereInput | PlannedPlantingWhereInput[]
    OR?: PlannedPlantingWhereInput[]
    NOT?: PlannedPlantingWhereInput | PlannedPlantingWhereInput[]
    planId?: IntFilter<"PlannedPlanting"> | number
    containerId?: IntFilter<"PlannedPlanting"> | number
    plantId?: IntFilter<"PlannedPlanting"> | number
    varietyId?: IntNullableFilter<"PlannedPlanting"> | number | null
    plannedDate?: DateTimeNullableFilter<"PlannedPlanting"> | Date | string | null
    quantity?: DecimalNullableFilter<"PlannedPlanting"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlannedPlanting"> | string | null
    status?: StringFilter<"PlannedPlanting"> | string
    plan?: XOR<SeasonalPlanScalarRelationFilter, SeasonalPlanWhereInput>
    container?: XOR<ContainerScalarRelationFilter, ContainerWhereInput>
    plant?: XOR<PlantCatalogScalarRelationFilter, PlantCatalogWhereInput>
    variety?: XOR<PlantVarietyNullableScalarRelationFilter, PlantVarietyWhereInput> | null
  }, "id">

  export type PlannedPlantingOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: PlannedPlantingCountOrderByAggregateInput
    _avg?: PlannedPlantingAvgOrderByAggregateInput
    _max?: PlannedPlantingMaxOrderByAggregateInput
    _min?: PlannedPlantingMinOrderByAggregateInput
    _sum?: PlannedPlantingSumOrderByAggregateInput
  }

  export type PlannedPlantingScalarWhereWithAggregatesInput = {
    AND?: PlannedPlantingScalarWhereWithAggregatesInput | PlannedPlantingScalarWhereWithAggregatesInput[]
    OR?: PlannedPlantingScalarWhereWithAggregatesInput[]
    NOT?: PlannedPlantingScalarWhereWithAggregatesInput | PlannedPlantingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlannedPlanting"> | number
    planId?: IntWithAggregatesFilter<"PlannedPlanting"> | number
    containerId?: IntWithAggregatesFilter<"PlannedPlanting"> | number
    plantId?: IntWithAggregatesFilter<"PlannedPlanting"> | number
    varietyId?: IntNullableWithAggregatesFilter<"PlannedPlanting"> | number | null
    plannedDate?: DateTimeNullableWithAggregatesFilter<"PlannedPlanting"> | Date | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"PlannedPlanting"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"PlannedPlanting"> | string | null
    status?: StringWithAggregatesFilter<"PlannedPlanting"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    difficulty?: StringFilter<"Task"> | string
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    endDate?: DateTimeFilter<"Task"> | Date | string
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    userId?: StringFilter<"Task"> | string
    gardenId?: IntNullableFilter<"Task"> | number | null
    containerId?: IntNullableFilter<"Task"> | number | null
    containerPlantId?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    isRecurring?: BoolFilter<"Task"> | boolean
    parentTaskId?: IntNullableFilter<"Task"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    garden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    container?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    containerPlant?: XOR<ContainerPlantNullableScalarRelationFilter, ContainerPlantWhereInput> | null
    parentTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    subtasks?: TaskListRelationFilter
    taskNotes?: TaskNoteListRelationFilter
    taskCompletionLog?: TaskCompletionLogListRelationFilter
    notifications?: TaskNotificationListRelationFilter
    prerequisites?: TaskPrerequisiteListRelationFilter
    dependents?: TaskPrerequisiteListRelationFilter
    recurringPattern?: XOR<RecurringTaskPatternNullableScalarRelationFilter, RecurringTaskPatternWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrder
    dateCompleted?: SortOrderInput | SortOrder
    userId?: SortOrder
    gardenId?: SortOrderInput | SortOrder
    containerId?: SortOrderInput | SortOrder
    containerPlantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRecurring?: SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    garden?: GardenOrderByWithRelationInput
    container?: ContainerOrderByWithRelationInput
    containerPlant?: ContainerPlantOrderByWithRelationInput
    parentTask?: TaskOrderByWithRelationInput
    subtasks?: TaskOrderByRelationAggregateInput
    taskNotes?: TaskNoteOrderByRelationAggregateInput
    taskCompletionLog?: TaskCompletionLogOrderByRelationAggregateInput
    notifications?: TaskNotificationOrderByRelationAggregateInput
    prerequisites?: TaskPrerequisiteOrderByRelationAggregateInput
    dependents?: TaskPrerequisiteOrderByRelationAggregateInput
    recurringPattern?: RecurringTaskPatternOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    difficulty?: StringFilter<"Task"> | string
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    endDate?: DateTimeFilter<"Task"> | Date | string
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    userId?: StringFilter<"Task"> | string
    gardenId?: IntNullableFilter<"Task"> | number | null
    containerId?: IntNullableFilter<"Task"> | number | null
    containerPlantId?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    isRecurring?: BoolFilter<"Task"> | boolean
    parentTaskId?: IntNullableFilter<"Task"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    garden?: XOR<GardenNullableScalarRelationFilter, GardenWhereInput> | null
    container?: XOR<ContainerNullableScalarRelationFilter, ContainerWhereInput> | null
    containerPlant?: XOR<ContainerPlantNullableScalarRelationFilter, ContainerPlantWhereInput> | null
    parentTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    subtasks?: TaskListRelationFilter
    taskNotes?: TaskNoteListRelationFilter
    taskCompletionLog?: TaskCompletionLogListRelationFilter
    notifications?: TaskNotificationListRelationFilter
    prerequisites?: TaskPrerequisiteListRelationFilter
    dependents?: TaskPrerequisiteListRelationFilter
    recurringPattern?: XOR<RecurringTaskPatternNullableScalarRelationFilter, RecurringTaskPatternWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrder
    dateCompleted?: SortOrderInput | SortOrder
    userId?: SortOrder
    gardenId?: SortOrderInput | SortOrder
    containerId?: SortOrderInput | SortOrder
    containerPlantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRecurring?: SortOrder
    parentTaskId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    status?: StringWithAggregatesFilter<"Task"> | string
    category?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    difficulty?: StringWithAggregatesFilter<"Task"> | string
    estimatedMinutes?: IntNullableWithAggregatesFilter<"Task"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    endDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    dateCompleted?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Task"> | string
    gardenId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    containerId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    containerPlantId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    isRecurring?: BoolWithAggregatesFilter<"Task"> | boolean
    parentTaskId?: IntNullableWithAggregatesFilter<"Task"> | number | null
  }

  export type TaskPrerequisiteWhereInput = {
    AND?: TaskPrerequisiteWhereInput | TaskPrerequisiteWhereInput[]
    OR?: TaskPrerequisiteWhereInput[]
    NOT?: TaskPrerequisiteWhereInput | TaskPrerequisiteWhereInput[]
    id?: IntFilter<"TaskPrerequisite"> | number
    taskId?: IntFilter<"TaskPrerequisite"> | number
    prerequisiteTaskId?: IntFilter<"TaskPrerequisite"> | number
    createdAt?: DateTimeFilter<"TaskPrerequisite"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    prerequisiteTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskPrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    prerequisiteTask?: TaskOrderByWithRelationInput
  }

  export type TaskPrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_prerequisiteTaskId?: TaskPrerequisiteTaskIdPrerequisiteTaskIdCompoundUniqueInput
    AND?: TaskPrerequisiteWhereInput | TaskPrerequisiteWhereInput[]
    OR?: TaskPrerequisiteWhereInput[]
    NOT?: TaskPrerequisiteWhereInput | TaskPrerequisiteWhereInput[]
    taskId?: IntFilter<"TaskPrerequisite"> | number
    prerequisiteTaskId?: IntFilter<"TaskPrerequisite"> | number
    createdAt?: DateTimeFilter<"TaskPrerequisite"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    prerequisiteTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "taskId_prerequisiteTaskId">

  export type TaskPrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
    createdAt?: SortOrder
    _count?: TaskPrerequisiteCountOrderByAggregateInput
    _avg?: TaskPrerequisiteAvgOrderByAggregateInput
    _max?: TaskPrerequisiteMaxOrderByAggregateInput
    _min?: TaskPrerequisiteMinOrderByAggregateInput
    _sum?: TaskPrerequisiteSumOrderByAggregateInput
  }

  export type TaskPrerequisiteScalarWhereWithAggregatesInput = {
    AND?: TaskPrerequisiteScalarWhereWithAggregatesInput | TaskPrerequisiteScalarWhereWithAggregatesInput[]
    OR?: TaskPrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: TaskPrerequisiteScalarWhereWithAggregatesInput | TaskPrerequisiteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskPrerequisite"> | number
    taskId?: IntWithAggregatesFilter<"TaskPrerequisite"> | number
    prerequisiteTaskId?: IntWithAggregatesFilter<"TaskPrerequisite"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaskPrerequisite"> | Date | string
  }

  export type TaskNoteWhereInput = {
    AND?: TaskNoteWhereInput | TaskNoteWhereInput[]
    OR?: TaskNoteWhereInput[]
    NOT?: TaskNoteWhereInput | TaskNoteWhereInput[]
    id?: IntFilter<"TaskNote"> | number
    taskId?: IntFilter<"TaskNote"> | number
    userId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
    updatedAt?: DateTimeFilter<"TaskNote"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskNoteOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskNoteWhereInput | TaskNoteWhereInput[]
    OR?: TaskNoteWhereInput[]
    NOT?: TaskNoteWhereInput | TaskNoteWhereInput[]
    taskId?: IntFilter<"TaskNote"> | number
    userId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
    updatedAt?: DateTimeFilter<"TaskNote"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskNoteOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskNoteCountOrderByAggregateInput
    _avg?: TaskNoteAvgOrderByAggregateInput
    _max?: TaskNoteMaxOrderByAggregateInput
    _min?: TaskNoteMinOrderByAggregateInput
    _sum?: TaskNoteSumOrderByAggregateInput
  }

  export type TaskNoteScalarWhereWithAggregatesInput = {
    AND?: TaskNoteScalarWhereWithAggregatesInput | TaskNoteScalarWhereWithAggregatesInput[]
    OR?: TaskNoteScalarWhereWithAggregatesInput[]
    NOT?: TaskNoteScalarWhereWithAggregatesInput | TaskNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskNote"> | number
    taskId?: IntWithAggregatesFilter<"TaskNote"> | number
    userId?: StringWithAggregatesFilter<"TaskNote"> | string
    content?: StringWithAggregatesFilter<"TaskNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskNote"> | Date | string
  }

  export type TaskCompletionLogWhereInput = {
    AND?: TaskCompletionLogWhereInput | TaskCompletionLogWhereInput[]
    OR?: TaskCompletionLogWhereInput[]
    NOT?: TaskCompletionLogWhereInput | TaskCompletionLogWhereInput[]
    id?: IntFilter<"TaskCompletionLog"> | number
    taskId?: IntFilter<"TaskCompletionLog"> | number
    userId?: StringFilter<"TaskCompletionLog"> | string
    status?: StringFilter<"TaskCompletionLog"> | string
    completedAt?: DateTimeFilter<"TaskCompletionLog"> | Date | string
    notes?: StringNullableFilter<"TaskCompletionLog"> | string | null
    percentDone?: IntNullableFilter<"TaskCompletionLog"> | number | null
    timeSpentMinutes?: IntNullableFilter<"TaskCompletionLog"> | number | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskCompletionLogOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    percentDone?: SortOrderInput | SortOrder
    timeSpentMinutes?: SortOrderInput | SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskCompletionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskCompletionLogWhereInput | TaskCompletionLogWhereInput[]
    OR?: TaskCompletionLogWhereInput[]
    NOT?: TaskCompletionLogWhereInput | TaskCompletionLogWhereInput[]
    taskId?: IntFilter<"TaskCompletionLog"> | number
    userId?: StringFilter<"TaskCompletionLog"> | string
    status?: StringFilter<"TaskCompletionLog"> | string
    completedAt?: DateTimeFilter<"TaskCompletionLog"> | Date | string
    notes?: StringNullableFilter<"TaskCompletionLog"> | string | null
    percentDone?: IntNullableFilter<"TaskCompletionLog"> | number | null
    timeSpentMinutes?: IntNullableFilter<"TaskCompletionLog"> | number | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskCompletionLogOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    percentDone?: SortOrderInput | SortOrder
    timeSpentMinutes?: SortOrderInput | SortOrder
    _count?: TaskCompletionLogCountOrderByAggregateInput
    _avg?: TaskCompletionLogAvgOrderByAggregateInput
    _max?: TaskCompletionLogMaxOrderByAggregateInput
    _min?: TaskCompletionLogMinOrderByAggregateInput
    _sum?: TaskCompletionLogSumOrderByAggregateInput
  }

  export type TaskCompletionLogScalarWhereWithAggregatesInput = {
    AND?: TaskCompletionLogScalarWhereWithAggregatesInput | TaskCompletionLogScalarWhereWithAggregatesInput[]
    OR?: TaskCompletionLogScalarWhereWithAggregatesInput[]
    NOT?: TaskCompletionLogScalarWhereWithAggregatesInput | TaskCompletionLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskCompletionLog"> | number
    taskId?: IntWithAggregatesFilter<"TaskCompletionLog"> | number
    userId?: StringWithAggregatesFilter<"TaskCompletionLog"> | string
    status?: StringWithAggregatesFilter<"TaskCompletionLog"> | string
    completedAt?: DateTimeWithAggregatesFilter<"TaskCompletionLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"TaskCompletionLog"> | string | null
    percentDone?: IntNullableWithAggregatesFilter<"TaskCompletionLog"> | number | null
    timeSpentMinutes?: IntNullableWithAggregatesFilter<"TaskCompletionLog"> | number | null
  }

  export type RecurringTaskPatternWhereInput = {
    AND?: RecurringTaskPatternWhereInput | RecurringTaskPatternWhereInput[]
    OR?: RecurringTaskPatternWhereInput[]
    NOT?: RecurringTaskPatternWhereInput | RecurringTaskPatternWhereInput[]
    id?: IntFilter<"RecurringTaskPattern"> | number
    taskId?: IntFilter<"RecurringTaskPattern"> | number
    frequency?: StringFilter<"RecurringTaskPattern"> | string
    interval?: IntFilter<"RecurringTaskPattern"> | number
    endAfterCount?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    endByDate?: DateTimeNullableFilter<"RecurringTaskPattern"> | Date | string | null
    daysOfWeek?: StringNullableFilter<"RecurringTaskPattern"> | string | null
    dayOfMonth?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    monthOfYear?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    createdAt?: DateTimeFilter<"RecurringTaskPattern"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTaskPattern"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type RecurringTaskPatternOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrderInput | SortOrder
    endByDate?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrderInput | SortOrder
    dayOfMonth?: SortOrderInput | SortOrder
    monthOfYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type RecurringTaskPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId?: number
    AND?: RecurringTaskPatternWhereInput | RecurringTaskPatternWhereInput[]
    OR?: RecurringTaskPatternWhereInput[]
    NOT?: RecurringTaskPatternWhereInput | RecurringTaskPatternWhereInput[]
    frequency?: StringFilter<"RecurringTaskPattern"> | string
    interval?: IntFilter<"RecurringTaskPattern"> | number
    endAfterCount?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    endByDate?: DateTimeNullableFilter<"RecurringTaskPattern"> | Date | string | null
    daysOfWeek?: StringNullableFilter<"RecurringTaskPattern"> | string | null
    dayOfMonth?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    monthOfYear?: IntNullableFilter<"RecurringTaskPattern"> | number | null
    createdAt?: DateTimeFilter<"RecurringTaskPattern"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTaskPattern"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "taskId">

  export type RecurringTaskPatternOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrderInput | SortOrder
    endByDate?: SortOrderInput | SortOrder
    daysOfWeek?: SortOrderInput | SortOrder
    dayOfMonth?: SortOrderInput | SortOrder
    monthOfYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringTaskPatternCountOrderByAggregateInput
    _avg?: RecurringTaskPatternAvgOrderByAggregateInput
    _max?: RecurringTaskPatternMaxOrderByAggregateInput
    _min?: RecurringTaskPatternMinOrderByAggregateInput
    _sum?: RecurringTaskPatternSumOrderByAggregateInput
  }

  export type RecurringTaskPatternScalarWhereWithAggregatesInput = {
    AND?: RecurringTaskPatternScalarWhereWithAggregatesInput | RecurringTaskPatternScalarWhereWithAggregatesInput[]
    OR?: RecurringTaskPatternScalarWhereWithAggregatesInput[]
    NOT?: RecurringTaskPatternScalarWhereWithAggregatesInput | RecurringTaskPatternScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecurringTaskPattern"> | number
    taskId?: IntWithAggregatesFilter<"RecurringTaskPattern"> | number
    frequency?: StringWithAggregatesFilter<"RecurringTaskPattern"> | string
    interval?: IntWithAggregatesFilter<"RecurringTaskPattern"> | number
    endAfterCount?: IntNullableWithAggregatesFilter<"RecurringTaskPattern"> | number | null
    endByDate?: DateTimeNullableWithAggregatesFilter<"RecurringTaskPattern"> | Date | string | null
    daysOfWeek?: StringNullableWithAggregatesFilter<"RecurringTaskPattern"> | string | null
    dayOfMonth?: IntNullableWithAggregatesFilter<"RecurringTaskPattern"> | number | null
    monthOfYear?: IntNullableWithAggregatesFilter<"RecurringTaskPattern"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringTaskPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringTaskPattern"> | Date | string
  }

  export type TaskNotificationWhereInput = {
    AND?: TaskNotificationWhereInput | TaskNotificationWhereInput[]
    OR?: TaskNotificationWhereInput[]
    NOT?: TaskNotificationWhereInput | TaskNotificationWhereInput[]
    id?: IntFilter<"TaskNotification"> | number
    taskId?: IntFilter<"TaskNotification"> | number
    userId?: StringFilter<"TaskNotification"> | string
    message?: StringFilter<"TaskNotification"> | string
    isRead?: BoolFilter<"TaskNotification"> | boolean
    readAt?: DateTimeNullableFilter<"TaskNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskNotification"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskNotificationOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskNotificationWhereInput | TaskNotificationWhereInput[]
    OR?: TaskNotificationWhereInput[]
    NOT?: TaskNotificationWhereInput | TaskNotificationWhereInput[]
    taskId?: IntFilter<"TaskNotification"> | number
    userId?: StringFilter<"TaskNotification"> | string
    message?: StringFilter<"TaskNotification"> | string
    isRead?: BoolFilter<"TaskNotification"> | boolean
    readAt?: DateTimeNullableFilter<"TaskNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskNotification"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskNotificationCountOrderByAggregateInput
    _avg?: TaskNotificationAvgOrderByAggregateInput
    _max?: TaskNotificationMaxOrderByAggregateInput
    _min?: TaskNotificationMinOrderByAggregateInput
    _sum?: TaskNotificationSumOrderByAggregateInput
  }

  export type TaskNotificationScalarWhereWithAggregatesInput = {
    AND?: TaskNotificationScalarWhereWithAggregatesInput | TaskNotificationScalarWhereWithAggregatesInput[]
    OR?: TaskNotificationScalarWhereWithAggregatesInput[]
    NOT?: TaskNotificationScalarWhereWithAggregatesInput | TaskNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskNotification"> | number
    taskId?: IntWithAggregatesFilter<"TaskNotification"> | number
    userId?: StringWithAggregatesFilter<"TaskNotification"> | string
    message?: StringWithAggregatesFilter<"TaskNotification"> | string
    isRead?: BoolWithAggregatesFilter<"TaskNotification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"TaskNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskNotification"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GardenCreateInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type GardenCreateManyInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionCreateInput = {
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutConditionsInput
  }

  export type GardenConditionUncheckedCreateInput = {
    id?: number
    gardenId: number
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenConditionUpdateInput = {
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type GardenConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionCreateManyInput = {
    id?: number
    gardenId: number
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenConditionUpdateManyMutationInput = {
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerTypeCreateInput = {
    name: string
    description?: string | null
    typicalDimensions?: string | null
    containers?: ContainerCreateNestedManyWithoutContainerTypeInput
  }

  export type ContainerTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    typicalDimensions?: string | null
    containers?: ContainerUncheckedCreateNestedManyWithoutContainerTypeInput
  }

  export type ContainerTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUpdateManyWithoutContainerTypeNestedInput
  }

  export type ContainerTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
    containers?: ContainerUncheckedUpdateManyWithoutContainerTypeNestedInput
  }

  export type ContainerTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    typicalDimensions?: string | null
  }

  export type ContainerTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerCreateInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerCreateManyInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantCatalogCreateInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUpdateInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogCreateManyInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantCatalogUpdateManyMutationInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantCatalogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantGrowingConditionCreateInput = {
    minTemperatureF?: number | null
    maxTemperatureF?: number | null
    sunlightNeeds?: string | null
    waterNeeds?: string | null
    soilPhMin?: Decimal | DecimalJsLike | number | string | null
    soilPhMax?: Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: string | null
    fertilizerNeeds?: string | null
    spacingInches?: Decimal | DecimalJsLike | number | string | null
    containerSuitable?: boolean
    minContainerDepthInches?: Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: Decimal | DecimalJsLike | number | string | null
    plant: PlantCatalogCreateNestedOneWithoutGrowingConditionsInput
  }

  export type PlantGrowingConditionUncheckedCreateInput = {
    id?: number
    plantId: number
    minTemperatureF?: number | null
    maxTemperatureF?: number | null
    sunlightNeeds?: string | null
    waterNeeds?: string | null
    soilPhMin?: Decimal | DecimalJsLike | number | string | null
    soilPhMax?: Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: string | null
    fertilizerNeeds?: string | null
    spacingInches?: Decimal | DecimalJsLike | number | string | null
    containerSuitable?: boolean
    minContainerDepthInches?: Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionUpdateInput = {
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutGrowingConditionsNestedInput
  }

  export type PlantGrowingConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionCreateManyInput = {
    id?: number
    plantId: number
    minTemperatureF?: number | null
    maxTemperatureF?: number | null
    sunlightNeeds?: string | null
    waterNeeds?: string | null
    soilPhMin?: Decimal | DecimalJsLike | number | string | null
    soilPhMax?: Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: string | null
    fertilizerNeeds?: string | null
    spacingInches?: Decimal | DecimalJsLike | number | string | null
    containerSuitable?: boolean
    minContainerDepthInches?: Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionUpdateManyMutationInput = {
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantClimateZoneCreateInput = {
    climateZone: string
    notes?: string | null
    plant: PlantCatalogCreateNestedOneWithoutClimateZonesInput
  }

  export type PlantClimateZoneUncheckedCreateInput = {
    id?: number
    plantId: number
    climateZone: string
    notes?: string | null
  }

  export type PlantClimateZoneUpdateInput = {
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutClimateZonesNestedInput
  }

  export type PlantClimateZoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantClimateZoneCreateManyInput = {
    id?: number
    plantId: number
    climateZone: string
    notes?: string | null
  }

  export type PlantClimateZoneUpdateManyMutationInput = {
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantClimateZoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantVarietyCreateInput = {
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    plant: PlantCatalogCreateNestedOneWithoutVarietiesInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutVarietyInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyUncheckedCreateInput = {
    id?: number
    plantId: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutVarietyInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyUpdateInput = {
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutVarietiesNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutVarietyNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutVarietyNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyCreateManyInput = {
    id?: number
    plantId: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
  }

  export type PlantVarietyUpdateManyMutationInput = {
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantVarietyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionCreateInput = {
    relationshipType: string
    effectDescription?: string | null
    plant: PlantCatalogCreateNestedOneWithoutCompanionsInput
    companionPlant: PlantCatalogCreateNestedOneWithoutCompanionToInput
  }

  export type PlantCompanionUncheckedCreateInput = {
    id?: number
    plantId: number
    companionPlantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type PlantCompanionUpdateInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutCompanionsNestedInput
    companionPlant?: PlantCatalogUpdateOneRequiredWithoutCompanionToNestedInput
  }

  export type PlantCompanionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    companionPlantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionCreateManyInput = {
    id?: number
    plantId: number
    companionPlantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type PlantCompanionUpdateManyMutationInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    companionPlantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerPlantCreateInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUpdateInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantCreateManyInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerPlantUpdateManyMutationInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerPlantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantGrowthStageCreateInput = {
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
    containerPlant: ContainerPlantCreateNestedOneWithoutGrowthStagesInput
  }

  export type PlantGrowthStageUncheckedCreateInput = {
    id?: number
    containerPlantId: number
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type PlantGrowthStageUpdateInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlant?: ContainerPlantUpdateOneRequiredWithoutGrowthStagesNestedInput
  }

  export type PlantGrowthStageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantGrowthStageCreateManyInput = {
    id?: number
    containerPlantId: number
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type PlantGrowthStageUpdateManyMutationInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantGrowthStageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionTypeCreateInput = {
    name: string
    description?: string | null
    category?: string | null
    actions?: GardenActionCreateNestedManyWithoutActionTypeInput
  }

  export type ActionTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    actions?: GardenActionUncheckedCreateNestedManyWithoutActionTypeInput
  }

  export type ActionTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: GardenActionUpdateManyWithoutActionTypeNestedInput
  }

  export type ActionTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: GardenActionUncheckedUpdateManyWithoutActionTypeNestedInput
  }

  export type ActionTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
  }

  export type ActionTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GardenActionCreateInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    actionType: ActionTypeCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutGardenActionsInput
    garden?: GardenCreateNestedOneWithoutGardenActionsInput
    container?: ContainerCreateNestedOneWithoutGardenActionsInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionUpdateInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: ActionTypeUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutGardenActionsNestedInput
    garden?: GardenUpdateOneWithoutGardenActionsNestedInput
    container?: ContainerUpdateOneWithoutGardenActionsNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionCreateManyInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionUpdateManyMutationInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarvestCreateInput = {
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
    containerPlant: ContainerPlantCreateNestedOneWithoutHarvestsInput
  }

  export type HarvestUncheckedCreateInput = {
    id?: number
    containerPlantId: number
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type HarvestUpdateInput = {
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlant?: ContainerPlantUpdateOneRequiredWithoutHarvestsNestedInput
  }

  export type HarvestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HarvestCreateManyInput = {
    id?: number
    containerPlantId: number
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type HarvestUpdateManyMutationInput = {
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HarvestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryCreateInput = {
    moveDate: Date | string
    reason?: string | null
    container: ContainerCreateNestedOneWithoutContainerHistoryInput
    previousContainer?: ContainerCreateNestedOneWithoutPreviousContainersInput
    previousGarden?: GardenCreateNestedOneWithoutPreviousContainersInput
    newGarden?: GardenCreateNestedOneWithoutNewContainersInput
  }

  export type ContainerHistoryUncheckedCreateInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryUpdateInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutContainerHistoryNestedInput
    previousContainer?: ContainerUpdateOneWithoutPreviousContainersNestedInput
    previousGarden?: GardenUpdateOneWithoutPreviousContainersNestedInput
    newGarden?: GardenUpdateOneWithoutNewContainersNestedInput
  }

  export type ContainerHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryCreateManyInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryUpdateManyMutationInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryCreateInput = {
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
    containerPlant: ContainerPlantCreateNestedOneWithoutMovementHistoryInput
  }

  export type PlantMovementHistoryUncheckedCreateInput = {
    id?: number
    containerPlantId: number
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
  }

  export type PlantMovementHistoryUpdateInput = {
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlant?: ContainerPlantUpdateOneRequiredWithoutMovementHistoryNestedInput
  }

  export type PlantMovementHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryCreateManyInput = {
    id?: number
    containerPlantId: number
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
  }

  export type PlantMovementHistoryUpdateManyMutationInput = {
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerPlantId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeasonalPlanCreateInput = {
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutSeasonalPlansInput
    plantings?: PlannedPlantingCreateNestedManyWithoutPlanInput
  }

  export type SeasonalPlanUncheckedCreateInput = {
    id?: number
    gardenId: number
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SeasonalPlanUpdateInput = {
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutSeasonalPlansNestedInput
    plantings?: PlannedPlantingUpdateManyWithoutPlanNestedInput
  }

  export type SeasonalPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlannedPlantingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SeasonalPlanCreateManyInput = {
    id?: number
    gardenId: number
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonalPlanUpdateManyMutationInput = {
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonalPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannedPlantingCreateInput = {
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
    plan: SeasonalPlanCreateNestedOneWithoutPlantingsInput
    container: ContainerCreateNestedOneWithoutPlannedPlantingsInput
    plant: PlantCatalogCreateNestedOneWithoutPlannedPlantingsInput
    variety?: PlantVarietyCreateNestedOneWithoutPlannedPlantingsInput
  }

  export type PlannedPlantingUncheckedCreateInput = {
    id?: number
    planId: number
    containerId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingUpdateInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: SeasonalPlanUpdateOneRequiredWithoutPlantingsNestedInput
    container?: ContainerUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    variety?: PlantVarietyUpdateOneWithoutPlannedPlantingsNestedInput
  }

  export type PlannedPlantingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingCreateManyInput = {
    id?: number
    planId: number
    containerId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingUpdateManyMutationInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskPrerequisiteCreateInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutPrerequisitesInput
    prerequisiteTask: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskPrerequisiteUncheckedCreateInput = {
    id?: number
    taskId: number
    prerequisiteTaskId: number
    createdAt?: Date | string
  }

  export type TaskPrerequisiteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisiteTask?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskPrerequisiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    prerequisiteTaskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteCreateManyInput = {
    id?: number
    taskId: number
    prerequisiteTaskId: number
    createdAt?: Date | string
  }

  export type TaskPrerequisiteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    prerequisiteTaskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskNotesInput
    user: UserCreateNestedOneWithoutTaskNotesInput
  }

  export type TaskNoteUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskNoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskNotesNestedInput
    user?: UserUpdateOneRequiredWithoutTaskNotesNestedInput
  }

  export type TaskNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteCreateManyInput = {
    id?: number
    taskId: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskNoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionLogCreateInput = {
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
    task: TaskCreateNestedOneWithoutTaskCompletionLogInput
    user: UserCreateNestedOneWithoutTaskCompletionLogsInput
  }

  export type TaskCompletionLogUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: string
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskCompletionLogUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    task?: TaskUpdateOneRequiredWithoutTaskCompletionLogNestedInput
    user?: UserUpdateOneRequiredWithoutTaskCompletionLogsNestedInput
  }

  export type TaskCompletionLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCompletionLogCreateManyInput = {
    id?: number
    taskId: number
    userId: string
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskCompletionLogUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCompletionLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecurringTaskPatternCreateInput = {
    frequency: string
    interval?: number
    endAfterCount?: number | null
    endByDate?: Date | string | null
    daysOfWeek?: string | null
    dayOfMonth?: number | null
    monthOfYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutRecurringPatternInput
  }

  export type RecurringTaskPatternUncheckedCreateInput = {
    id?: number
    taskId: number
    frequency: string
    interval?: number
    endAfterCount?: number | null
    endByDate?: Date | string | null
    daysOfWeek?: string | null
    dayOfMonth?: number | null
    monthOfYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTaskPatternUpdateInput = {
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutRecurringPatternNestedInput
  }

  export type RecurringTaskPatternUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTaskPatternCreateManyInput = {
    id?: number
    taskId: number
    frequency: string
    interval?: number
    endAfterCount?: number | null
    endByDate?: Date | string | null
    daysOfWeek?: string | null
    dayOfMonth?: number | null
    monthOfYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTaskPatternUpdateManyMutationInput = {
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTaskPatternUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNotificationCreateInput = {
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutTaskNotificationsInput
  }

  export type TaskNotificationUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskNotificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskNotificationsNestedInput
  }

  export type TaskNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNotificationCreateManyInput = {
    id?: number
    taskId: number
    userId: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskNotificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type GardenListRelationFilter = {
    every?: GardenWhereInput
    some?: GardenWhereInput
    none?: GardenWhereInput
  }

  export type GardenActionListRelationFilter = {
    every?: GardenActionWhereInput
    some?: GardenActionWhereInput
    none?: GardenActionWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskNoteListRelationFilter = {
    every?: TaskNoteWhereInput
    some?: TaskNoteWhereInput
    none?: TaskNoteWhereInput
  }

  export type TaskCompletionLogListRelationFilter = {
    every?: TaskCompletionLogWhereInput
    some?: TaskCompletionLogWhereInput
    none?: TaskCompletionLogWhereInput
  }

  export type TaskNotificationListRelationFilter = {
    every?: TaskNotificationWhereInput
    some?: TaskNotificationWhereInput
    none?: TaskNotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GardenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GardenActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCompletionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type GardenConditionListRelationFilter = {
    every?: GardenConditionWhereInput
    some?: GardenConditionWhereInput
    none?: GardenConditionWhereInput
  }

  export type ContainerListRelationFilter = {
    every?: ContainerWhereInput
    some?: ContainerWhereInput
    none?: ContainerWhereInput
  }

  export type SeasonalPlanListRelationFilter = {
    every?: SeasonalPlanWhereInput
    some?: SeasonalPlanWhereInput
    none?: SeasonalPlanWhereInput
  }

  export type ContainerHistoryListRelationFilter = {
    every?: ContainerHistoryWhereInput
    some?: ContainerHistoryWhereInput
    none?: ContainerHistoryWhereInput
  }

  export type GardenConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonalPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GardenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    sizeSqFeet?: SortOrder
    gardenType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenAvgOrderByAggregateInput = {
    id?: SortOrder
    sizeSqFeet?: SortOrder
  }

  export type GardenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    sizeSqFeet?: SortOrder
    gardenType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    sizeSqFeet?: SortOrder
    gardenType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenSumOrderByAggregateInput = {
    id?: SortOrder
    sizeSqFeet?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type GardenScalarRelationFilter = {
    is?: GardenWhereInput
    isNot?: GardenWhereInput
  }

  export type GardenConditionCountOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    climateZone?: SortOrder
    sunlightExposure?: SortOrder
    avgTemperatureF?: SortOrder
    humidityPct?: SortOrder
    soilType?: SortOrder
    annualRainfall?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenConditionAvgOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    avgTemperatureF?: SortOrder
    humidityPct?: SortOrder
    annualRainfall?: SortOrder
  }

  export type GardenConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    climateZone?: SortOrder
    sunlightExposure?: SortOrder
    avgTemperatureF?: SortOrder
    humidityPct?: SortOrder
    soilType?: SortOrder
    annualRainfall?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenConditionMinOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    climateZone?: SortOrder
    sunlightExposure?: SortOrder
    avgTemperatureF?: SortOrder
    humidityPct?: SortOrder
    soilType?: SortOrder
    annualRainfall?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GardenConditionSumOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    avgTemperatureF?: SortOrder
    humidityPct?: SortOrder
    annualRainfall?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContainerTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    typicalDimensions?: SortOrder
  }

  export type ContainerTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContainerTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    typicalDimensions?: SortOrder
  }

  export type ContainerTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    typicalDimensions?: SortOrder
  }

  export type ContainerTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContainerTypeScalarRelationFilter = {
    is?: ContainerTypeWhereInput
    isNot?: ContainerTypeWhereInput
  }

  export type ContainerPlantListRelationFilter = {
    every?: ContainerPlantWhereInput
    some?: ContainerPlantWhereInput
    none?: ContainerPlantWhereInput
  }

  export type PlannedPlantingListRelationFilter = {
    every?: PlannedPlantingWhereInput
    some?: PlannedPlantingWhereInput
    none?: PlannedPlantingWhereInput
  }

  export type ContainerPlantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlannedPlantingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerCountOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    name?: SortOrder
    material?: SortOrder
    widthInches?: SortOrder
    lengthInches?: SortOrder
    heightInches?: SortOrder
    diameterInches?: SortOrder
    volumeGallons?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    soilType?: SortOrder
    drainageQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerAvgOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    widthInches?: SortOrder
    lengthInches?: SortOrder
    heightInches?: SortOrder
    diameterInches?: SortOrder
    volumeGallons?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ContainerMaxOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    name?: SortOrder
    material?: SortOrder
    widthInches?: SortOrder
    lengthInches?: SortOrder
    heightInches?: SortOrder
    diameterInches?: SortOrder
    volumeGallons?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    soilType?: SortOrder
    drainageQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerMinOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    name?: SortOrder
    material?: SortOrder
    widthInches?: SortOrder
    lengthInches?: SortOrder
    heightInches?: SortOrder
    diameterInches?: SortOrder
    volumeGallons?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    soilType?: SortOrder
    drainageQuality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerSumOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    containerTypeId?: SortOrder
    widthInches?: SortOrder
    lengthInches?: SortOrder
    heightInches?: SortOrder
    diameterInches?: SortOrder
    volumeGallons?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type PlantGrowingConditionNullableScalarRelationFilter = {
    is?: PlantGrowingConditionWhereInput | null
    isNot?: PlantGrowingConditionWhereInput | null
  }

  export type PlantClimateZoneListRelationFilter = {
    every?: PlantClimateZoneWhereInput
    some?: PlantClimateZoneWhereInput
    none?: PlantClimateZoneWhereInput
  }

  export type PlantVarietyListRelationFilter = {
    every?: PlantVarietyWhereInput
    some?: PlantVarietyWhereInput
    none?: PlantVarietyWhereInput
  }

  export type PlantCompanionListRelationFilter = {
    every?: PlantCompanionWhereInput
    some?: PlantCompanionWhereInput
    none?: PlantCompanionWhereInput
  }

  export type PlantClimateZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantVarietyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantCompanionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    plantType?: SortOrder
    lifeCycle?: SortOrder
    growthHabit?: SortOrder
    edible?: SortOrder
    description?: SortOrder
    plantingInstructions?: SortOrder
    careInstructions?: SortOrder
    daysToGerminationMin?: SortOrder
    daysToGerminationMax?: SortOrder
    daysToMaturityMin?: SortOrder
    daysToMaturityMax?: SortOrder
    harvestSeason?: SortOrder
    heightInchesMin?: SortOrder
    heightInchesMax?: SortOrder
    widthInchesMin?: SortOrder
    widthInchesMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantCatalogAvgOrderByAggregateInput = {
    id?: SortOrder
    daysToGerminationMin?: SortOrder
    daysToGerminationMax?: SortOrder
    daysToMaturityMin?: SortOrder
    daysToMaturityMax?: SortOrder
    heightInchesMin?: SortOrder
    heightInchesMax?: SortOrder
    widthInchesMin?: SortOrder
    widthInchesMax?: SortOrder
  }

  export type PlantCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    plantType?: SortOrder
    lifeCycle?: SortOrder
    growthHabit?: SortOrder
    edible?: SortOrder
    description?: SortOrder
    plantingInstructions?: SortOrder
    careInstructions?: SortOrder
    daysToGerminationMin?: SortOrder
    daysToGerminationMax?: SortOrder
    daysToMaturityMin?: SortOrder
    daysToMaturityMax?: SortOrder
    harvestSeason?: SortOrder
    heightInchesMin?: SortOrder
    heightInchesMax?: SortOrder
    widthInchesMin?: SortOrder
    widthInchesMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    commonName?: SortOrder
    scientificName?: SortOrder
    plantType?: SortOrder
    lifeCycle?: SortOrder
    growthHabit?: SortOrder
    edible?: SortOrder
    description?: SortOrder
    plantingInstructions?: SortOrder
    careInstructions?: SortOrder
    daysToGerminationMin?: SortOrder
    daysToGerminationMax?: SortOrder
    daysToMaturityMin?: SortOrder
    daysToMaturityMax?: SortOrder
    harvestSeason?: SortOrder
    heightInchesMin?: SortOrder
    heightInchesMax?: SortOrder
    widthInchesMin?: SortOrder
    widthInchesMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantCatalogSumOrderByAggregateInput = {
    id?: SortOrder
    daysToGerminationMin?: SortOrder
    daysToGerminationMax?: SortOrder
    daysToMaturityMin?: SortOrder
    daysToMaturityMax?: SortOrder
    heightInchesMin?: SortOrder
    heightInchesMax?: SortOrder
    widthInchesMin?: SortOrder
    widthInchesMax?: SortOrder
  }

  export type PlantCatalogScalarRelationFilter = {
    is?: PlantCatalogWhereInput
    isNot?: PlantCatalogWhereInput
  }

  export type PlantGrowingConditionCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrder
    maxTemperatureF?: SortOrder
    sunlightNeeds?: SortOrder
    waterNeeds?: SortOrder
    soilPhMin?: SortOrder
    soilPhMax?: SortOrder
    soilTypePreference?: SortOrder
    fertilizerNeeds?: SortOrder
    spacingInches?: SortOrder
    containerSuitable?: SortOrder
    minContainerDepthInches?: SortOrder
    minContainerVolumeGallons?: SortOrder
  }

  export type PlantGrowingConditionAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrder
    maxTemperatureF?: SortOrder
    soilPhMin?: SortOrder
    soilPhMax?: SortOrder
    spacingInches?: SortOrder
    minContainerDepthInches?: SortOrder
    minContainerVolumeGallons?: SortOrder
  }

  export type PlantGrowingConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrder
    maxTemperatureF?: SortOrder
    sunlightNeeds?: SortOrder
    waterNeeds?: SortOrder
    soilPhMin?: SortOrder
    soilPhMax?: SortOrder
    soilTypePreference?: SortOrder
    fertilizerNeeds?: SortOrder
    spacingInches?: SortOrder
    containerSuitable?: SortOrder
    minContainerDepthInches?: SortOrder
    minContainerVolumeGallons?: SortOrder
  }

  export type PlantGrowingConditionMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrder
    maxTemperatureF?: SortOrder
    sunlightNeeds?: SortOrder
    waterNeeds?: SortOrder
    soilPhMin?: SortOrder
    soilPhMax?: SortOrder
    soilTypePreference?: SortOrder
    fertilizerNeeds?: SortOrder
    spacingInches?: SortOrder
    containerSuitable?: SortOrder
    minContainerDepthInches?: SortOrder
    minContainerVolumeGallons?: SortOrder
  }

  export type PlantGrowingConditionSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    minTemperatureF?: SortOrder
    maxTemperatureF?: SortOrder
    soilPhMin?: SortOrder
    soilPhMax?: SortOrder
    spacingInches?: SortOrder
    minContainerDepthInches?: SortOrder
    minContainerVolumeGallons?: SortOrder
  }

  export type PlantClimateZoneCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    climateZone?: SortOrder
    notes?: SortOrder
  }

  export type PlantClimateZoneAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type PlantClimateZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    climateZone?: SortOrder
    notes?: SortOrder
  }

  export type PlantClimateZoneMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    climateZone?: SortOrder
    notes?: SortOrder
  }

  export type PlantClimateZoneSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type PlantVarietyCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    varietyName?: SortOrder
    description?: SortOrder
    specificTraits?: SortOrder
    specificCareNeeds?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantVarietyAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type PlantVarietyMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    varietyName?: SortOrder
    description?: SortOrder
    specificTraits?: SortOrder
    specificCareNeeds?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantVarietyMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    varietyName?: SortOrder
    description?: SortOrder
    specificTraits?: SortOrder
    specificCareNeeds?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantVarietySumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type PlantCompanionCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
    relationshipType?: SortOrder
    effectDescription?: SortOrder
  }

  export type PlantCompanionAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
  }

  export type PlantCompanionMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
    relationshipType?: SortOrder
    effectDescription?: SortOrder
  }

  export type PlantCompanionMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
    relationshipType?: SortOrder
    effectDescription?: SortOrder
  }

  export type PlantCompanionSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    companionPlantId?: SortOrder
  }

  export type ContainerScalarRelationFilter = {
    is?: ContainerWhereInput
    isNot?: ContainerWhereInput
  }

  export type PlantVarietyNullableScalarRelationFilter = {
    is?: PlantVarietyWhereInput | null
    isNot?: PlantVarietyWhereInput | null
  }

  export type PlantGrowthStageListRelationFilter = {
    every?: PlantGrowthStageWhereInput
    some?: PlantGrowthStageWhereInput
    none?: PlantGrowthStageWhereInput
  }

  export type HarvestListRelationFilter = {
    every?: HarvestWhereInput
    some?: HarvestWhereInput
    none?: HarvestWhereInput
  }

  export type PlantMovementHistoryListRelationFilter = {
    every?: PlantMovementHistoryWhereInput
    some?: PlantMovementHistoryWhereInput
    none?: PlantMovementHistoryWhereInput
  }

  export type PlantGrowthStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HarvestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantMovementHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContainerPlantCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
    plantDate?: SortOrder
    initialStage?: SortOrder
    currentStage?: SortOrder
    status?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    expectedHarvestDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerPlantAvgOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ContainerPlantMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
    plantDate?: SortOrder
    initialStage?: SortOrder
    currentStage?: SortOrder
    status?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    expectedHarvestDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerPlantMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
    plantDate?: SortOrder
    initialStage?: SortOrder
    currentStage?: SortOrder
    status?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    expectedHarvestDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContainerPlantSumOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type ContainerPlantScalarRelationFilter = {
    is?: ContainerPlantWhereInput
    isNot?: ContainerPlantWhereInput
  }

  export type PlantGrowthStageCountOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    stageName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantGrowthStageAvgOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
  }

  export type PlantGrowthStageMaxOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    stageName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantGrowthStageMinOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    stageName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type PlantGrowthStageSumOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
  }

  export type ActionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type ActionTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type ActionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type ActionTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActionTypeScalarRelationFilter = {
    is?: ActionTypeWhereInput
    isNot?: ActionTypeWhereInput
  }

  export type GardenNullableScalarRelationFilter = {
    is?: GardenWhereInput | null
    isNot?: GardenWhereInput | null
  }

  export type ContainerNullableScalarRelationFilter = {
    is?: ContainerWhereInput | null
    isNot?: ContainerWhereInput | null
  }

  export type ContainerPlantNullableScalarRelationFilter = {
    is?: ContainerPlantWhereInput | null
    isNot?: ContainerPlantWhereInput | null
  }

  export type GardenActionCountOrderByAggregateInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    actionDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    successRating?: SortOrder
    createdAt?: SortOrder
  }

  export type GardenActionAvgOrderByAggregateInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    quantity?: SortOrder
    successRating?: SortOrder
  }

  export type GardenActionMaxOrderByAggregateInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    actionDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    successRating?: SortOrder
    createdAt?: SortOrder
  }

  export type GardenActionMinOrderByAggregateInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    actionDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    successRating?: SortOrder
    createdAt?: SortOrder
  }

  export type GardenActionSumOrderByAggregateInput = {
    id?: SortOrder
    actionTypeId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    quantity?: SortOrder
    successRating?: SortOrder
  }

  export type HarvestCountOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    harvestDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    qualityRating?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type HarvestAvgOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    quantity?: SortOrder
    qualityRating?: SortOrder
  }

  export type HarvestMaxOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    harvestDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    qualityRating?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type HarvestMinOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    harvestDate?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    qualityRating?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
  }

  export type HarvestSumOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    quantity?: SortOrder
    qualityRating?: SortOrder
  }

  export type ContainerHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrder
    previousGardenId?: SortOrder
    newGardenId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
  }

  export type ContainerHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrder
    previousGardenId?: SortOrder
    newGardenId?: SortOrder
  }

  export type ContainerHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrder
    previousGardenId?: SortOrder
    newGardenId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
  }

  export type ContainerHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrder
    previousGardenId?: SortOrder
    newGardenId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
  }

  export type ContainerHistorySumOrderByAggregateInput = {
    id?: SortOrder
    containerId?: SortOrder
    previousContainerId?: SortOrder
    previousGardenId?: SortOrder
    newGardenId?: SortOrder
  }

  export type PlantMovementHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrder
    newContainerId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
    plantConditionBefore?: SortOrder
    plantConditionAfter?: SortOrder
  }

  export type PlantMovementHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrder
    newContainerId?: SortOrder
  }

  export type PlantMovementHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrder
    newContainerId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
    plantConditionBefore?: SortOrder
    plantConditionAfter?: SortOrder
  }

  export type PlantMovementHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrder
    newContainerId?: SortOrder
    moveDate?: SortOrder
    reason?: SortOrder
    plantConditionBefore?: SortOrder
    plantConditionAfter?: SortOrder
  }

  export type PlantMovementHistorySumOrderByAggregateInput = {
    id?: SortOrder
    containerPlantId?: SortOrder
    previousContainerId?: SortOrder
    newContainerId?: SortOrder
  }

  export type SeasonalPlanCountOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    season?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonalPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    year?: SortOrder
  }

  export type SeasonalPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    season?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonalPlanMinOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    season?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonalPlanSumOrderByAggregateInput = {
    id?: SortOrder
    gardenId?: SortOrder
    year?: SortOrder
  }

  export type SeasonalPlanScalarRelationFilter = {
    is?: SeasonalPlanWhereInput
    isNot?: SeasonalPlanWhereInput
  }

  export type PlannedPlantingCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    plannedDate?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type PlannedPlantingAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
  }

  export type PlannedPlantingMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    plannedDate?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type PlannedPlantingMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    plannedDate?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    status?: SortOrder
  }

  export type PlannedPlantingSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    containerId?: SortOrder
    plantId?: SortOrder
    varietyId?: SortOrder
    quantity?: SortOrder
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type TaskPrerequisiteListRelationFilter = {
    every?: TaskPrerequisiteWhereInput
    some?: TaskPrerequisiteWhereInput
    none?: TaskPrerequisiteWhereInput
  }

  export type RecurringTaskPatternNullableScalarRelationFilter = {
    is?: RecurringTaskPatternWhereInput | null
    isNot?: RecurringTaskPatternWhereInput | null
  }

  export type TaskPrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dateCompleted?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRecurring?: SortOrder
    parentTaskId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedMinutes?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    parentTaskId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dateCompleted?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRecurring?: SortOrder
    parentTaskId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedMinutes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    dateCompleted?: SortOrder
    userId?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRecurring?: SortOrder
    parentTaskId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedMinutes?: SortOrder
    gardenId?: SortOrder
    containerId?: SortOrder
    containerPlantId?: SortOrder
    parentTaskId?: SortOrder
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskPrerequisiteTaskIdPrerequisiteTaskIdCompoundUniqueInput = {
    taskId: number
    prerequisiteTaskId: number
  }

  export type TaskPrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskPrerequisiteAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
  }

  export type TaskPrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskPrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskPrerequisiteSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    prerequisiteTaskId?: SortOrder
  }

  export type TaskNoteCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type TaskNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskNoteMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskNoteSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type TaskCompletionLogCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    percentDone?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type TaskCompletionLogAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    percentDone?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type TaskCompletionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    percentDone?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type TaskCompletionLogMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    percentDone?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type TaskCompletionLogSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    percentDone?: SortOrder
    timeSpentMinutes?: SortOrder
  }

  export type RecurringTaskPatternCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrder
    endByDate?: SortOrder
    daysOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    monthOfYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTaskPatternAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrder
    dayOfMonth?: SortOrder
    monthOfYear?: SortOrder
  }

  export type RecurringTaskPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrder
    endByDate?: SortOrder
    daysOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    monthOfYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTaskPatternMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrder
    endByDate?: SortOrder
    daysOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    monthOfYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTaskPatternSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    interval?: SortOrder
    endAfterCount?: SortOrder
    dayOfMonth?: SortOrder
    monthOfYear?: SortOrder
  }

  export type TaskNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type TaskNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type GardenCreateNestedManyWithoutUserInput = {
    create?: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput> | GardenCreateWithoutUserInput[] | GardenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenCreateOrConnectWithoutUserInput | GardenCreateOrConnectWithoutUserInput[]
    createMany?: GardenCreateManyUserInputEnvelope
    connect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
  }

  export type GardenActionCreateNestedManyWithoutUserInput = {
    create?: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput> | GardenActionCreateWithoutUserInput[] | GardenActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutUserInput | GardenActionCreateOrConnectWithoutUserInput[]
    createMany?: GardenActionCreateManyUserInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput> | TaskNoteCreateWithoutUserInput[] | TaskNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutUserInput | TaskNoteCreateOrConnectWithoutUserInput[]
    createMany?: TaskNoteCreateManyUserInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskCompletionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput> | TaskCompletionLogCreateWithoutUserInput[] | TaskCompletionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutUserInput | TaskCompletionLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskCompletionLogCreateManyUserInputEnvelope
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
  }

  export type TaskNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput> | TaskNotificationCreateWithoutUserInput[] | TaskNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutUserInput | TaskNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TaskNotificationCreateManyUserInputEnvelope
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type GardenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput> | GardenCreateWithoutUserInput[] | GardenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenCreateOrConnectWithoutUserInput | GardenCreateOrConnectWithoutUserInput[]
    createMany?: GardenCreateManyUserInputEnvelope
    connect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
  }

  export type GardenActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput> | GardenActionCreateWithoutUserInput[] | GardenActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutUserInput | GardenActionCreateOrConnectWithoutUserInput[]
    createMany?: GardenActionCreateManyUserInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput> | TaskNoteCreateWithoutUserInput[] | TaskNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutUserInput | TaskNoteCreateOrConnectWithoutUserInput[]
    createMany?: TaskNoteCreateManyUserInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput> | TaskCompletionLogCreateWithoutUserInput[] | TaskCompletionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutUserInput | TaskCompletionLogCreateOrConnectWithoutUserInput[]
    createMany?: TaskCompletionLogCreateManyUserInputEnvelope
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
  }

  export type TaskNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput> | TaskNotificationCreateWithoutUserInput[] | TaskNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutUserInput | TaskNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TaskNotificationCreateManyUserInputEnvelope
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type GardenUpdateManyWithoutUserNestedInput = {
    create?: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput> | GardenCreateWithoutUserInput[] | GardenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenCreateOrConnectWithoutUserInput | GardenCreateOrConnectWithoutUserInput[]
    upsert?: GardenUpsertWithWhereUniqueWithoutUserInput | GardenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GardenCreateManyUserInputEnvelope
    set?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    disconnect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    delete?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    connect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    update?: GardenUpdateWithWhereUniqueWithoutUserInput | GardenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GardenUpdateManyWithWhereWithoutUserInput | GardenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GardenScalarWhereInput | GardenScalarWhereInput[]
  }

  export type GardenActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput> | GardenActionCreateWithoutUserInput[] | GardenActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutUserInput | GardenActionCreateOrConnectWithoutUserInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutUserInput | GardenActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GardenActionCreateManyUserInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutUserInput | GardenActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutUserInput | GardenActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput> | TaskNoteCreateWithoutUserInput[] | TaskNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutUserInput | TaskNoteCreateOrConnectWithoutUserInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutUserInput | TaskNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNoteCreateManyUserInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutUserInput | TaskNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutUserInput | TaskNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskCompletionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput> | TaskCompletionLogCreateWithoutUserInput[] | TaskCompletionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutUserInput | TaskCompletionLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskCompletionLogUpsertWithWhereUniqueWithoutUserInput | TaskCompletionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCompletionLogCreateManyUserInputEnvelope
    set?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    disconnect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    delete?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    update?: TaskCompletionLogUpdateWithWhereUniqueWithoutUserInput | TaskCompletionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCompletionLogUpdateManyWithWhereWithoutUserInput | TaskCompletionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
  }

  export type TaskNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput> | TaskNotificationCreateWithoutUserInput[] | TaskNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutUserInput | TaskNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TaskNotificationUpsertWithWhereUniqueWithoutUserInput | TaskNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNotificationCreateManyUserInputEnvelope
    set?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    disconnect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    delete?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    update?: TaskNotificationUpdateWithWhereUniqueWithoutUserInput | TaskNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNotificationUpdateManyWithWhereWithoutUserInput | TaskNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type GardenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput> | GardenCreateWithoutUserInput[] | GardenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenCreateOrConnectWithoutUserInput | GardenCreateOrConnectWithoutUserInput[]
    upsert?: GardenUpsertWithWhereUniqueWithoutUserInput | GardenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GardenCreateManyUserInputEnvelope
    set?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    disconnect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    delete?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    connect?: GardenWhereUniqueInput | GardenWhereUniqueInput[]
    update?: GardenUpdateWithWhereUniqueWithoutUserInput | GardenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GardenUpdateManyWithWhereWithoutUserInput | GardenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GardenScalarWhereInput | GardenScalarWhereInput[]
  }

  export type GardenActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput> | GardenActionCreateWithoutUserInput[] | GardenActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutUserInput | GardenActionCreateOrConnectWithoutUserInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutUserInput | GardenActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GardenActionCreateManyUserInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutUserInput | GardenActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutUserInput | GardenActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput> | TaskNoteCreateWithoutUserInput[] | TaskNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutUserInput | TaskNoteCreateOrConnectWithoutUserInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutUserInput | TaskNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNoteCreateManyUserInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutUserInput | TaskNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutUserInput | TaskNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput> | TaskCompletionLogCreateWithoutUserInput[] | TaskCompletionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutUserInput | TaskCompletionLogCreateOrConnectWithoutUserInput[]
    upsert?: TaskCompletionLogUpsertWithWhereUniqueWithoutUserInput | TaskCompletionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCompletionLogCreateManyUserInputEnvelope
    set?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    disconnect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    delete?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    update?: TaskCompletionLogUpdateWithWhereUniqueWithoutUserInput | TaskCompletionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCompletionLogUpdateManyWithWhereWithoutUserInput | TaskCompletionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
  }

  export type TaskNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput> | TaskNotificationCreateWithoutUserInput[] | TaskNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutUserInput | TaskNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TaskNotificationUpsertWithWhereUniqueWithoutUserInput | TaskNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskNotificationCreateManyUserInputEnvelope
    set?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    disconnect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    delete?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    update?: TaskNotificationUpdateWithWhereUniqueWithoutUserInput | TaskNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskNotificationUpdateManyWithWhereWithoutUserInput | TaskNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutGardensInput = {
    create?: XOR<UserCreateWithoutGardensInput, UserUncheckedCreateWithoutGardensInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardensInput
    connect?: UserWhereUniqueInput
  }

  export type GardenConditionCreateNestedManyWithoutGardenInput = {
    create?: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput> | GardenConditionCreateWithoutGardenInput[] | GardenConditionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenConditionCreateOrConnectWithoutGardenInput | GardenConditionCreateOrConnectWithoutGardenInput[]
    createMany?: GardenConditionCreateManyGardenInputEnvelope
    connect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
  }

  export type ContainerCreateNestedManyWithoutGardenInput = {
    create?: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput> | ContainerCreateWithoutGardenInput[] | ContainerUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenInput | ContainerCreateOrConnectWithoutGardenInput[]
    createMany?: ContainerCreateManyGardenInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type GardenActionCreateNestedManyWithoutGardenInput = {
    create?: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput> | GardenActionCreateWithoutGardenInput[] | GardenActionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutGardenInput | GardenActionCreateOrConnectWithoutGardenInput[]
    createMany?: GardenActionCreateManyGardenInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type SeasonalPlanCreateNestedManyWithoutGardenInput = {
    create?: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput> | SeasonalPlanCreateWithoutGardenInput[] | SeasonalPlanUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutGardenInput | SeasonalPlanCreateOrConnectWithoutGardenInput[]
    createMany?: SeasonalPlanCreateManyGardenInputEnvelope
    connect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
  }

  export type ContainerHistoryCreateNestedManyWithoutPreviousGardenInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput> | ContainerHistoryCreateWithoutPreviousGardenInput[] | ContainerHistoryUncheckedCreateWithoutPreviousGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousGardenInput | ContainerHistoryCreateOrConnectWithoutPreviousGardenInput[]
    createMany?: ContainerHistoryCreateManyPreviousGardenInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type ContainerHistoryCreateNestedManyWithoutNewGardenInput = {
    create?: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput> | ContainerHistoryCreateWithoutNewGardenInput[] | ContainerHistoryUncheckedCreateWithoutNewGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutNewGardenInput | ContainerHistoryCreateOrConnectWithoutNewGardenInput[]
    createMany?: ContainerHistoryCreateManyNewGardenInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutGardenInput = {
    create?: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput> | TaskCreateWithoutGardenInput[] | TaskUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGardenInput | TaskCreateOrConnectWithoutGardenInput[]
    createMany?: TaskCreateManyGardenInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type GardenConditionUncheckedCreateNestedManyWithoutGardenInput = {
    create?: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput> | GardenConditionCreateWithoutGardenInput[] | GardenConditionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenConditionCreateOrConnectWithoutGardenInput | GardenConditionCreateOrConnectWithoutGardenInput[]
    createMany?: GardenConditionCreateManyGardenInputEnvelope
    connect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
  }

  export type ContainerUncheckedCreateNestedManyWithoutGardenInput = {
    create?: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput> | ContainerCreateWithoutGardenInput[] | ContainerUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenInput | ContainerCreateOrConnectWithoutGardenInput[]
    createMany?: ContainerCreateManyGardenInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type GardenActionUncheckedCreateNestedManyWithoutGardenInput = {
    create?: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput> | GardenActionCreateWithoutGardenInput[] | GardenActionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutGardenInput | GardenActionCreateOrConnectWithoutGardenInput[]
    createMany?: GardenActionCreateManyGardenInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput = {
    create?: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput> | SeasonalPlanCreateWithoutGardenInput[] | SeasonalPlanUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutGardenInput | SeasonalPlanCreateOrConnectWithoutGardenInput[]
    createMany?: SeasonalPlanCreateManyGardenInputEnvelope
    connect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
  }

  export type ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput> | ContainerHistoryCreateWithoutPreviousGardenInput[] | ContainerHistoryUncheckedCreateWithoutPreviousGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousGardenInput | ContainerHistoryCreateOrConnectWithoutPreviousGardenInput[]
    createMany?: ContainerHistoryCreateManyPreviousGardenInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput = {
    create?: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput> | ContainerHistoryCreateWithoutNewGardenInput[] | ContainerHistoryUncheckedCreateWithoutNewGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutNewGardenInput | ContainerHistoryCreateOrConnectWithoutNewGardenInput[]
    createMany?: ContainerHistoryCreateManyNewGardenInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutGardenInput = {
    create?: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput> | TaskCreateWithoutGardenInput[] | TaskUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGardenInput | TaskCreateOrConnectWithoutGardenInput[]
    createMany?: TaskCreateManyGardenInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutGardensNestedInput = {
    create?: XOR<UserCreateWithoutGardensInput, UserUncheckedCreateWithoutGardensInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardensInput
    upsert?: UserUpsertWithoutGardensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGardensInput, UserUpdateWithoutGardensInput>, UserUncheckedUpdateWithoutGardensInput>
  }

  export type GardenConditionUpdateManyWithoutGardenNestedInput = {
    create?: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput> | GardenConditionCreateWithoutGardenInput[] | GardenConditionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenConditionCreateOrConnectWithoutGardenInput | GardenConditionCreateOrConnectWithoutGardenInput[]
    upsert?: GardenConditionUpsertWithWhereUniqueWithoutGardenInput | GardenConditionUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: GardenConditionCreateManyGardenInputEnvelope
    set?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    disconnect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    delete?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    connect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    update?: GardenConditionUpdateWithWhereUniqueWithoutGardenInput | GardenConditionUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: GardenConditionUpdateManyWithWhereWithoutGardenInput | GardenConditionUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: GardenConditionScalarWhereInput | GardenConditionScalarWhereInput[]
  }

  export type ContainerUpdateManyWithoutGardenNestedInput = {
    create?: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput> | ContainerCreateWithoutGardenInput[] | ContainerUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenInput | ContainerCreateOrConnectWithoutGardenInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutGardenInput | ContainerUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: ContainerCreateManyGardenInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutGardenInput | ContainerUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutGardenInput | ContainerUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type GardenActionUpdateManyWithoutGardenNestedInput = {
    create?: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput> | GardenActionCreateWithoutGardenInput[] | GardenActionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutGardenInput | GardenActionCreateOrConnectWithoutGardenInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutGardenInput | GardenActionUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: GardenActionCreateManyGardenInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutGardenInput | GardenActionUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutGardenInput | GardenActionUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type SeasonalPlanUpdateManyWithoutGardenNestedInput = {
    create?: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput> | SeasonalPlanCreateWithoutGardenInput[] | SeasonalPlanUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutGardenInput | SeasonalPlanCreateOrConnectWithoutGardenInput[]
    upsert?: SeasonalPlanUpsertWithWhereUniqueWithoutGardenInput | SeasonalPlanUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: SeasonalPlanCreateManyGardenInputEnvelope
    set?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    disconnect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    delete?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    connect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    update?: SeasonalPlanUpdateWithWhereUniqueWithoutGardenInput | SeasonalPlanUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: SeasonalPlanUpdateManyWithWhereWithoutGardenInput | SeasonalPlanUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: SeasonalPlanScalarWhereInput | SeasonalPlanScalarWhereInput[]
  }

  export type ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput> | ContainerHistoryCreateWithoutPreviousGardenInput[] | ContainerHistoryUncheckedCreateWithoutPreviousGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousGardenInput | ContainerHistoryCreateOrConnectWithoutPreviousGardenInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutPreviousGardenInput | ContainerHistoryUpsertWithWhereUniqueWithoutPreviousGardenInput[]
    createMany?: ContainerHistoryCreateManyPreviousGardenInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutPreviousGardenInput | ContainerHistoryUpdateWithWhereUniqueWithoutPreviousGardenInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutPreviousGardenInput | ContainerHistoryUpdateManyWithWhereWithoutPreviousGardenInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type ContainerHistoryUpdateManyWithoutNewGardenNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput> | ContainerHistoryCreateWithoutNewGardenInput[] | ContainerHistoryUncheckedCreateWithoutNewGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutNewGardenInput | ContainerHistoryCreateOrConnectWithoutNewGardenInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutNewGardenInput | ContainerHistoryUpsertWithWhereUniqueWithoutNewGardenInput[]
    createMany?: ContainerHistoryCreateManyNewGardenInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutNewGardenInput | ContainerHistoryUpdateWithWhereUniqueWithoutNewGardenInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutNewGardenInput | ContainerHistoryUpdateManyWithWhereWithoutNewGardenInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutGardenNestedInput = {
    create?: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput> | TaskCreateWithoutGardenInput[] | TaskUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGardenInput | TaskCreateOrConnectWithoutGardenInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGardenInput | TaskUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: TaskCreateManyGardenInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGardenInput | TaskUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGardenInput | TaskUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GardenConditionUncheckedUpdateManyWithoutGardenNestedInput = {
    create?: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput> | GardenConditionCreateWithoutGardenInput[] | GardenConditionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenConditionCreateOrConnectWithoutGardenInput | GardenConditionCreateOrConnectWithoutGardenInput[]
    upsert?: GardenConditionUpsertWithWhereUniqueWithoutGardenInput | GardenConditionUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: GardenConditionCreateManyGardenInputEnvelope
    set?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    disconnect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    delete?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    connect?: GardenConditionWhereUniqueInput | GardenConditionWhereUniqueInput[]
    update?: GardenConditionUpdateWithWhereUniqueWithoutGardenInput | GardenConditionUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: GardenConditionUpdateManyWithWhereWithoutGardenInput | GardenConditionUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: GardenConditionScalarWhereInput | GardenConditionScalarWhereInput[]
  }

  export type ContainerUncheckedUpdateManyWithoutGardenNestedInput = {
    create?: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput> | ContainerCreateWithoutGardenInput[] | ContainerUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenInput | ContainerCreateOrConnectWithoutGardenInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutGardenInput | ContainerUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: ContainerCreateManyGardenInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutGardenInput | ContainerUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutGardenInput | ContainerUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type GardenActionUncheckedUpdateManyWithoutGardenNestedInput = {
    create?: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput> | GardenActionCreateWithoutGardenInput[] | GardenActionUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutGardenInput | GardenActionCreateOrConnectWithoutGardenInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutGardenInput | GardenActionUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: GardenActionCreateManyGardenInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutGardenInput | GardenActionUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutGardenInput | GardenActionUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput = {
    create?: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput> | SeasonalPlanCreateWithoutGardenInput[] | SeasonalPlanUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutGardenInput | SeasonalPlanCreateOrConnectWithoutGardenInput[]
    upsert?: SeasonalPlanUpsertWithWhereUniqueWithoutGardenInput | SeasonalPlanUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: SeasonalPlanCreateManyGardenInputEnvelope
    set?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    disconnect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    delete?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    connect?: SeasonalPlanWhereUniqueInput | SeasonalPlanWhereUniqueInput[]
    update?: SeasonalPlanUpdateWithWhereUniqueWithoutGardenInput | SeasonalPlanUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: SeasonalPlanUpdateManyWithWhereWithoutGardenInput | SeasonalPlanUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: SeasonalPlanScalarWhereInput | SeasonalPlanScalarWhereInput[]
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput> | ContainerHistoryCreateWithoutPreviousGardenInput[] | ContainerHistoryUncheckedCreateWithoutPreviousGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousGardenInput | ContainerHistoryCreateOrConnectWithoutPreviousGardenInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutPreviousGardenInput | ContainerHistoryUpsertWithWhereUniqueWithoutPreviousGardenInput[]
    createMany?: ContainerHistoryCreateManyPreviousGardenInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutPreviousGardenInput | ContainerHistoryUpdateWithWhereUniqueWithoutPreviousGardenInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutPreviousGardenInput | ContainerHistoryUpdateManyWithWhereWithoutPreviousGardenInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput> | ContainerHistoryCreateWithoutNewGardenInput[] | ContainerHistoryUncheckedCreateWithoutNewGardenInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutNewGardenInput | ContainerHistoryCreateOrConnectWithoutNewGardenInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutNewGardenInput | ContainerHistoryUpsertWithWhereUniqueWithoutNewGardenInput[]
    createMany?: ContainerHistoryCreateManyNewGardenInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutNewGardenInput | ContainerHistoryUpdateWithWhereUniqueWithoutNewGardenInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutNewGardenInput | ContainerHistoryUpdateManyWithWhereWithoutNewGardenInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutGardenNestedInput = {
    create?: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput> | TaskCreateWithoutGardenInput[] | TaskUncheckedCreateWithoutGardenInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGardenInput | TaskCreateOrConnectWithoutGardenInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGardenInput | TaskUpsertWithWhereUniqueWithoutGardenInput[]
    createMany?: TaskCreateManyGardenInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGardenInput | TaskUpdateWithWhereUniqueWithoutGardenInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGardenInput | TaskUpdateManyWithWhereWithoutGardenInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type GardenCreateNestedOneWithoutConditionsInput = {
    create?: XOR<GardenCreateWithoutConditionsInput, GardenUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: GardenCreateOrConnectWithoutConditionsInput
    connect?: GardenWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GardenUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<GardenCreateWithoutConditionsInput, GardenUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: GardenCreateOrConnectWithoutConditionsInput
    upsert?: GardenUpsertWithoutConditionsInput
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutConditionsInput, GardenUpdateWithoutConditionsInput>, GardenUncheckedUpdateWithoutConditionsInput>
  }

  export type ContainerCreateNestedManyWithoutContainerTypeInput = {
    create?: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput> | ContainerCreateWithoutContainerTypeInput[] | ContainerUncheckedCreateWithoutContainerTypeInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerTypeInput | ContainerCreateOrConnectWithoutContainerTypeInput[]
    createMany?: ContainerCreateManyContainerTypeInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type ContainerUncheckedCreateNestedManyWithoutContainerTypeInput = {
    create?: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput> | ContainerCreateWithoutContainerTypeInput[] | ContainerUncheckedCreateWithoutContainerTypeInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerTypeInput | ContainerCreateOrConnectWithoutContainerTypeInput[]
    createMany?: ContainerCreateManyContainerTypeInputEnvelope
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
  }

  export type ContainerUpdateManyWithoutContainerTypeNestedInput = {
    create?: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput> | ContainerCreateWithoutContainerTypeInput[] | ContainerUncheckedCreateWithoutContainerTypeInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerTypeInput | ContainerCreateOrConnectWithoutContainerTypeInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutContainerTypeInput | ContainerUpsertWithWhereUniqueWithoutContainerTypeInput[]
    createMany?: ContainerCreateManyContainerTypeInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutContainerTypeInput | ContainerUpdateWithWhereUniqueWithoutContainerTypeInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutContainerTypeInput | ContainerUpdateManyWithWhereWithoutContainerTypeInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type ContainerUncheckedUpdateManyWithoutContainerTypeNestedInput = {
    create?: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput> | ContainerCreateWithoutContainerTypeInput[] | ContainerUncheckedCreateWithoutContainerTypeInput[]
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerTypeInput | ContainerCreateOrConnectWithoutContainerTypeInput[]
    upsert?: ContainerUpsertWithWhereUniqueWithoutContainerTypeInput | ContainerUpsertWithWhereUniqueWithoutContainerTypeInput[]
    createMany?: ContainerCreateManyContainerTypeInputEnvelope
    set?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    disconnect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    delete?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    connect?: ContainerWhereUniqueInput | ContainerWhereUniqueInput[]
    update?: ContainerUpdateWithWhereUniqueWithoutContainerTypeInput | ContainerUpdateWithWhereUniqueWithoutContainerTypeInput[]
    updateMany?: ContainerUpdateManyWithWhereWithoutContainerTypeInput | ContainerUpdateManyWithWhereWithoutContainerTypeInput[]
    deleteMany?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
  }

  export type GardenCreateNestedOneWithoutContainersInput = {
    create?: XOR<GardenCreateWithoutContainersInput, GardenUncheckedCreateWithoutContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutContainersInput
    connect?: GardenWhereUniqueInput
  }

  export type ContainerTypeCreateNestedOneWithoutContainersInput = {
    create?: XOR<ContainerTypeCreateWithoutContainersInput, ContainerTypeUncheckedCreateWithoutContainersInput>
    connectOrCreate?: ContainerTypeCreateOrConnectWithoutContainersInput
    connect?: ContainerTypeWhereUniqueInput
  }

  export type ContainerPlantCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput> | ContainerPlantCreateWithoutContainerInput[] | ContainerPlantUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutContainerInput | ContainerPlantCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerPlantCreateManyContainerInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type GardenActionCreateNestedManyWithoutContainerInput = {
    create?: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput> | GardenActionCreateWithoutContainerInput[] | GardenActionUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerInput | GardenActionCreateOrConnectWithoutContainerInput[]
    createMany?: GardenActionCreateManyContainerInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type ContainerHistoryCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput> | ContainerHistoryCreateWithoutContainerInput[] | ContainerHistoryUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutContainerInput | ContainerHistoryCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerHistoryCreateManyContainerInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type ContainerHistoryCreateNestedManyWithoutPreviousContainerInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput> | ContainerHistoryCreateWithoutPreviousContainerInput[] | ContainerHistoryUncheckedCreateWithoutPreviousContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousContainerInput | ContainerHistoryCreateOrConnectWithoutPreviousContainerInput[]
    createMany?: ContainerHistoryCreateManyPreviousContainerInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type PlannedPlantingCreateNestedManyWithoutContainerInput = {
    create?: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput> | PlannedPlantingCreateWithoutContainerInput[] | PlannedPlantingUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutContainerInput | PlannedPlantingCreateOrConnectWithoutContainerInput[]
    createMany?: PlannedPlantingCreateManyContainerInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutContainerInput = {
    create?: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput> | TaskCreateWithoutContainerInput[] | TaskUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerInput | TaskCreateOrConnectWithoutContainerInput[]
    createMany?: TaskCreateManyContainerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ContainerPlantUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput> | ContainerPlantCreateWithoutContainerInput[] | ContainerPlantUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutContainerInput | ContainerPlantCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerPlantCreateManyContainerInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type GardenActionUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput> | GardenActionCreateWithoutContainerInput[] | GardenActionUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerInput | GardenActionCreateOrConnectWithoutContainerInput[]
    createMany?: GardenActionCreateManyContainerInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput> | ContainerHistoryCreateWithoutContainerInput[] | ContainerHistoryUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutContainerInput | ContainerHistoryCreateOrConnectWithoutContainerInput[]
    createMany?: ContainerHistoryCreateManyContainerInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput> | ContainerHistoryCreateWithoutPreviousContainerInput[] | ContainerHistoryUncheckedCreateWithoutPreviousContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousContainerInput | ContainerHistoryCreateOrConnectWithoutPreviousContainerInput[]
    createMany?: ContainerHistoryCreateManyPreviousContainerInputEnvelope
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
  }

  export type PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput> | PlannedPlantingCreateWithoutContainerInput[] | PlannedPlantingUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutContainerInput | PlannedPlantingCreateOrConnectWithoutContainerInput[]
    createMany?: PlannedPlantingCreateManyContainerInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput> | TaskCreateWithoutContainerInput[] | TaskUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerInput | TaskCreateOrConnectWithoutContainerInput[]
    createMany?: TaskCreateManyContainerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type GardenUpdateOneRequiredWithoutContainersNestedInput = {
    create?: XOR<GardenCreateWithoutContainersInput, GardenUncheckedCreateWithoutContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutContainersInput
    upsert?: GardenUpsertWithoutContainersInput
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutContainersInput, GardenUpdateWithoutContainersInput>, GardenUncheckedUpdateWithoutContainersInput>
  }

  export type ContainerTypeUpdateOneRequiredWithoutContainersNestedInput = {
    create?: XOR<ContainerTypeCreateWithoutContainersInput, ContainerTypeUncheckedCreateWithoutContainersInput>
    connectOrCreate?: ContainerTypeCreateOrConnectWithoutContainersInput
    upsert?: ContainerTypeUpsertWithoutContainersInput
    connect?: ContainerTypeWhereUniqueInput
    update?: XOR<XOR<ContainerTypeUpdateToOneWithWhereWithoutContainersInput, ContainerTypeUpdateWithoutContainersInput>, ContainerTypeUncheckedUpdateWithoutContainersInput>
  }

  export type ContainerPlantUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput> | ContainerPlantCreateWithoutContainerInput[] | ContainerPlantUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutContainerInput | ContainerPlantCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutContainerInput | ContainerPlantUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerPlantCreateManyContainerInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutContainerInput | ContainerPlantUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutContainerInput | ContainerPlantUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type GardenActionUpdateManyWithoutContainerNestedInput = {
    create?: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput> | GardenActionCreateWithoutContainerInput[] | GardenActionUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerInput | GardenActionCreateOrConnectWithoutContainerInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutContainerInput | GardenActionUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: GardenActionCreateManyContainerInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutContainerInput | GardenActionUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutContainerInput | GardenActionUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type ContainerHistoryUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput> | ContainerHistoryCreateWithoutContainerInput[] | ContainerHistoryUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutContainerInput | ContainerHistoryCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutContainerInput | ContainerHistoryUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerHistoryCreateManyContainerInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutContainerInput | ContainerHistoryUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutContainerInput | ContainerHistoryUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput> | ContainerHistoryCreateWithoutPreviousContainerInput[] | ContainerHistoryUncheckedCreateWithoutPreviousContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousContainerInput | ContainerHistoryCreateOrConnectWithoutPreviousContainerInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutPreviousContainerInput | ContainerHistoryUpsertWithWhereUniqueWithoutPreviousContainerInput[]
    createMany?: ContainerHistoryCreateManyPreviousContainerInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutPreviousContainerInput | ContainerHistoryUpdateWithWhereUniqueWithoutPreviousContainerInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutPreviousContainerInput | ContainerHistoryUpdateManyWithWhereWithoutPreviousContainerInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type PlannedPlantingUpdateManyWithoutContainerNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput> | PlannedPlantingCreateWithoutContainerInput[] | PlannedPlantingUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutContainerInput | PlannedPlantingCreateOrConnectWithoutContainerInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutContainerInput | PlannedPlantingUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: PlannedPlantingCreateManyContainerInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutContainerInput | PlannedPlantingUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutContainerInput | PlannedPlantingUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutContainerNestedInput = {
    create?: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput> | TaskCreateWithoutContainerInput[] | TaskUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerInput | TaskCreateOrConnectWithoutContainerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutContainerInput | TaskUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: TaskCreateManyContainerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutContainerInput | TaskUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutContainerInput | TaskUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput> | ContainerPlantCreateWithoutContainerInput[] | ContainerPlantUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutContainerInput | ContainerPlantCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutContainerInput | ContainerPlantUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerPlantCreateManyContainerInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutContainerInput | ContainerPlantUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutContainerInput | ContainerPlantUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type GardenActionUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput> | GardenActionCreateWithoutContainerInput[] | GardenActionUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerInput | GardenActionCreateOrConnectWithoutContainerInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutContainerInput | GardenActionUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: GardenActionCreateManyContainerInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutContainerInput | GardenActionUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutContainerInput | GardenActionUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput> | ContainerHistoryCreateWithoutContainerInput[] | ContainerHistoryUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutContainerInput | ContainerHistoryCreateOrConnectWithoutContainerInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutContainerInput | ContainerHistoryUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: ContainerHistoryCreateManyContainerInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutContainerInput | ContainerHistoryUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutContainerInput | ContainerHistoryUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput = {
    create?: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput> | ContainerHistoryCreateWithoutPreviousContainerInput[] | ContainerHistoryUncheckedCreateWithoutPreviousContainerInput[]
    connectOrCreate?: ContainerHistoryCreateOrConnectWithoutPreviousContainerInput | ContainerHistoryCreateOrConnectWithoutPreviousContainerInput[]
    upsert?: ContainerHistoryUpsertWithWhereUniqueWithoutPreviousContainerInput | ContainerHistoryUpsertWithWhereUniqueWithoutPreviousContainerInput[]
    createMany?: ContainerHistoryCreateManyPreviousContainerInputEnvelope
    set?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    disconnect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    delete?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    connect?: ContainerHistoryWhereUniqueInput | ContainerHistoryWhereUniqueInput[]
    update?: ContainerHistoryUpdateWithWhereUniqueWithoutPreviousContainerInput | ContainerHistoryUpdateWithWhereUniqueWithoutPreviousContainerInput[]
    updateMany?: ContainerHistoryUpdateManyWithWhereWithoutPreviousContainerInput | ContainerHistoryUpdateManyWithWhereWithoutPreviousContainerInput[]
    deleteMany?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput> | PlannedPlantingCreateWithoutContainerInput[] | PlannedPlantingUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutContainerInput | PlannedPlantingCreateOrConnectWithoutContainerInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutContainerInput | PlannedPlantingUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: PlannedPlantingCreateManyContainerInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutContainerInput | PlannedPlantingUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutContainerInput | PlannedPlantingUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput> | TaskCreateWithoutContainerInput[] | TaskUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerInput | TaskCreateOrConnectWithoutContainerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutContainerInput | TaskUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: TaskCreateManyContainerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutContainerInput | TaskUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutContainerInput | TaskUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PlantGrowingConditionCreateNestedOneWithoutPlantInput = {
    create?: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
    connectOrCreate?: PlantGrowingConditionCreateOrConnectWithoutPlantInput
    connect?: PlantGrowingConditionWhereUniqueInput
  }

  export type PlantClimateZoneCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput> | PlantClimateZoneCreateWithoutPlantInput[] | PlantClimateZoneUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantClimateZoneCreateOrConnectWithoutPlantInput | PlantClimateZoneCreateOrConnectWithoutPlantInput[]
    createMany?: PlantClimateZoneCreateManyPlantInputEnvelope
    connect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
  }

  export type PlantVarietyCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput> | PlantVarietyCreateWithoutPlantInput[] | PlantVarietyUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlantInput | PlantVarietyCreateOrConnectWithoutPlantInput[]
    createMany?: PlantVarietyCreateManyPlantInputEnvelope
    connect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
  }

  export type PlantCompanionCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput> | PlantCompanionCreateWithoutPlantInput[] | PlantCompanionUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutPlantInput | PlantCompanionCreateOrConnectWithoutPlantInput[]
    createMany?: PlantCompanionCreateManyPlantInputEnvelope
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
  }

  export type PlantCompanionCreateNestedManyWithoutCompanionPlantInput = {
    create?: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput> | PlantCompanionCreateWithoutCompanionPlantInput[] | PlantCompanionUncheckedCreateWithoutCompanionPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutCompanionPlantInput | PlantCompanionCreateOrConnectWithoutCompanionPlantInput[]
    createMany?: PlantCompanionCreateManyCompanionPlantInputEnvelope
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
  }

  export type ContainerPlantCreateNestedManyWithoutPlantInput = {
    create?: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput> | ContainerPlantCreateWithoutPlantInput[] | ContainerPlantUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutPlantInput | ContainerPlantCreateOrConnectWithoutPlantInput[]
    createMany?: ContainerPlantCreateManyPlantInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type PlannedPlantingCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput> | PlannedPlantingCreateWithoutPlantInput[] | PlannedPlantingUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlantInput | PlannedPlantingCreateOrConnectWithoutPlantInput[]
    createMany?: PlannedPlantingCreateManyPlantInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput = {
    create?: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
    connectOrCreate?: PlantGrowingConditionCreateOrConnectWithoutPlantInput
    connect?: PlantGrowingConditionWhereUniqueInput
  }

  export type PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput> | PlantClimateZoneCreateWithoutPlantInput[] | PlantClimateZoneUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantClimateZoneCreateOrConnectWithoutPlantInput | PlantClimateZoneCreateOrConnectWithoutPlantInput[]
    createMany?: PlantClimateZoneCreateManyPlantInputEnvelope
    connect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
  }

  export type PlantVarietyUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput> | PlantVarietyCreateWithoutPlantInput[] | PlantVarietyUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlantInput | PlantVarietyCreateOrConnectWithoutPlantInput[]
    createMany?: PlantVarietyCreateManyPlantInputEnvelope
    connect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
  }

  export type PlantCompanionUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput> | PlantCompanionCreateWithoutPlantInput[] | PlantCompanionUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutPlantInput | PlantCompanionCreateOrConnectWithoutPlantInput[]
    createMany?: PlantCompanionCreateManyPlantInputEnvelope
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
  }

  export type PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput = {
    create?: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput> | PlantCompanionCreateWithoutCompanionPlantInput[] | PlantCompanionUncheckedCreateWithoutCompanionPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutCompanionPlantInput | PlantCompanionCreateOrConnectWithoutCompanionPlantInput[]
    createMany?: PlantCompanionCreateManyCompanionPlantInputEnvelope
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
  }

  export type ContainerPlantUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput> | ContainerPlantCreateWithoutPlantInput[] | ContainerPlantUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutPlantInput | ContainerPlantCreateOrConnectWithoutPlantInput[]
    createMany?: ContainerPlantCreateManyPlantInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput> | PlannedPlantingCreateWithoutPlantInput[] | PlannedPlantingUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlantInput | PlannedPlantingCreateOrConnectWithoutPlantInput[]
    createMany?: PlannedPlantingCreateManyPlantInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type PlantGrowingConditionUpdateOneWithoutPlantNestedInput = {
    create?: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
    connectOrCreate?: PlantGrowingConditionCreateOrConnectWithoutPlantInput
    upsert?: PlantGrowingConditionUpsertWithoutPlantInput
    disconnect?: PlantGrowingConditionWhereInput | boolean
    delete?: PlantGrowingConditionWhereInput | boolean
    connect?: PlantGrowingConditionWhereUniqueInput
    update?: XOR<XOR<PlantGrowingConditionUpdateToOneWithWhereWithoutPlantInput, PlantGrowingConditionUpdateWithoutPlantInput>, PlantGrowingConditionUncheckedUpdateWithoutPlantInput>
  }

  export type PlantClimateZoneUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput> | PlantClimateZoneCreateWithoutPlantInput[] | PlantClimateZoneUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantClimateZoneCreateOrConnectWithoutPlantInput | PlantClimateZoneCreateOrConnectWithoutPlantInput[]
    upsert?: PlantClimateZoneUpsertWithWhereUniqueWithoutPlantInput | PlantClimateZoneUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantClimateZoneCreateManyPlantInputEnvelope
    set?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    disconnect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    delete?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    connect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    update?: PlantClimateZoneUpdateWithWhereUniqueWithoutPlantInput | PlantClimateZoneUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantClimateZoneUpdateManyWithWhereWithoutPlantInput | PlantClimateZoneUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantClimateZoneScalarWhereInput | PlantClimateZoneScalarWhereInput[]
  }

  export type PlantVarietyUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput> | PlantVarietyCreateWithoutPlantInput[] | PlantVarietyUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlantInput | PlantVarietyCreateOrConnectWithoutPlantInput[]
    upsert?: PlantVarietyUpsertWithWhereUniqueWithoutPlantInput | PlantVarietyUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantVarietyCreateManyPlantInputEnvelope
    set?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    disconnect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    delete?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    connect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    update?: PlantVarietyUpdateWithWhereUniqueWithoutPlantInput | PlantVarietyUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantVarietyUpdateManyWithWhereWithoutPlantInput | PlantVarietyUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantVarietyScalarWhereInput | PlantVarietyScalarWhereInput[]
  }

  export type PlantCompanionUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput> | PlantCompanionCreateWithoutPlantInput[] | PlantCompanionUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutPlantInput | PlantCompanionCreateOrConnectWithoutPlantInput[]
    upsert?: PlantCompanionUpsertWithWhereUniqueWithoutPlantInput | PlantCompanionUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantCompanionCreateManyPlantInputEnvelope
    set?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    disconnect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    delete?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    update?: PlantCompanionUpdateWithWhereUniqueWithoutPlantInput | PlantCompanionUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantCompanionUpdateManyWithWhereWithoutPlantInput | PlantCompanionUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
  }

  export type PlantCompanionUpdateManyWithoutCompanionPlantNestedInput = {
    create?: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput> | PlantCompanionCreateWithoutCompanionPlantInput[] | PlantCompanionUncheckedCreateWithoutCompanionPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutCompanionPlantInput | PlantCompanionCreateOrConnectWithoutCompanionPlantInput[]
    upsert?: PlantCompanionUpsertWithWhereUniqueWithoutCompanionPlantInput | PlantCompanionUpsertWithWhereUniqueWithoutCompanionPlantInput[]
    createMany?: PlantCompanionCreateManyCompanionPlantInputEnvelope
    set?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    disconnect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    delete?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    update?: PlantCompanionUpdateWithWhereUniqueWithoutCompanionPlantInput | PlantCompanionUpdateWithWhereUniqueWithoutCompanionPlantInput[]
    updateMany?: PlantCompanionUpdateManyWithWhereWithoutCompanionPlantInput | PlantCompanionUpdateManyWithWhereWithoutCompanionPlantInput[]
    deleteMany?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
  }

  export type ContainerPlantUpdateManyWithoutPlantNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput> | ContainerPlantCreateWithoutPlantInput[] | ContainerPlantUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutPlantInput | ContainerPlantCreateOrConnectWithoutPlantInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutPlantInput | ContainerPlantUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: ContainerPlantCreateManyPlantInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutPlantInput | ContainerPlantUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutPlantInput | ContainerPlantUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type PlannedPlantingUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput> | PlannedPlantingCreateWithoutPlantInput[] | PlannedPlantingUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlantInput | PlannedPlantingCreateOrConnectWithoutPlantInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutPlantInput | PlannedPlantingUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlannedPlantingCreateManyPlantInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutPlantInput | PlannedPlantingUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutPlantInput | PlannedPlantingUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput = {
    create?: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
    connectOrCreate?: PlantGrowingConditionCreateOrConnectWithoutPlantInput
    upsert?: PlantGrowingConditionUpsertWithoutPlantInput
    disconnect?: PlantGrowingConditionWhereInput | boolean
    delete?: PlantGrowingConditionWhereInput | boolean
    connect?: PlantGrowingConditionWhereUniqueInput
    update?: XOR<XOR<PlantGrowingConditionUpdateToOneWithWhereWithoutPlantInput, PlantGrowingConditionUpdateWithoutPlantInput>, PlantGrowingConditionUncheckedUpdateWithoutPlantInput>
  }

  export type PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput> | PlantClimateZoneCreateWithoutPlantInput[] | PlantClimateZoneUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantClimateZoneCreateOrConnectWithoutPlantInput | PlantClimateZoneCreateOrConnectWithoutPlantInput[]
    upsert?: PlantClimateZoneUpsertWithWhereUniqueWithoutPlantInput | PlantClimateZoneUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantClimateZoneCreateManyPlantInputEnvelope
    set?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    disconnect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    delete?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    connect?: PlantClimateZoneWhereUniqueInput | PlantClimateZoneWhereUniqueInput[]
    update?: PlantClimateZoneUpdateWithWhereUniqueWithoutPlantInput | PlantClimateZoneUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantClimateZoneUpdateManyWithWhereWithoutPlantInput | PlantClimateZoneUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantClimateZoneScalarWhereInput | PlantClimateZoneScalarWhereInput[]
  }

  export type PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput> | PlantVarietyCreateWithoutPlantInput[] | PlantVarietyUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlantInput | PlantVarietyCreateOrConnectWithoutPlantInput[]
    upsert?: PlantVarietyUpsertWithWhereUniqueWithoutPlantInput | PlantVarietyUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantVarietyCreateManyPlantInputEnvelope
    set?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    disconnect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    delete?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    connect?: PlantVarietyWhereUniqueInput | PlantVarietyWhereUniqueInput[]
    update?: PlantVarietyUpdateWithWhereUniqueWithoutPlantInput | PlantVarietyUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantVarietyUpdateManyWithWhereWithoutPlantInput | PlantVarietyUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantVarietyScalarWhereInput | PlantVarietyScalarWhereInput[]
  }

  export type PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput> | PlantCompanionCreateWithoutPlantInput[] | PlantCompanionUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutPlantInput | PlantCompanionCreateOrConnectWithoutPlantInput[]
    upsert?: PlantCompanionUpsertWithWhereUniqueWithoutPlantInput | PlantCompanionUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlantCompanionCreateManyPlantInputEnvelope
    set?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    disconnect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    delete?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    update?: PlantCompanionUpdateWithWhereUniqueWithoutPlantInput | PlantCompanionUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlantCompanionUpdateManyWithWhereWithoutPlantInput | PlantCompanionUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
  }

  export type PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput = {
    create?: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput> | PlantCompanionCreateWithoutCompanionPlantInput[] | PlantCompanionUncheckedCreateWithoutCompanionPlantInput[]
    connectOrCreate?: PlantCompanionCreateOrConnectWithoutCompanionPlantInput | PlantCompanionCreateOrConnectWithoutCompanionPlantInput[]
    upsert?: PlantCompanionUpsertWithWhereUniqueWithoutCompanionPlantInput | PlantCompanionUpsertWithWhereUniqueWithoutCompanionPlantInput[]
    createMany?: PlantCompanionCreateManyCompanionPlantInputEnvelope
    set?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    disconnect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    delete?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    connect?: PlantCompanionWhereUniqueInput | PlantCompanionWhereUniqueInput[]
    update?: PlantCompanionUpdateWithWhereUniqueWithoutCompanionPlantInput | PlantCompanionUpdateWithWhereUniqueWithoutCompanionPlantInput[]
    updateMany?: PlantCompanionUpdateManyWithWhereWithoutCompanionPlantInput | PlantCompanionUpdateManyWithWhereWithoutCompanionPlantInput[]
    deleteMany?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
  }

  export type ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput> | ContainerPlantCreateWithoutPlantInput[] | ContainerPlantUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutPlantInput | ContainerPlantCreateOrConnectWithoutPlantInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutPlantInput | ContainerPlantUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: ContainerPlantCreateManyPlantInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutPlantInput | ContainerPlantUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutPlantInput | ContainerPlantUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput> | PlannedPlantingCreateWithoutPlantInput[] | PlannedPlantingUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlantInput | PlannedPlantingCreateOrConnectWithoutPlantInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutPlantInput | PlannedPlantingUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: PlannedPlantingCreateManyPlantInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutPlantInput | PlannedPlantingUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutPlantInput | PlannedPlantingUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type PlantCatalogCreateNestedOneWithoutGrowingConditionsInput = {
    create?: XOR<PlantCatalogCreateWithoutGrowingConditionsInput, PlantCatalogUncheckedCreateWithoutGrowingConditionsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutGrowingConditionsInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantCatalogUpdateOneRequiredWithoutGrowingConditionsNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutGrowingConditionsInput, PlantCatalogUncheckedCreateWithoutGrowingConditionsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutGrowingConditionsInput
    upsert?: PlantCatalogUpsertWithoutGrowingConditionsInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutGrowingConditionsInput, PlantCatalogUpdateWithoutGrowingConditionsInput>, PlantCatalogUncheckedUpdateWithoutGrowingConditionsInput>
  }

  export type PlantCatalogCreateNestedOneWithoutClimateZonesInput = {
    create?: XOR<PlantCatalogCreateWithoutClimateZonesInput, PlantCatalogUncheckedCreateWithoutClimateZonesInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutClimateZonesInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantCatalogUpdateOneRequiredWithoutClimateZonesNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutClimateZonesInput, PlantCatalogUncheckedCreateWithoutClimateZonesInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutClimateZonesInput
    upsert?: PlantCatalogUpsertWithoutClimateZonesInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutClimateZonesInput, PlantCatalogUpdateWithoutClimateZonesInput>, PlantCatalogUncheckedUpdateWithoutClimateZonesInput>
  }

  export type PlantCatalogCreateNestedOneWithoutVarietiesInput = {
    create?: XOR<PlantCatalogCreateWithoutVarietiesInput, PlantCatalogUncheckedCreateWithoutVarietiesInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutVarietiesInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type ContainerPlantCreateNestedManyWithoutVarietyInput = {
    create?: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput> | ContainerPlantCreateWithoutVarietyInput[] | ContainerPlantUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutVarietyInput | ContainerPlantCreateOrConnectWithoutVarietyInput[]
    createMany?: ContainerPlantCreateManyVarietyInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type PlannedPlantingCreateNestedManyWithoutVarietyInput = {
    create?: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput> | PlannedPlantingCreateWithoutVarietyInput[] | PlannedPlantingUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutVarietyInput | PlannedPlantingCreateOrConnectWithoutVarietyInput[]
    createMany?: PlannedPlantingCreateManyVarietyInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type ContainerPlantUncheckedCreateNestedManyWithoutVarietyInput = {
    create?: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput> | ContainerPlantCreateWithoutVarietyInput[] | ContainerPlantUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutVarietyInput | ContainerPlantCreateOrConnectWithoutVarietyInput[]
    createMany?: ContainerPlantCreateManyVarietyInputEnvelope
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
  }

  export type PlannedPlantingUncheckedCreateNestedManyWithoutVarietyInput = {
    create?: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput> | PlannedPlantingCreateWithoutVarietyInput[] | PlannedPlantingUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutVarietyInput | PlannedPlantingCreateOrConnectWithoutVarietyInput[]
    createMany?: PlannedPlantingCreateManyVarietyInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type PlantCatalogUpdateOneRequiredWithoutVarietiesNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutVarietiesInput, PlantCatalogUncheckedCreateWithoutVarietiesInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutVarietiesInput
    upsert?: PlantCatalogUpsertWithoutVarietiesInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutVarietiesInput, PlantCatalogUpdateWithoutVarietiesInput>, PlantCatalogUncheckedUpdateWithoutVarietiesInput>
  }

  export type ContainerPlantUpdateManyWithoutVarietyNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput> | ContainerPlantCreateWithoutVarietyInput[] | ContainerPlantUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutVarietyInput | ContainerPlantCreateOrConnectWithoutVarietyInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutVarietyInput | ContainerPlantUpsertWithWhereUniqueWithoutVarietyInput[]
    createMany?: ContainerPlantCreateManyVarietyInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutVarietyInput | ContainerPlantUpdateWithWhereUniqueWithoutVarietyInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutVarietyInput | ContainerPlantUpdateManyWithWhereWithoutVarietyInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type PlannedPlantingUpdateManyWithoutVarietyNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput> | PlannedPlantingCreateWithoutVarietyInput[] | PlannedPlantingUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutVarietyInput | PlannedPlantingCreateOrConnectWithoutVarietyInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutVarietyInput | PlannedPlantingUpsertWithWhereUniqueWithoutVarietyInput[]
    createMany?: PlannedPlantingCreateManyVarietyInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutVarietyInput | PlannedPlantingUpdateWithWhereUniqueWithoutVarietyInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutVarietyInput | PlannedPlantingUpdateManyWithWhereWithoutVarietyInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type ContainerPlantUncheckedUpdateManyWithoutVarietyNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput> | ContainerPlantCreateWithoutVarietyInput[] | ContainerPlantUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutVarietyInput | ContainerPlantCreateOrConnectWithoutVarietyInput[]
    upsert?: ContainerPlantUpsertWithWhereUniqueWithoutVarietyInput | ContainerPlantUpsertWithWhereUniqueWithoutVarietyInput[]
    createMany?: ContainerPlantCreateManyVarietyInputEnvelope
    set?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    disconnect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    delete?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    connect?: ContainerPlantWhereUniqueInput | ContainerPlantWhereUniqueInput[]
    update?: ContainerPlantUpdateWithWhereUniqueWithoutVarietyInput | ContainerPlantUpdateWithWhereUniqueWithoutVarietyInput[]
    updateMany?: ContainerPlantUpdateManyWithWhereWithoutVarietyInput | ContainerPlantUpdateManyWithWhereWithoutVarietyInput[]
    deleteMany?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutVarietyNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput> | PlannedPlantingCreateWithoutVarietyInput[] | PlannedPlantingUncheckedCreateWithoutVarietyInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutVarietyInput | PlannedPlantingCreateOrConnectWithoutVarietyInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutVarietyInput | PlannedPlantingUpsertWithWhereUniqueWithoutVarietyInput[]
    createMany?: PlannedPlantingCreateManyVarietyInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutVarietyInput | PlannedPlantingUpdateWithWhereUniqueWithoutVarietyInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutVarietyInput | PlannedPlantingUpdateManyWithWhereWithoutVarietyInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type PlantCatalogCreateNestedOneWithoutCompanionsInput = {
    create?: XOR<PlantCatalogCreateWithoutCompanionsInput, PlantCatalogUncheckedCreateWithoutCompanionsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutCompanionsInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantCatalogCreateNestedOneWithoutCompanionToInput = {
    create?: XOR<PlantCatalogCreateWithoutCompanionToInput, PlantCatalogUncheckedCreateWithoutCompanionToInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutCompanionToInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantCatalogUpdateOneRequiredWithoutCompanionsNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutCompanionsInput, PlantCatalogUncheckedCreateWithoutCompanionsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutCompanionsInput
    upsert?: PlantCatalogUpsertWithoutCompanionsInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutCompanionsInput, PlantCatalogUpdateWithoutCompanionsInput>, PlantCatalogUncheckedUpdateWithoutCompanionsInput>
  }

  export type PlantCatalogUpdateOneRequiredWithoutCompanionToNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutCompanionToInput, PlantCatalogUncheckedCreateWithoutCompanionToInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutCompanionToInput
    upsert?: PlantCatalogUpsertWithoutCompanionToInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutCompanionToInput, PlantCatalogUpdateWithoutCompanionToInput>, PlantCatalogUncheckedUpdateWithoutCompanionToInput>
  }

  export type ContainerCreateNestedOneWithoutContainerPlantsInput = {
    create?: XOR<ContainerCreateWithoutContainerPlantsInput, ContainerUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerPlantsInput
    connect?: ContainerWhereUniqueInput
  }

  export type PlantCatalogCreateNestedOneWithoutContainerPlantsInput = {
    create?: XOR<PlantCatalogCreateWithoutContainerPlantsInput, PlantCatalogUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutContainerPlantsInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantVarietyCreateNestedOneWithoutContainerPlantsInput = {
    create?: XOR<PlantVarietyCreateWithoutContainerPlantsInput, PlantVarietyUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutContainerPlantsInput
    connect?: PlantVarietyWhereUniqueInput
  }

  export type PlantGrowthStageCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput> | PlantGrowthStageCreateWithoutContainerPlantInput[] | PlantGrowthStageUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantGrowthStageCreateOrConnectWithoutContainerPlantInput | PlantGrowthStageCreateOrConnectWithoutContainerPlantInput[]
    createMany?: PlantGrowthStageCreateManyContainerPlantInputEnvelope
    connect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
  }

  export type GardenActionCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput> | GardenActionCreateWithoutContainerPlantInput[] | GardenActionUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerPlantInput | GardenActionCreateOrConnectWithoutContainerPlantInput[]
    createMany?: GardenActionCreateManyContainerPlantInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type HarvestCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput> | HarvestCreateWithoutContainerPlantInput[] | HarvestUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: HarvestCreateOrConnectWithoutContainerPlantInput | HarvestCreateOrConnectWithoutContainerPlantInput[]
    createMany?: HarvestCreateManyContainerPlantInputEnvelope
    connect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
  }

  export type PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput> | PlantMovementHistoryCreateWithoutContainerPlantInput[] | PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput | PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput[]
    createMany?: PlantMovementHistoryCreateManyContainerPlantInputEnvelope
    connect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput> | TaskCreateWithoutContainerPlantInput[] | TaskUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerPlantInput | TaskCreateOrConnectWithoutContainerPlantInput[]
    createMany?: TaskCreateManyContainerPlantInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput> | PlantGrowthStageCreateWithoutContainerPlantInput[] | PlantGrowthStageUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantGrowthStageCreateOrConnectWithoutContainerPlantInput | PlantGrowthStageCreateOrConnectWithoutContainerPlantInput[]
    createMany?: PlantGrowthStageCreateManyContainerPlantInputEnvelope
    connect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
  }

  export type GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput> | GardenActionCreateWithoutContainerPlantInput[] | GardenActionUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerPlantInput | GardenActionCreateOrConnectWithoutContainerPlantInput[]
    createMany?: GardenActionCreateManyContainerPlantInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type HarvestUncheckedCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput> | HarvestCreateWithoutContainerPlantInput[] | HarvestUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: HarvestCreateOrConnectWithoutContainerPlantInput | HarvestCreateOrConnectWithoutContainerPlantInput[]
    createMany?: HarvestCreateManyContainerPlantInputEnvelope
    connect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
  }

  export type PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput> | PlantMovementHistoryCreateWithoutContainerPlantInput[] | PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput | PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput[]
    createMany?: PlantMovementHistoryCreateManyContainerPlantInputEnvelope
    connect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutContainerPlantInput = {
    create?: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput> | TaskCreateWithoutContainerPlantInput[] | TaskUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerPlantInput | TaskCreateOrConnectWithoutContainerPlantInput[]
    createMany?: TaskCreateManyContainerPlantInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput = {
    create?: XOR<ContainerCreateWithoutContainerPlantsInput, ContainerUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerPlantsInput
    upsert?: ContainerUpsertWithoutContainerPlantsInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutContainerPlantsInput, ContainerUpdateWithoutContainerPlantsInput>, ContainerUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutContainerPlantsInput, PlantCatalogUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutContainerPlantsInput
    upsert?: PlantCatalogUpsertWithoutContainerPlantsInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutContainerPlantsInput, PlantCatalogUpdateWithoutContainerPlantsInput>, PlantCatalogUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type PlantVarietyUpdateOneWithoutContainerPlantsNestedInput = {
    create?: XOR<PlantVarietyCreateWithoutContainerPlantsInput, PlantVarietyUncheckedCreateWithoutContainerPlantsInput>
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutContainerPlantsInput
    upsert?: PlantVarietyUpsertWithoutContainerPlantsInput
    disconnect?: PlantVarietyWhereInput | boolean
    delete?: PlantVarietyWhereInput | boolean
    connect?: PlantVarietyWhereUniqueInput
    update?: XOR<XOR<PlantVarietyUpdateToOneWithWhereWithoutContainerPlantsInput, PlantVarietyUpdateWithoutContainerPlantsInput>, PlantVarietyUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput> | PlantGrowthStageCreateWithoutContainerPlantInput[] | PlantGrowthStageUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantGrowthStageCreateOrConnectWithoutContainerPlantInput | PlantGrowthStageCreateOrConnectWithoutContainerPlantInput[]
    upsert?: PlantGrowthStageUpsertWithWhereUniqueWithoutContainerPlantInput | PlantGrowthStageUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: PlantGrowthStageCreateManyContainerPlantInputEnvelope
    set?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    disconnect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    delete?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    connect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    update?: PlantGrowthStageUpdateWithWhereUniqueWithoutContainerPlantInput | PlantGrowthStageUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: PlantGrowthStageUpdateManyWithWhereWithoutContainerPlantInput | PlantGrowthStageUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: PlantGrowthStageScalarWhereInput | PlantGrowthStageScalarWhereInput[]
  }

  export type GardenActionUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput> | GardenActionCreateWithoutContainerPlantInput[] | GardenActionUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerPlantInput | GardenActionCreateOrConnectWithoutContainerPlantInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutContainerPlantInput | GardenActionUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: GardenActionCreateManyContainerPlantInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutContainerPlantInput | GardenActionUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutContainerPlantInput | GardenActionUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type HarvestUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput> | HarvestCreateWithoutContainerPlantInput[] | HarvestUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: HarvestCreateOrConnectWithoutContainerPlantInput | HarvestCreateOrConnectWithoutContainerPlantInput[]
    upsert?: HarvestUpsertWithWhereUniqueWithoutContainerPlantInput | HarvestUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: HarvestCreateManyContainerPlantInputEnvelope
    set?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    disconnect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    delete?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    connect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    update?: HarvestUpdateWithWhereUniqueWithoutContainerPlantInput | HarvestUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: HarvestUpdateManyWithWhereWithoutContainerPlantInput | HarvestUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: HarvestScalarWhereInput | HarvestScalarWhereInput[]
  }

  export type PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput> | PlantMovementHistoryCreateWithoutContainerPlantInput[] | PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput | PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput[]
    upsert?: PlantMovementHistoryUpsertWithWhereUniqueWithoutContainerPlantInput | PlantMovementHistoryUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: PlantMovementHistoryCreateManyContainerPlantInputEnvelope
    set?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    disconnect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    delete?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    connect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    update?: PlantMovementHistoryUpdateWithWhereUniqueWithoutContainerPlantInput | PlantMovementHistoryUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: PlantMovementHistoryUpdateManyWithWhereWithoutContainerPlantInput | PlantMovementHistoryUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: PlantMovementHistoryScalarWhereInput | PlantMovementHistoryScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput> | TaskCreateWithoutContainerPlantInput[] | TaskUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerPlantInput | TaskCreateOrConnectWithoutContainerPlantInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutContainerPlantInput | TaskUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: TaskCreateManyContainerPlantInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutContainerPlantInput | TaskUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutContainerPlantInput | TaskUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput> | PlantGrowthStageCreateWithoutContainerPlantInput[] | PlantGrowthStageUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantGrowthStageCreateOrConnectWithoutContainerPlantInput | PlantGrowthStageCreateOrConnectWithoutContainerPlantInput[]
    upsert?: PlantGrowthStageUpsertWithWhereUniqueWithoutContainerPlantInput | PlantGrowthStageUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: PlantGrowthStageCreateManyContainerPlantInputEnvelope
    set?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    disconnect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    delete?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    connect?: PlantGrowthStageWhereUniqueInput | PlantGrowthStageWhereUniqueInput[]
    update?: PlantGrowthStageUpdateWithWhereUniqueWithoutContainerPlantInput | PlantGrowthStageUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: PlantGrowthStageUpdateManyWithWhereWithoutContainerPlantInput | PlantGrowthStageUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: PlantGrowthStageScalarWhereInput | PlantGrowthStageScalarWhereInput[]
  }

  export type GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput> | GardenActionCreateWithoutContainerPlantInput[] | GardenActionUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutContainerPlantInput | GardenActionCreateOrConnectWithoutContainerPlantInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutContainerPlantInput | GardenActionUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: GardenActionCreateManyContainerPlantInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutContainerPlantInput | GardenActionUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutContainerPlantInput | GardenActionUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput> | HarvestCreateWithoutContainerPlantInput[] | HarvestUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: HarvestCreateOrConnectWithoutContainerPlantInput | HarvestCreateOrConnectWithoutContainerPlantInput[]
    upsert?: HarvestUpsertWithWhereUniqueWithoutContainerPlantInput | HarvestUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: HarvestCreateManyContainerPlantInputEnvelope
    set?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    disconnect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    delete?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    connect?: HarvestWhereUniqueInput | HarvestWhereUniqueInput[]
    update?: HarvestUpdateWithWhereUniqueWithoutContainerPlantInput | HarvestUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: HarvestUpdateManyWithWhereWithoutContainerPlantInput | HarvestUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: HarvestScalarWhereInput | HarvestScalarWhereInput[]
  }

  export type PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput> | PlantMovementHistoryCreateWithoutContainerPlantInput[] | PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput | PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput[]
    upsert?: PlantMovementHistoryUpsertWithWhereUniqueWithoutContainerPlantInput | PlantMovementHistoryUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: PlantMovementHistoryCreateManyContainerPlantInputEnvelope
    set?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    disconnect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    delete?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    connect?: PlantMovementHistoryWhereUniqueInput | PlantMovementHistoryWhereUniqueInput[]
    update?: PlantMovementHistoryUpdateWithWhereUniqueWithoutContainerPlantInput | PlantMovementHistoryUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: PlantMovementHistoryUpdateManyWithWhereWithoutContainerPlantInput | PlantMovementHistoryUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: PlantMovementHistoryScalarWhereInput | PlantMovementHistoryScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutContainerPlantNestedInput = {
    create?: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput> | TaskCreateWithoutContainerPlantInput[] | TaskUncheckedCreateWithoutContainerPlantInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutContainerPlantInput | TaskCreateOrConnectWithoutContainerPlantInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutContainerPlantInput | TaskUpsertWithWhereUniqueWithoutContainerPlantInput[]
    createMany?: TaskCreateManyContainerPlantInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutContainerPlantInput | TaskUpdateWithWhereUniqueWithoutContainerPlantInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutContainerPlantInput | TaskUpdateManyWithWhereWithoutContainerPlantInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ContainerPlantCreateNestedOneWithoutGrowthStagesInput = {
    create?: XOR<ContainerPlantCreateWithoutGrowthStagesInput, ContainerPlantUncheckedCreateWithoutGrowthStagesInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutGrowthStagesInput
    connect?: ContainerPlantWhereUniqueInput
  }

  export type ContainerPlantUpdateOneRequiredWithoutGrowthStagesNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutGrowthStagesInput, ContainerPlantUncheckedCreateWithoutGrowthStagesInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutGrowthStagesInput
    upsert?: ContainerPlantUpsertWithoutGrowthStagesInput
    connect?: ContainerPlantWhereUniqueInput
    update?: XOR<XOR<ContainerPlantUpdateToOneWithWhereWithoutGrowthStagesInput, ContainerPlantUpdateWithoutGrowthStagesInput>, ContainerPlantUncheckedUpdateWithoutGrowthStagesInput>
  }

  export type GardenActionCreateNestedManyWithoutActionTypeInput = {
    create?: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput> | GardenActionCreateWithoutActionTypeInput[] | GardenActionUncheckedCreateWithoutActionTypeInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutActionTypeInput | GardenActionCreateOrConnectWithoutActionTypeInput[]
    createMany?: GardenActionCreateManyActionTypeInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type GardenActionUncheckedCreateNestedManyWithoutActionTypeInput = {
    create?: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput> | GardenActionCreateWithoutActionTypeInput[] | GardenActionUncheckedCreateWithoutActionTypeInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutActionTypeInput | GardenActionCreateOrConnectWithoutActionTypeInput[]
    createMany?: GardenActionCreateManyActionTypeInputEnvelope
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
  }

  export type GardenActionUpdateManyWithoutActionTypeNestedInput = {
    create?: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput> | GardenActionCreateWithoutActionTypeInput[] | GardenActionUncheckedCreateWithoutActionTypeInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutActionTypeInput | GardenActionCreateOrConnectWithoutActionTypeInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutActionTypeInput | GardenActionUpsertWithWhereUniqueWithoutActionTypeInput[]
    createMany?: GardenActionCreateManyActionTypeInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutActionTypeInput | GardenActionUpdateWithWhereUniqueWithoutActionTypeInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutActionTypeInput | GardenActionUpdateManyWithWhereWithoutActionTypeInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type GardenActionUncheckedUpdateManyWithoutActionTypeNestedInput = {
    create?: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput> | GardenActionCreateWithoutActionTypeInput[] | GardenActionUncheckedCreateWithoutActionTypeInput[]
    connectOrCreate?: GardenActionCreateOrConnectWithoutActionTypeInput | GardenActionCreateOrConnectWithoutActionTypeInput[]
    upsert?: GardenActionUpsertWithWhereUniqueWithoutActionTypeInput | GardenActionUpsertWithWhereUniqueWithoutActionTypeInput[]
    createMany?: GardenActionCreateManyActionTypeInputEnvelope
    set?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    disconnect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    delete?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    connect?: GardenActionWhereUniqueInput | GardenActionWhereUniqueInput[]
    update?: GardenActionUpdateWithWhereUniqueWithoutActionTypeInput | GardenActionUpdateWithWhereUniqueWithoutActionTypeInput[]
    updateMany?: GardenActionUpdateManyWithWhereWithoutActionTypeInput | GardenActionUpdateManyWithWhereWithoutActionTypeInput[]
    deleteMany?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
  }

  export type ActionTypeCreateNestedOneWithoutActionsInput = {
    create?: XOR<ActionTypeCreateWithoutActionsInput, ActionTypeUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ActionTypeCreateOrConnectWithoutActionsInput
    connect?: ActionTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGardenActionsInput = {
    create?: XOR<UserCreateWithoutGardenActionsInput, UserUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardenActionsInput
    connect?: UserWhereUniqueInput
  }

  export type GardenCreateNestedOneWithoutGardenActionsInput = {
    create?: XOR<GardenCreateWithoutGardenActionsInput, GardenUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: GardenCreateOrConnectWithoutGardenActionsInput
    connect?: GardenWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutGardenActionsInput = {
    create?: XOR<ContainerCreateWithoutGardenActionsInput, ContainerUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenActionsInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerPlantCreateNestedOneWithoutGardenActionsInput = {
    create?: XOR<ContainerPlantCreateWithoutGardenActionsInput, ContainerPlantUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutGardenActionsInput
    connect?: ContainerPlantWhereUniqueInput
  }

  export type ActionTypeUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<ActionTypeCreateWithoutActionsInput, ActionTypeUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ActionTypeCreateOrConnectWithoutActionsInput
    upsert?: ActionTypeUpsertWithoutActionsInput
    connect?: ActionTypeWhereUniqueInput
    update?: XOR<XOR<ActionTypeUpdateToOneWithWhereWithoutActionsInput, ActionTypeUpdateWithoutActionsInput>, ActionTypeUncheckedUpdateWithoutActionsInput>
  }

  export type UserUpdateOneRequiredWithoutGardenActionsNestedInput = {
    create?: XOR<UserCreateWithoutGardenActionsInput, UserUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardenActionsInput
    upsert?: UserUpsertWithoutGardenActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGardenActionsInput, UserUpdateWithoutGardenActionsInput>, UserUncheckedUpdateWithoutGardenActionsInput>
  }

  export type GardenUpdateOneWithoutGardenActionsNestedInput = {
    create?: XOR<GardenCreateWithoutGardenActionsInput, GardenUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: GardenCreateOrConnectWithoutGardenActionsInput
    upsert?: GardenUpsertWithoutGardenActionsInput
    disconnect?: GardenWhereInput | boolean
    delete?: GardenWhereInput | boolean
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutGardenActionsInput, GardenUpdateWithoutGardenActionsInput>, GardenUncheckedUpdateWithoutGardenActionsInput>
  }

  export type ContainerUpdateOneWithoutGardenActionsNestedInput = {
    create?: XOR<ContainerCreateWithoutGardenActionsInput, ContainerUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutGardenActionsInput
    upsert?: ContainerUpsertWithoutGardenActionsInput
    disconnect?: ContainerWhereInput | boolean
    delete?: ContainerWhereInput | boolean
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutGardenActionsInput, ContainerUpdateWithoutGardenActionsInput>, ContainerUncheckedUpdateWithoutGardenActionsInput>
  }

  export type ContainerPlantUpdateOneWithoutGardenActionsNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutGardenActionsInput, ContainerPlantUncheckedCreateWithoutGardenActionsInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutGardenActionsInput
    upsert?: ContainerPlantUpsertWithoutGardenActionsInput
    disconnect?: ContainerPlantWhereInput | boolean
    delete?: ContainerPlantWhereInput | boolean
    connect?: ContainerPlantWhereUniqueInput
    update?: XOR<XOR<ContainerPlantUpdateToOneWithWhereWithoutGardenActionsInput, ContainerPlantUpdateWithoutGardenActionsInput>, ContainerPlantUncheckedUpdateWithoutGardenActionsInput>
  }

  export type ContainerPlantCreateNestedOneWithoutHarvestsInput = {
    create?: XOR<ContainerPlantCreateWithoutHarvestsInput, ContainerPlantUncheckedCreateWithoutHarvestsInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutHarvestsInput
    connect?: ContainerPlantWhereUniqueInput
  }

  export type ContainerPlantUpdateOneRequiredWithoutHarvestsNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutHarvestsInput, ContainerPlantUncheckedCreateWithoutHarvestsInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutHarvestsInput
    upsert?: ContainerPlantUpsertWithoutHarvestsInput
    connect?: ContainerPlantWhereUniqueInput
    update?: XOR<XOR<ContainerPlantUpdateToOneWithWhereWithoutHarvestsInput, ContainerPlantUpdateWithoutHarvestsInput>, ContainerPlantUncheckedUpdateWithoutHarvestsInput>
  }

  export type ContainerCreateNestedOneWithoutContainerHistoryInput = {
    create?: XOR<ContainerCreateWithoutContainerHistoryInput, ContainerUncheckedCreateWithoutContainerHistoryInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerHistoryInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutPreviousContainersInput = {
    create?: XOR<ContainerCreateWithoutPreviousContainersInput, ContainerUncheckedCreateWithoutPreviousContainersInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutPreviousContainersInput
    connect?: ContainerWhereUniqueInput
  }

  export type GardenCreateNestedOneWithoutPreviousContainersInput = {
    create?: XOR<GardenCreateWithoutPreviousContainersInput, GardenUncheckedCreateWithoutPreviousContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutPreviousContainersInput
    connect?: GardenWhereUniqueInput
  }

  export type GardenCreateNestedOneWithoutNewContainersInput = {
    create?: XOR<GardenCreateWithoutNewContainersInput, GardenUncheckedCreateWithoutNewContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutNewContainersInput
    connect?: GardenWhereUniqueInput
  }

  export type ContainerUpdateOneRequiredWithoutContainerHistoryNestedInput = {
    create?: XOR<ContainerCreateWithoutContainerHistoryInput, ContainerUncheckedCreateWithoutContainerHistoryInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutContainerHistoryInput
    upsert?: ContainerUpsertWithoutContainerHistoryInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutContainerHistoryInput, ContainerUpdateWithoutContainerHistoryInput>, ContainerUncheckedUpdateWithoutContainerHistoryInput>
  }

  export type ContainerUpdateOneWithoutPreviousContainersNestedInput = {
    create?: XOR<ContainerCreateWithoutPreviousContainersInput, ContainerUncheckedCreateWithoutPreviousContainersInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutPreviousContainersInput
    upsert?: ContainerUpsertWithoutPreviousContainersInput
    disconnect?: ContainerWhereInput | boolean
    delete?: ContainerWhereInput | boolean
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutPreviousContainersInput, ContainerUpdateWithoutPreviousContainersInput>, ContainerUncheckedUpdateWithoutPreviousContainersInput>
  }

  export type GardenUpdateOneWithoutPreviousContainersNestedInput = {
    create?: XOR<GardenCreateWithoutPreviousContainersInput, GardenUncheckedCreateWithoutPreviousContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutPreviousContainersInput
    upsert?: GardenUpsertWithoutPreviousContainersInput
    disconnect?: GardenWhereInput | boolean
    delete?: GardenWhereInput | boolean
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutPreviousContainersInput, GardenUpdateWithoutPreviousContainersInput>, GardenUncheckedUpdateWithoutPreviousContainersInput>
  }

  export type GardenUpdateOneWithoutNewContainersNestedInput = {
    create?: XOR<GardenCreateWithoutNewContainersInput, GardenUncheckedCreateWithoutNewContainersInput>
    connectOrCreate?: GardenCreateOrConnectWithoutNewContainersInput
    upsert?: GardenUpsertWithoutNewContainersInput
    disconnect?: GardenWhereInput | boolean
    delete?: GardenWhereInput | boolean
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutNewContainersInput, GardenUpdateWithoutNewContainersInput>, GardenUncheckedUpdateWithoutNewContainersInput>
  }

  export type ContainerPlantCreateNestedOneWithoutMovementHistoryInput = {
    create?: XOR<ContainerPlantCreateWithoutMovementHistoryInput, ContainerPlantUncheckedCreateWithoutMovementHistoryInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutMovementHistoryInput
    connect?: ContainerPlantWhereUniqueInput
  }

  export type ContainerPlantUpdateOneRequiredWithoutMovementHistoryNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutMovementHistoryInput, ContainerPlantUncheckedCreateWithoutMovementHistoryInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutMovementHistoryInput
    upsert?: ContainerPlantUpsertWithoutMovementHistoryInput
    connect?: ContainerPlantWhereUniqueInput
    update?: XOR<XOR<ContainerPlantUpdateToOneWithWhereWithoutMovementHistoryInput, ContainerPlantUpdateWithoutMovementHistoryInput>, ContainerPlantUncheckedUpdateWithoutMovementHistoryInput>
  }

  export type GardenCreateNestedOneWithoutSeasonalPlansInput = {
    create?: XOR<GardenCreateWithoutSeasonalPlansInput, GardenUncheckedCreateWithoutSeasonalPlansInput>
    connectOrCreate?: GardenCreateOrConnectWithoutSeasonalPlansInput
    connect?: GardenWhereUniqueInput
  }

  export type PlannedPlantingCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput> | PlannedPlantingCreateWithoutPlanInput[] | PlannedPlantingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlanInput | PlannedPlantingCreateOrConnectWithoutPlanInput[]
    createMany?: PlannedPlantingCreateManyPlanInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type PlannedPlantingUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput> | PlannedPlantingCreateWithoutPlanInput[] | PlannedPlantingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlanInput | PlannedPlantingCreateOrConnectWithoutPlanInput[]
    createMany?: PlannedPlantingCreateManyPlanInputEnvelope
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
  }

  export type GardenUpdateOneRequiredWithoutSeasonalPlansNestedInput = {
    create?: XOR<GardenCreateWithoutSeasonalPlansInput, GardenUncheckedCreateWithoutSeasonalPlansInput>
    connectOrCreate?: GardenCreateOrConnectWithoutSeasonalPlansInput
    upsert?: GardenUpsertWithoutSeasonalPlansInput
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutSeasonalPlansInput, GardenUpdateWithoutSeasonalPlansInput>, GardenUncheckedUpdateWithoutSeasonalPlansInput>
  }

  export type PlannedPlantingUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput> | PlannedPlantingCreateWithoutPlanInput[] | PlannedPlantingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlanInput | PlannedPlantingCreateOrConnectWithoutPlanInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutPlanInput | PlannedPlantingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlannedPlantingCreateManyPlanInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutPlanInput | PlannedPlantingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutPlanInput | PlannedPlantingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput> | PlannedPlantingCreateWithoutPlanInput[] | PlannedPlantingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlannedPlantingCreateOrConnectWithoutPlanInput | PlannedPlantingCreateOrConnectWithoutPlanInput[]
    upsert?: PlannedPlantingUpsertWithWhereUniqueWithoutPlanInput | PlannedPlantingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlannedPlantingCreateManyPlanInputEnvelope
    set?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    disconnect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    delete?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    connect?: PlannedPlantingWhereUniqueInput | PlannedPlantingWhereUniqueInput[]
    update?: PlannedPlantingUpdateWithWhereUniqueWithoutPlanInput | PlannedPlantingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlannedPlantingUpdateManyWithWhereWithoutPlanInput | PlannedPlantingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
  }

  export type SeasonalPlanCreateNestedOneWithoutPlantingsInput = {
    create?: XOR<SeasonalPlanCreateWithoutPlantingsInput, SeasonalPlanUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutPlantingsInput
    connect?: SeasonalPlanWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutPlannedPlantingsInput = {
    create?: XOR<ContainerCreateWithoutPlannedPlantingsInput, ContainerUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutPlannedPlantingsInput
    connect?: ContainerWhereUniqueInput
  }

  export type PlantCatalogCreateNestedOneWithoutPlannedPlantingsInput = {
    create?: XOR<PlantCatalogCreateWithoutPlannedPlantingsInput, PlantCatalogUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutPlannedPlantingsInput
    connect?: PlantCatalogWhereUniqueInput
  }

  export type PlantVarietyCreateNestedOneWithoutPlannedPlantingsInput = {
    create?: XOR<PlantVarietyCreateWithoutPlannedPlantingsInput, PlantVarietyUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlannedPlantingsInput
    connect?: PlantVarietyWhereUniqueInput
  }

  export type SeasonalPlanUpdateOneRequiredWithoutPlantingsNestedInput = {
    create?: XOR<SeasonalPlanCreateWithoutPlantingsInput, SeasonalPlanUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: SeasonalPlanCreateOrConnectWithoutPlantingsInput
    upsert?: SeasonalPlanUpsertWithoutPlantingsInput
    connect?: SeasonalPlanWhereUniqueInput
    update?: XOR<XOR<SeasonalPlanUpdateToOneWithWhereWithoutPlantingsInput, SeasonalPlanUpdateWithoutPlantingsInput>, SeasonalPlanUncheckedUpdateWithoutPlantingsInput>
  }

  export type ContainerUpdateOneRequiredWithoutPlannedPlantingsNestedInput = {
    create?: XOR<ContainerCreateWithoutPlannedPlantingsInput, ContainerUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutPlannedPlantingsInput
    upsert?: ContainerUpsertWithoutPlannedPlantingsInput
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutPlannedPlantingsInput, ContainerUpdateWithoutPlannedPlantingsInput>, ContainerUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type PlantCatalogUpdateOneRequiredWithoutPlannedPlantingsNestedInput = {
    create?: XOR<PlantCatalogCreateWithoutPlannedPlantingsInput, PlantCatalogUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: PlantCatalogCreateOrConnectWithoutPlannedPlantingsInput
    upsert?: PlantCatalogUpsertWithoutPlannedPlantingsInput
    connect?: PlantCatalogWhereUniqueInput
    update?: XOR<XOR<PlantCatalogUpdateToOneWithWhereWithoutPlannedPlantingsInput, PlantCatalogUpdateWithoutPlannedPlantingsInput>, PlantCatalogUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type PlantVarietyUpdateOneWithoutPlannedPlantingsNestedInput = {
    create?: XOR<PlantVarietyCreateWithoutPlannedPlantingsInput, PlantVarietyUncheckedCreateWithoutPlannedPlantingsInput>
    connectOrCreate?: PlantVarietyCreateOrConnectWithoutPlannedPlantingsInput
    upsert?: PlantVarietyUpsertWithoutPlannedPlantingsInput
    disconnect?: PlantVarietyWhereInput | boolean
    delete?: PlantVarietyWhereInput | boolean
    connect?: PlantVarietyWhereUniqueInput
    update?: XOR<XOR<PlantVarietyUpdateToOneWithWhereWithoutPlannedPlantingsInput, PlantVarietyUpdateWithoutPlannedPlantingsInput>, PlantVarietyUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type GardenCreateNestedOneWithoutTasksInput = {
    create?: XOR<GardenCreateWithoutTasksInput, GardenUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GardenCreateOrConnectWithoutTasksInput
    connect?: GardenWhereUniqueInput
  }

  export type ContainerCreateNestedOneWithoutTasksInput = {
    create?: XOR<ContainerCreateWithoutTasksInput, ContainerUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutTasksInput
    connect?: ContainerWhereUniqueInput
  }

  export type ContainerPlantCreateNestedOneWithoutTasksInput = {
    create?: XOR<ContainerPlantCreateWithoutTasksInput, ContainerPlantUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutTasksInput
    connect?: ContainerPlantWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskNoteCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskCompletionLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput> | TaskCompletionLogCreateWithoutTaskInput[] | TaskCompletionLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutTaskInput | TaskCompletionLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCompletionLogCreateManyTaskInputEnvelope
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
  }

  export type TaskNotificationCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput> | TaskNotificationCreateWithoutTaskInput[] | TaskNotificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutTaskInput | TaskNotificationCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNotificationCreateManyTaskInputEnvelope
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
  }

  export type TaskPrerequisiteCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput> | TaskPrerequisiteCreateWithoutTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutTaskInput | TaskPrerequisiteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskPrerequisiteCreateManyTaskInputEnvelope
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
  }

  export type TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput> | TaskPrerequisiteCreateWithoutPrerequisiteTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput | TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput[]
    createMany?: TaskPrerequisiteCreateManyPrerequisiteTaskInputEnvelope
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
  }

  export type RecurringTaskPatternCreateNestedOneWithoutTaskInput = {
    create?: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
    connectOrCreate?: RecurringTaskPatternCreateOrConnectWithoutTaskInput
    connect?: RecurringTaskPatternWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskNoteUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
  }

  export type TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput> | TaskCompletionLogCreateWithoutTaskInput[] | TaskCompletionLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutTaskInput | TaskCompletionLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCompletionLogCreateManyTaskInputEnvelope
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
  }

  export type TaskNotificationUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput> | TaskNotificationCreateWithoutTaskInput[] | TaskNotificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutTaskInput | TaskNotificationCreateOrConnectWithoutTaskInput[]
    createMany?: TaskNotificationCreateManyTaskInputEnvelope
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
  }

  export type TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput> | TaskPrerequisiteCreateWithoutTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutTaskInput | TaskPrerequisiteCreateOrConnectWithoutTaskInput[]
    createMany?: TaskPrerequisiteCreateManyTaskInputEnvelope
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
  }

  export type TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput> | TaskPrerequisiteCreateWithoutPrerequisiteTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput | TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput[]
    createMany?: TaskPrerequisiteCreateManyPrerequisiteTaskInputEnvelope
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
  }

  export type RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
    connectOrCreate?: RecurringTaskPatternCreateOrConnectWithoutTaskInput
    connect?: RecurringTaskPatternWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type GardenUpdateOneWithoutTasksNestedInput = {
    create?: XOR<GardenCreateWithoutTasksInput, GardenUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GardenCreateOrConnectWithoutTasksInput
    upsert?: GardenUpsertWithoutTasksInput
    disconnect?: GardenWhereInput | boolean
    delete?: GardenWhereInput | boolean
    connect?: GardenWhereUniqueInput
    update?: XOR<XOR<GardenUpdateToOneWithWhereWithoutTasksInput, GardenUpdateWithoutTasksInput>, GardenUncheckedUpdateWithoutTasksInput>
  }

  export type ContainerUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ContainerCreateWithoutTasksInput, ContainerUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ContainerCreateOrConnectWithoutTasksInput
    upsert?: ContainerUpsertWithoutTasksInput
    disconnect?: ContainerWhereInput | boolean
    delete?: ContainerWhereInput | boolean
    connect?: ContainerWhereUniqueInput
    update?: XOR<XOR<ContainerUpdateToOneWithWhereWithoutTasksInput, ContainerUpdateWithoutTasksInput>, ContainerUncheckedUpdateWithoutTasksInput>
  }

  export type ContainerPlantUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ContainerPlantCreateWithoutTasksInput, ContainerPlantUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ContainerPlantCreateOrConnectWithoutTasksInput
    upsert?: ContainerPlantUpsertWithoutTasksInput
    disconnect?: ContainerPlantWhereInput | boolean
    delete?: ContainerPlantWhereInput | boolean
    connect?: ContainerPlantWhereUniqueInput
    update?: XOR<XOR<ContainerPlantUpdateToOneWithWhereWithoutTasksInput, ContainerPlantUpdateWithoutTasksInput>, ContainerPlantUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    upsert?: TaskUpsertWithoutSubtasksInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TaskUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParentTaskInput | TaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParentTaskInput | TaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParentTaskInput | TaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskNoteUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutTaskInput | TaskNoteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutTaskInput | TaskNoteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutTaskInput | TaskNoteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskCompletionLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput> | TaskCompletionLogCreateWithoutTaskInput[] | TaskCompletionLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutTaskInput | TaskCompletionLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCompletionLogUpsertWithWhereUniqueWithoutTaskInput | TaskCompletionLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCompletionLogCreateManyTaskInputEnvelope
    set?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    disconnect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    delete?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    update?: TaskCompletionLogUpdateWithWhereUniqueWithoutTaskInput | TaskCompletionLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCompletionLogUpdateManyWithWhereWithoutTaskInput | TaskCompletionLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
  }

  export type TaskNotificationUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput> | TaskNotificationCreateWithoutTaskInput[] | TaskNotificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutTaskInput | TaskNotificationCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNotificationUpsertWithWhereUniqueWithoutTaskInput | TaskNotificationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNotificationCreateManyTaskInputEnvelope
    set?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    disconnect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    delete?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    update?: TaskNotificationUpdateWithWhereUniqueWithoutTaskInput | TaskNotificationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNotificationUpdateManyWithWhereWithoutTaskInput | TaskNotificationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
  }

  export type TaskPrerequisiteUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput> | TaskPrerequisiteCreateWithoutTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutTaskInput | TaskPrerequisiteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskPrerequisiteUpsertWithWhereUniqueWithoutTaskInput | TaskPrerequisiteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskPrerequisiteCreateManyTaskInputEnvelope
    set?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    disconnect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    delete?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    update?: TaskPrerequisiteUpdateWithWhereUniqueWithoutTaskInput | TaskPrerequisiteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskPrerequisiteUpdateManyWithWhereWithoutTaskInput | TaskPrerequisiteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
  }

  export type TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput> | TaskPrerequisiteCreateWithoutPrerequisiteTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput | TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput[]
    upsert?: TaskPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteTaskInput | TaskPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteTaskInput[]
    createMany?: TaskPrerequisiteCreateManyPrerequisiteTaskInputEnvelope
    set?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    disconnect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    delete?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    update?: TaskPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteTaskInput | TaskPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteTaskInput[]
    updateMany?: TaskPrerequisiteUpdateManyWithWhereWithoutPrerequisiteTaskInput | TaskPrerequisiteUpdateManyWithWhereWithoutPrerequisiteTaskInput[]
    deleteMany?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
  }

  export type RecurringTaskPatternUpdateOneWithoutTaskNestedInput = {
    create?: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
    connectOrCreate?: RecurringTaskPatternCreateOrConnectWithoutTaskInput
    upsert?: RecurringTaskPatternUpsertWithoutTaskInput
    disconnect?: RecurringTaskPatternWhereInput | boolean
    delete?: RecurringTaskPatternWhereInput | boolean
    connect?: RecurringTaskPatternWhereUniqueInput
    update?: XOR<XOR<RecurringTaskPatternUpdateToOneWithWhereWithoutTaskInput, RecurringTaskPatternUpdateWithoutTaskInput>, RecurringTaskPatternUncheckedUpdateWithoutTaskInput>
  }

  export type TaskUncheckedUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput> | TaskCreateWithoutParentTaskInput[] | TaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParentTaskInput | TaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParentTaskInput | TaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: TaskCreateManyParentTaskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParentTaskInput | TaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParentTaskInput | TaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskNoteUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput> | TaskNoteCreateWithoutTaskInput[] | TaskNoteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNoteCreateOrConnectWithoutTaskInput | TaskNoteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNoteUpsertWithWhereUniqueWithoutTaskInput | TaskNoteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNoteCreateManyTaskInputEnvelope
    set?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    disconnect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    delete?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    connect?: TaskNoteWhereUniqueInput | TaskNoteWhereUniqueInput[]
    update?: TaskNoteUpdateWithWhereUniqueWithoutTaskInput | TaskNoteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNoteUpdateManyWithWhereWithoutTaskInput | TaskNoteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
  }

  export type TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput> | TaskCompletionLogCreateWithoutTaskInput[] | TaskCompletionLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionLogCreateOrConnectWithoutTaskInput | TaskCompletionLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCompletionLogUpsertWithWhereUniqueWithoutTaskInput | TaskCompletionLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCompletionLogCreateManyTaskInputEnvelope
    set?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    disconnect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    delete?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    connect?: TaskCompletionLogWhereUniqueInput | TaskCompletionLogWhereUniqueInput[]
    update?: TaskCompletionLogUpdateWithWhereUniqueWithoutTaskInput | TaskCompletionLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCompletionLogUpdateManyWithWhereWithoutTaskInput | TaskCompletionLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
  }

  export type TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput> | TaskNotificationCreateWithoutTaskInput[] | TaskNotificationUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskNotificationCreateOrConnectWithoutTaskInput | TaskNotificationCreateOrConnectWithoutTaskInput[]
    upsert?: TaskNotificationUpsertWithWhereUniqueWithoutTaskInput | TaskNotificationUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskNotificationCreateManyTaskInputEnvelope
    set?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    disconnect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    delete?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    connect?: TaskNotificationWhereUniqueInput | TaskNotificationWhereUniqueInput[]
    update?: TaskNotificationUpdateWithWhereUniqueWithoutTaskInput | TaskNotificationUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskNotificationUpdateManyWithWhereWithoutTaskInput | TaskNotificationUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
  }

  export type TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput> | TaskPrerequisiteCreateWithoutTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutTaskInput | TaskPrerequisiteCreateOrConnectWithoutTaskInput[]
    upsert?: TaskPrerequisiteUpsertWithWhereUniqueWithoutTaskInput | TaskPrerequisiteUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskPrerequisiteCreateManyTaskInputEnvelope
    set?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    disconnect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    delete?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    update?: TaskPrerequisiteUpdateWithWhereUniqueWithoutTaskInput | TaskPrerequisiteUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskPrerequisiteUpdateManyWithWhereWithoutTaskInput | TaskPrerequisiteUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
  }

  export type TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput = {
    create?: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput> | TaskPrerequisiteCreateWithoutPrerequisiteTaskInput[] | TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput[]
    connectOrCreate?: TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput | TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput[]
    upsert?: TaskPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteTaskInput | TaskPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteTaskInput[]
    createMany?: TaskPrerequisiteCreateManyPrerequisiteTaskInputEnvelope
    set?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    disconnect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    delete?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    connect?: TaskPrerequisiteWhereUniqueInput | TaskPrerequisiteWhereUniqueInput[]
    update?: TaskPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteTaskInput | TaskPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteTaskInput[]
    updateMany?: TaskPrerequisiteUpdateManyWithWhereWithoutPrerequisiteTaskInput | TaskPrerequisiteUpdateManyWithWhereWithoutPrerequisiteTaskInput[]
    deleteMany?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
  }

  export type RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
    connectOrCreate?: RecurringTaskPatternCreateOrConnectWithoutTaskInput
    upsert?: RecurringTaskPatternUpsertWithoutTaskInput
    disconnect?: RecurringTaskPatternWhereInput | boolean
    delete?: RecurringTaskPatternWhereInput | boolean
    connect?: RecurringTaskPatternWhereUniqueInput
    update?: XOR<XOR<RecurringTaskPatternUpdateToOneWithWhereWithoutTaskInput, RecurringTaskPatternUpdateWithoutTaskInput>, RecurringTaskPatternUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<TaskCreateWithoutPrerequisitesInput, TaskUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPrerequisitesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutDependentsInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<TaskCreateWithoutPrerequisitesInput, TaskUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPrerequisitesInput
    upsert?: TaskUpsertWithoutPrerequisitesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutPrerequisitesInput, TaskUpdateWithoutPrerequisitesInput>, TaskUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type TaskUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    upsert?: TaskUpsertWithoutDependentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependentsInput, TaskUpdateWithoutDependentsInput>, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskCreateNestedOneWithoutTaskNotesInput = {
    create?: XOR<TaskCreateWithoutTaskNotesInput, TaskUncheckedCreateWithoutTaskNotesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskNotesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskNotesInput = {
    create?: XOR<UserCreateWithoutTaskNotesInput, UserUncheckedCreateWithoutTaskNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNotesInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskNotesNestedInput = {
    create?: XOR<TaskCreateWithoutTaskNotesInput, TaskUncheckedCreateWithoutTaskNotesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskNotesInput
    upsert?: TaskUpsertWithoutTaskNotesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskNotesInput, TaskUpdateWithoutTaskNotesInput>, TaskUncheckedUpdateWithoutTaskNotesInput>
  }

  export type UserUpdateOneRequiredWithoutTaskNotesNestedInput = {
    create?: XOR<UserCreateWithoutTaskNotesInput, UserUncheckedCreateWithoutTaskNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNotesInput
    upsert?: UserUpsertWithoutTaskNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskNotesInput, UserUpdateWithoutTaskNotesInput>, UserUncheckedUpdateWithoutTaskNotesInput>
  }

  export type TaskCreateNestedOneWithoutTaskCompletionLogInput = {
    create?: XOR<TaskCreateWithoutTaskCompletionLogInput, TaskUncheckedCreateWithoutTaskCompletionLogInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskCompletionLogInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskCompletionLogsInput = {
    create?: XOR<UserCreateWithoutTaskCompletionLogsInput, UserUncheckedCreateWithoutTaskCompletionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCompletionLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskCompletionLogNestedInput = {
    create?: XOR<TaskCreateWithoutTaskCompletionLogInput, TaskUncheckedCreateWithoutTaskCompletionLogInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskCompletionLogInput
    upsert?: TaskUpsertWithoutTaskCompletionLogInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskCompletionLogInput, TaskUpdateWithoutTaskCompletionLogInput>, TaskUncheckedUpdateWithoutTaskCompletionLogInput>
  }

  export type UserUpdateOneRequiredWithoutTaskCompletionLogsNestedInput = {
    create?: XOR<UserCreateWithoutTaskCompletionLogsInput, UserUncheckedCreateWithoutTaskCompletionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCompletionLogsInput
    upsert?: UserUpsertWithoutTaskCompletionLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskCompletionLogsInput, UserUpdateWithoutTaskCompletionLogsInput>, UserUncheckedUpdateWithoutTaskCompletionLogsInput>
  }

  export type TaskCreateNestedOneWithoutRecurringPatternInput = {
    create?: XOR<TaskCreateWithoutRecurringPatternInput, TaskUncheckedCreateWithoutRecurringPatternInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRecurringPatternInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutRecurringPatternNestedInput = {
    create?: XOR<TaskCreateWithoutRecurringPatternInput, TaskUncheckedCreateWithoutRecurringPatternInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRecurringPatternInput
    upsert?: TaskUpsertWithoutRecurringPatternInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutRecurringPatternInput, TaskUpdateWithoutRecurringPatternInput>, TaskUncheckedUpdateWithoutRecurringPatternInput>
  }

  export type TaskCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TaskCreateWithoutNotificationsInput, TaskUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutNotificationsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskNotificationsInput = {
    create?: XOR<UserCreateWithoutTaskNotificationsInput, UserUncheckedCreateWithoutTaskNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TaskCreateWithoutNotificationsInput, TaskUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutNotificationsInput
    upsert?: TaskUpsertWithoutNotificationsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutNotificationsInput, TaskUpdateWithoutNotificationsInput>, TaskUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutTaskNotificationsInput, UserUncheckedCreateWithoutTaskNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskNotificationsInput
    upsert?: UserUpsertWithoutTaskNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskNotificationsInput, UserUpdateWithoutTaskNotificationsInput>, UserUncheckedUpdateWithoutTaskNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GardenCreateWithoutUserInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutUserInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput>
  }

  export type GardenCreateManyUserInputEnvelope = {
    data: GardenCreateManyUserInput | GardenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GardenActionCreateWithoutUserInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    actionType: ActionTypeCreateNestedOneWithoutActionsInput
    garden?: GardenCreateNestedOneWithoutGardenActionsInput
    container?: ContainerCreateNestedOneWithoutGardenActionsInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateWithoutUserInput = {
    id?: number
    actionTypeId: number
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionCreateOrConnectWithoutUserInput = {
    where: GardenActionWhereUniqueInput
    create: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput>
  }

  export type GardenActionCreateManyUserInputEnvelope = {
    data: GardenActionCreateManyUserInput | GardenActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutUserInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskNoteCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutTaskNotesInput
  }

  export type TaskNoteUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskNoteCreateOrConnectWithoutUserInput = {
    where: TaskNoteWhereUniqueInput
    create: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput>
  }

  export type TaskNoteCreateManyUserInputEnvelope = {
    data: TaskNoteCreateManyUserInput | TaskNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCompletionLogCreateWithoutUserInput = {
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
    task: TaskCreateNestedOneWithoutTaskCompletionLogInput
  }

  export type TaskCompletionLogUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskCompletionLogCreateOrConnectWithoutUserInput = {
    where: TaskCompletionLogWhereUniqueInput
    create: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput>
  }

  export type TaskCompletionLogCreateManyUserInputEnvelope = {
    data: TaskCompletionLogCreateManyUserInput | TaskCompletionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskNotificationCreateWithoutUserInput = {
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutNotificationsInput
  }

  export type TaskNotificationUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskNotificationCreateOrConnectWithoutUserInput = {
    where: TaskNotificationWhereUniqueInput
    create: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput>
  }

  export type TaskNotificationCreateManyUserInputEnvelope = {
    data: TaskNotificationCreateManyUserInput | TaskNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type GardenUpsertWithWhereUniqueWithoutUserInput = {
    where: GardenWhereUniqueInput
    update: XOR<GardenUpdateWithoutUserInput, GardenUncheckedUpdateWithoutUserInput>
    create: XOR<GardenCreateWithoutUserInput, GardenUncheckedCreateWithoutUserInput>
  }

  export type GardenUpdateWithWhereUniqueWithoutUserInput = {
    where: GardenWhereUniqueInput
    data: XOR<GardenUpdateWithoutUserInput, GardenUncheckedUpdateWithoutUserInput>
  }

  export type GardenUpdateManyWithWhereWithoutUserInput = {
    where: GardenScalarWhereInput
    data: XOR<GardenUpdateManyMutationInput, GardenUncheckedUpdateManyWithoutUserInput>
  }

  export type GardenScalarWhereInput = {
    AND?: GardenScalarWhereInput | GardenScalarWhereInput[]
    OR?: GardenScalarWhereInput[]
    NOT?: GardenScalarWhereInput | GardenScalarWhereInput[]
    id?: IntFilter<"Garden"> | number
    userId?: StringFilter<"Garden"> | string
    name?: StringFilter<"Garden"> | string
    location?: StringNullableFilter<"Garden"> | string | null
    sizeSqFeet?: DecimalNullableFilter<"Garden"> | Decimal | DecimalJsLike | number | string | null
    gardenType?: StringNullableFilter<"Garden"> | string | null
    description?: StringNullableFilter<"Garden"> | string | null
    createdAt?: DateTimeFilter<"Garden"> | Date | string
    updatedAt?: DateTimeFilter<"Garden"> | Date | string
  }

  export type GardenActionUpsertWithWhereUniqueWithoutUserInput = {
    where: GardenActionWhereUniqueInput
    update: XOR<GardenActionUpdateWithoutUserInput, GardenActionUncheckedUpdateWithoutUserInput>
    create: XOR<GardenActionCreateWithoutUserInput, GardenActionUncheckedCreateWithoutUserInput>
  }

  export type GardenActionUpdateWithWhereUniqueWithoutUserInput = {
    where: GardenActionWhereUniqueInput
    data: XOR<GardenActionUpdateWithoutUserInput, GardenActionUncheckedUpdateWithoutUserInput>
  }

  export type GardenActionUpdateManyWithWhereWithoutUserInput = {
    where: GardenActionScalarWhereInput
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyWithoutUserInput>
  }

  export type GardenActionScalarWhereInput = {
    AND?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
    OR?: GardenActionScalarWhereInput[]
    NOT?: GardenActionScalarWhereInput | GardenActionScalarWhereInput[]
    id?: IntFilter<"GardenAction"> | number
    actionTypeId?: IntFilter<"GardenAction"> | number
    userId?: StringFilter<"GardenAction"> | string
    gardenId?: IntNullableFilter<"GardenAction"> | number | null
    containerId?: IntNullableFilter<"GardenAction"> | number | null
    containerPlantId?: IntNullableFilter<"GardenAction"> | number | null
    actionDate?: DateTimeFilter<"GardenAction"> | Date | string
    quantity?: DecimalNullableFilter<"GardenAction"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"GardenAction"> | string | null
    notes?: StringNullableFilter<"GardenAction"> | string | null
    successRating?: IntNullableFilter<"GardenAction"> | number | null
    createdAt?: DateTimeFilter<"GardenAction"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    difficulty?: StringFilter<"Task"> | string
    estimatedMinutes?: IntNullableFilter<"Task"> | number | null
    startDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    endDate?: DateTimeFilter<"Task"> | Date | string
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    userId?: StringFilter<"Task"> | string
    gardenId?: IntNullableFilter<"Task"> | number | null
    containerId?: IntNullableFilter<"Task"> | number | null
    containerPlantId?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    isRecurring?: BoolFilter<"Task"> | boolean
    parentTaskId?: IntNullableFilter<"Task"> | number | null
  }

  export type TaskNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskNoteWhereUniqueInput
    update: XOR<TaskNoteUpdateWithoutUserInput, TaskNoteUncheckedUpdateWithoutUserInput>
    create: XOR<TaskNoteCreateWithoutUserInput, TaskNoteUncheckedCreateWithoutUserInput>
  }

  export type TaskNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskNoteWhereUniqueInput
    data: XOR<TaskNoteUpdateWithoutUserInput, TaskNoteUncheckedUpdateWithoutUserInput>
  }

  export type TaskNoteUpdateManyWithWhereWithoutUserInput = {
    where: TaskNoteScalarWhereInput
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskNoteScalarWhereInput = {
    AND?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
    OR?: TaskNoteScalarWhereInput[]
    NOT?: TaskNoteScalarWhereInput | TaskNoteScalarWhereInput[]
    id?: IntFilter<"TaskNote"> | number
    taskId?: IntFilter<"TaskNote"> | number
    userId?: StringFilter<"TaskNote"> | string
    content?: StringFilter<"TaskNote"> | string
    createdAt?: DateTimeFilter<"TaskNote"> | Date | string
    updatedAt?: DateTimeFilter<"TaskNote"> | Date | string
  }

  export type TaskCompletionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskCompletionLogWhereUniqueInput
    update: XOR<TaskCompletionLogUpdateWithoutUserInput, TaskCompletionLogUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCompletionLogCreateWithoutUserInput, TaskCompletionLogUncheckedCreateWithoutUserInput>
  }

  export type TaskCompletionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskCompletionLogWhereUniqueInput
    data: XOR<TaskCompletionLogUpdateWithoutUserInput, TaskCompletionLogUncheckedUpdateWithoutUserInput>
  }

  export type TaskCompletionLogUpdateManyWithWhereWithoutUserInput = {
    where: TaskCompletionLogScalarWhereInput
    data: XOR<TaskCompletionLogUpdateManyMutationInput, TaskCompletionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskCompletionLogScalarWhereInput = {
    AND?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
    OR?: TaskCompletionLogScalarWhereInput[]
    NOT?: TaskCompletionLogScalarWhereInput | TaskCompletionLogScalarWhereInput[]
    id?: IntFilter<"TaskCompletionLog"> | number
    taskId?: IntFilter<"TaskCompletionLog"> | number
    userId?: StringFilter<"TaskCompletionLog"> | string
    status?: StringFilter<"TaskCompletionLog"> | string
    completedAt?: DateTimeFilter<"TaskCompletionLog"> | Date | string
    notes?: StringNullableFilter<"TaskCompletionLog"> | string | null
    percentDone?: IntNullableFilter<"TaskCompletionLog"> | number | null
    timeSpentMinutes?: IntNullableFilter<"TaskCompletionLog"> | number | null
  }

  export type TaskNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskNotificationWhereUniqueInput
    update: XOR<TaskNotificationUpdateWithoutUserInput, TaskNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<TaskNotificationCreateWithoutUserInput, TaskNotificationUncheckedCreateWithoutUserInput>
  }

  export type TaskNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskNotificationWhereUniqueInput
    data: XOR<TaskNotificationUpdateWithoutUserInput, TaskNotificationUncheckedUpdateWithoutUserInput>
  }

  export type TaskNotificationUpdateManyWithWhereWithoutUserInput = {
    where: TaskNotificationScalarWhereInput
    data: XOR<TaskNotificationUpdateManyMutationInput, TaskNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskNotificationScalarWhereInput = {
    AND?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
    OR?: TaskNotificationScalarWhereInput[]
    NOT?: TaskNotificationScalarWhereInput | TaskNotificationScalarWhereInput[]
    id?: IntFilter<"TaskNotification"> | number
    taskId?: IntFilter<"TaskNotification"> | number
    userId?: StringFilter<"TaskNotification"> | string
    message?: StringFilter<"TaskNotification"> | string
    isRead?: BoolFilter<"TaskNotification"> | boolean
    readAt?: DateTimeNullableFilter<"TaskNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskNotification"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGardensInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGardensInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGardensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGardensInput, UserUncheckedCreateWithoutGardensInput>
  }

  export type GardenConditionCreateWithoutGardenInput = {
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenConditionUncheckedCreateWithoutGardenInput = {
    id?: number
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenConditionCreateOrConnectWithoutGardenInput = {
    where: GardenConditionWhereUniqueInput
    create: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput>
  }

  export type GardenConditionCreateManyGardenInputEnvelope = {
    data: GardenConditionCreateManyGardenInput | GardenConditionCreateManyGardenInput[]
    skipDuplicates?: boolean
  }

  export type ContainerCreateWithoutGardenInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutGardenInput = {
    id?: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutGardenInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput>
  }

  export type ContainerCreateManyGardenInputEnvelope = {
    data: ContainerCreateManyGardenInput | ContainerCreateManyGardenInput[]
    skipDuplicates?: boolean
  }

  export type GardenActionCreateWithoutGardenInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    actionType: ActionTypeCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutGardenActionsInput
    container?: ContainerCreateNestedOneWithoutGardenActionsInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateWithoutGardenInput = {
    id?: number
    actionTypeId: number
    userId: string
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionCreateOrConnectWithoutGardenInput = {
    where: GardenActionWhereUniqueInput
    create: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput>
  }

  export type GardenActionCreateManyGardenInputEnvelope = {
    data: GardenActionCreateManyGardenInput | GardenActionCreateManyGardenInput[]
    skipDuplicates?: boolean
  }

  export type SeasonalPlanCreateWithoutGardenInput = {
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlannedPlantingCreateNestedManyWithoutPlanInput
  }

  export type SeasonalPlanUncheckedCreateWithoutGardenInput = {
    id?: number
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SeasonalPlanCreateOrConnectWithoutGardenInput = {
    where: SeasonalPlanWhereUniqueInput
    create: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput>
  }

  export type SeasonalPlanCreateManyGardenInputEnvelope = {
    data: SeasonalPlanCreateManyGardenInput | SeasonalPlanCreateManyGardenInput[]
    skipDuplicates?: boolean
  }

  export type ContainerHistoryCreateWithoutPreviousGardenInput = {
    moveDate: Date | string
    reason?: string | null
    container: ContainerCreateNestedOneWithoutContainerHistoryInput
    previousContainer?: ContainerCreateNestedOneWithoutPreviousContainersInput
    newGarden?: GardenCreateNestedOneWithoutNewContainersInput
  }

  export type ContainerHistoryUncheckedCreateWithoutPreviousGardenInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateOrConnectWithoutPreviousGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    create: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput>
  }

  export type ContainerHistoryCreateManyPreviousGardenInputEnvelope = {
    data: ContainerHistoryCreateManyPreviousGardenInput | ContainerHistoryCreateManyPreviousGardenInput[]
    skipDuplicates?: boolean
  }

  export type ContainerHistoryCreateWithoutNewGardenInput = {
    moveDate: Date | string
    reason?: string | null
    container: ContainerCreateNestedOneWithoutContainerHistoryInput
    previousContainer?: ContainerCreateNestedOneWithoutPreviousContainersInput
    previousGarden?: GardenCreateNestedOneWithoutPreviousContainersInput
  }

  export type ContainerHistoryUncheckedCreateWithoutNewGardenInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateOrConnectWithoutNewGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    create: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput>
  }

  export type ContainerHistoryCreateManyNewGardenInputEnvelope = {
    data: ContainerHistoryCreateManyNewGardenInput | ContainerHistoryCreateManyNewGardenInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutGardenInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutGardenInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutGardenInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput>
  }

  export type TaskCreateManyGardenInputEnvelope = {
    data: TaskCreateManyGardenInput | TaskCreateManyGardenInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGardensInput = {
    update: XOR<UserUpdateWithoutGardensInput, UserUncheckedUpdateWithoutGardensInput>
    create: XOR<UserCreateWithoutGardensInput, UserUncheckedCreateWithoutGardensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGardensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGardensInput, UserUncheckedUpdateWithoutGardensInput>
  }

  export type UserUpdateWithoutGardensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGardensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GardenConditionUpsertWithWhereUniqueWithoutGardenInput = {
    where: GardenConditionWhereUniqueInput
    update: XOR<GardenConditionUpdateWithoutGardenInput, GardenConditionUncheckedUpdateWithoutGardenInput>
    create: XOR<GardenConditionCreateWithoutGardenInput, GardenConditionUncheckedCreateWithoutGardenInput>
  }

  export type GardenConditionUpdateWithWhereUniqueWithoutGardenInput = {
    where: GardenConditionWhereUniqueInput
    data: XOR<GardenConditionUpdateWithoutGardenInput, GardenConditionUncheckedUpdateWithoutGardenInput>
  }

  export type GardenConditionUpdateManyWithWhereWithoutGardenInput = {
    where: GardenConditionScalarWhereInput
    data: XOR<GardenConditionUpdateManyMutationInput, GardenConditionUncheckedUpdateManyWithoutGardenInput>
  }

  export type GardenConditionScalarWhereInput = {
    AND?: GardenConditionScalarWhereInput | GardenConditionScalarWhereInput[]
    OR?: GardenConditionScalarWhereInput[]
    NOT?: GardenConditionScalarWhereInput | GardenConditionScalarWhereInput[]
    id?: IntFilter<"GardenCondition"> | number
    gardenId?: IntFilter<"GardenCondition"> | number
    climateZone?: StringNullableFilter<"GardenCondition"> | string | null
    sunlightExposure?: StringNullableFilter<"GardenCondition"> | string | null
    avgTemperatureF?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    humidityPct?: IntNullableFilter<"GardenCondition"> | number | null
    soilType?: StringNullableFilter<"GardenCondition"> | string | null
    annualRainfall?: DecimalNullableFilter<"GardenCondition"> | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: StringNullableFilter<"GardenCondition"> | string | null
    createdAt?: DateTimeFilter<"GardenCondition"> | Date | string
    updatedAt?: DateTimeFilter<"GardenCondition"> | Date | string
  }

  export type ContainerUpsertWithWhereUniqueWithoutGardenInput = {
    where: ContainerWhereUniqueInput
    update: XOR<ContainerUpdateWithoutGardenInput, ContainerUncheckedUpdateWithoutGardenInput>
    create: XOR<ContainerCreateWithoutGardenInput, ContainerUncheckedCreateWithoutGardenInput>
  }

  export type ContainerUpdateWithWhereUniqueWithoutGardenInput = {
    where: ContainerWhereUniqueInput
    data: XOR<ContainerUpdateWithoutGardenInput, ContainerUncheckedUpdateWithoutGardenInput>
  }

  export type ContainerUpdateManyWithWhereWithoutGardenInput = {
    where: ContainerScalarWhereInput
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyWithoutGardenInput>
  }

  export type ContainerScalarWhereInput = {
    AND?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
    OR?: ContainerScalarWhereInput[]
    NOT?: ContainerScalarWhereInput | ContainerScalarWhereInput[]
    id?: IntFilter<"Container"> | number
    gardenId?: IntFilter<"Container"> | number
    containerTypeId?: IntFilter<"Container"> | number
    name?: StringNullableFilter<"Container"> | string | null
    material?: StringNullableFilter<"Container"> | string | null
    widthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    lengthInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    heightInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    diameterInches?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionX?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"Container"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"Container"> | string | null
    drainageQuality?: StringNullableFilter<"Container"> | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    createdAt?: DateTimeFilter<"Container"> | Date | string
    updatedAt?: DateTimeFilter<"Container"> | Date | string
  }

  export type GardenActionUpsertWithWhereUniqueWithoutGardenInput = {
    where: GardenActionWhereUniqueInput
    update: XOR<GardenActionUpdateWithoutGardenInput, GardenActionUncheckedUpdateWithoutGardenInput>
    create: XOR<GardenActionCreateWithoutGardenInput, GardenActionUncheckedCreateWithoutGardenInput>
  }

  export type GardenActionUpdateWithWhereUniqueWithoutGardenInput = {
    where: GardenActionWhereUniqueInput
    data: XOR<GardenActionUpdateWithoutGardenInput, GardenActionUncheckedUpdateWithoutGardenInput>
  }

  export type GardenActionUpdateManyWithWhereWithoutGardenInput = {
    where: GardenActionScalarWhereInput
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyWithoutGardenInput>
  }

  export type SeasonalPlanUpsertWithWhereUniqueWithoutGardenInput = {
    where: SeasonalPlanWhereUniqueInput
    update: XOR<SeasonalPlanUpdateWithoutGardenInput, SeasonalPlanUncheckedUpdateWithoutGardenInput>
    create: XOR<SeasonalPlanCreateWithoutGardenInput, SeasonalPlanUncheckedCreateWithoutGardenInput>
  }

  export type SeasonalPlanUpdateWithWhereUniqueWithoutGardenInput = {
    where: SeasonalPlanWhereUniqueInput
    data: XOR<SeasonalPlanUpdateWithoutGardenInput, SeasonalPlanUncheckedUpdateWithoutGardenInput>
  }

  export type SeasonalPlanUpdateManyWithWhereWithoutGardenInput = {
    where: SeasonalPlanScalarWhereInput
    data: XOR<SeasonalPlanUpdateManyMutationInput, SeasonalPlanUncheckedUpdateManyWithoutGardenInput>
  }

  export type SeasonalPlanScalarWhereInput = {
    AND?: SeasonalPlanScalarWhereInput | SeasonalPlanScalarWhereInput[]
    OR?: SeasonalPlanScalarWhereInput[]
    NOT?: SeasonalPlanScalarWhereInput | SeasonalPlanScalarWhereInput[]
    id?: IntFilter<"SeasonalPlan"> | number
    gardenId?: IntFilter<"SeasonalPlan"> | number
    season?: StringFilter<"SeasonalPlan"> | string
    year?: IntFilter<"SeasonalPlan"> | number
    description?: StringNullableFilter<"SeasonalPlan"> | string | null
    createdAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SeasonalPlan"> | Date | string
  }

  export type ContainerHistoryUpsertWithWhereUniqueWithoutPreviousGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    update: XOR<ContainerHistoryUpdateWithoutPreviousGardenInput, ContainerHistoryUncheckedUpdateWithoutPreviousGardenInput>
    create: XOR<ContainerHistoryCreateWithoutPreviousGardenInput, ContainerHistoryUncheckedCreateWithoutPreviousGardenInput>
  }

  export type ContainerHistoryUpdateWithWhereUniqueWithoutPreviousGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    data: XOR<ContainerHistoryUpdateWithoutPreviousGardenInput, ContainerHistoryUncheckedUpdateWithoutPreviousGardenInput>
  }

  export type ContainerHistoryUpdateManyWithWhereWithoutPreviousGardenInput = {
    where: ContainerHistoryScalarWhereInput
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenInput>
  }

  export type ContainerHistoryScalarWhereInput = {
    AND?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
    OR?: ContainerHistoryScalarWhereInput[]
    NOT?: ContainerHistoryScalarWhereInput | ContainerHistoryScalarWhereInput[]
    id?: IntFilter<"ContainerHistory"> | number
    containerId?: IntFilter<"ContainerHistory"> | number
    previousContainerId?: IntNullableFilter<"ContainerHistory"> | number | null
    previousGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    newGardenId?: IntNullableFilter<"ContainerHistory"> | number | null
    moveDate?: DateTimeFilter<"ContainerHistory"> | Date | string
    reason?: StringNullableFilter<"ContainerHistory"> | string | null
  }

  export type ContainerHistoryUpsertWithWhereUniqueWithoutNewGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    update: XOR<ContainerHistoryUpdateWithoutNewGardenInput, ContainerHistoryUncheckedUpdateWithoutNewGardenInput>
    create: XOR<ContainerHistoryCreateWithoutNewGardenInput, ContainerHistoryUncheckedCreateWithoutNewGardenInput>
  }

  export type ContainerHistoryUpdateWithWhereUniqueWithoutNewGardenInput = {
    where: ContainerHistoryWhereUniqueInput
    data: XOR<ContainerHistoryUpdateWithoutNewGardenInput, ContainerHistoryUncheckedUpdateWithoutNewGardenInput>
  }

  export type ContainerHistoryUpdateManyWithWhereWithoutNewGardenInput = {
    where: ContainerHistoryScalarWhereInput
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyWithoutNewGardenInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutGardenInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutGardenInput, TaskUncheckedUpdateWithoutGardenInput>
    create: XOR<TaskCreateWithoutGardenInput, TaskUncheckedCreateWithoutGardenInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutGardenInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutGardenInput, TaskUncheckedUpdateWithoutGardenInput>
  }

  export type TaskUpdateManyWithWhereWithoutGardenInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutGardenInput>
  }

  export type GardenCreateWithoutConditionsInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutConditionsInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutConditionsInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutConditionsInput, GardenUncheckedCreateWithoutConditionsInput>
  }

  export type GardenUpsertWithoutConditionsInput = {
    update: XOR<GardenUpdateWithoutConditionsInput, GardenUncheckedUpdateWithoutConditionsInput>
    create: XOR<GardenCreateWithoutConditionsInput, GardenUncheckedCreateWithoutConditionsInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutConditionsInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutConditionsInput, GardenUncheckedUpdateWithoutConditionsInput>
  }

  export type GardenUpdateWithoutConditionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type ContainerCreateWithoutContainerTypeInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutContainerTypeInput = {
    id?: number
    gardenId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutContainerTypeInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput>
  }

  export type ContainerCreateManyContainerTypeInputEnvelope = {
    data: ContainerCreateManyContainerTypeInput | ContainerCreateManyContainerTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContainerUpsertWithWhereUniqueWithoutContainerTypeInput = {
    where: ContainerWhereUniqueInput
    update: XOR<ContainerUpdateWithoutContainerTypeInput, ContainerUncheckedUpdateWithoutContainerTypeInput>
    create: XOR<ContainerCreateWithoutContainerTypeInput, ContainerUncheckedCreateWithoutContainerTypeInput>
  }

  export type ContainerUpdateWithWhereUniqueWithoutContainerTypeInput = {
    where: ContainerWhereUniqueInput
    data: XOR<ContainerUpdateWithoutContainerTypeInput, ContainerUncheckedUpdateWithoutContainerTypeInput>
  }

  export type ContainerUpdateManyWithWhereWithoutContainerTypeInput = {
    where: ContainerScalarWhereInput
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyWithoutContainerTypeInput>
  }

  export type GardenCreateWithoutContainersInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutContainersInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutContainersInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutContainersInput, GardenUncheckedCreateWithoutContainersInput>
  }

  export type ContainerTypeCreateWithoutContainersInput = {
    name: string
    description?: string | null
    typicalDimensions?: string | null
  }

  export type ContainerTypeUncheckedCreateWithoutContainersInput = {
    id?: number
    name: string
    description?: string | null
    typicalDimensions?: string | null
  }

  export type ContainerTypeCreateOrConnectWithoutContainersInput = {
    where: ContainerTypeWhereUniqueInput
    create: XOR<ContainerTypeCreateWithoutContainersInput, ContainerTypeUncheckedCreateWithoutContainersInput>
  }

  export type ContainerPlantCreateWithoutContainerInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutContainerInput = {
    id?: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutContainerInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput>
  }

  export type ContainerPlantCreateManyContainerInputEnvelope = {
    data: ContainerPlantCreateManyContainerInput | ContainerPlantCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type GardenActionCreateWithoutContainerInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    actionType: ActionTypeCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutGardenActionsInput
    garden?: GardenCreateNestedOneWithoutGardenActionsInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateWithoutContainerInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionCreateOrConnectWithoutContainerInput = {
    where: GardenActionWhereUniqueInput
    create: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput>
  }

  export type GardenActionCreateManyContainerInputEnvelope = {
    data: GardenActionCreateManyContainerInput | GardenActionCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type ContainerHistoryCreateWithoutContainerInput = {
    moveDate: Date | string
    reason?: string | null
    previousContainer?: ContainerCreateNestedOneWithoutPreviousContainersInput
    previousGarden?: GardenCreateNestedOneWithoutPreviousContainersInput
    newGarden?: GardenCreateNestedOneWithoutNewContainersInput
  }

  export type ContainerHistoryUncheckedCreateWithoutContainerInput = {
    id?: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateOrConnectWithoutContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    create: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput>
  }

  export type ContainerHistoryCreateManyContainerInputEnvelope = {
    data: ContainerHistoryCreateManyContainerInput | ContainerHistoryCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type ContainerHistoryCreateWithoutPreviousContainerInput = {
    moveDate: Date | string
    reason?: string | null
    container: ContainerCreateNestedOneWithoutContainerHistoryInput
    previousGarden?: GardenCreateNestedOneWithoutPreviousContainersInput
    newGarden?: GardenCreateNestedOneWithoutNewContainersInput
  }

  export type ContainerHistoryUncheckedCreateWithoutPreviousContainerInput = {
    id?: number
    containerId: number
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateOrConnectWithoutPreviousContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    create: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput>
  }

  export type ContainerHistoryCreateManyPreviousContainerInputEnvelope = {
    data: ContainerHistoryCreateManyPreviousContainerInput | ContainerHistoryCreateManyPreviousContainerInput[]
    skipDuplicates?: boolean
  }

  export type PlannedPlantingCreateWithoutContainerInput = {
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
    plan: SeasonalPlanCreateNestedOneWithoutPlantingsInput
    plant: PlantCatalogCreateNestedOneWithoutPlannedPlantingsInput
    variety?: PlantVarietyCreateNestedOneWithoutPlannedPlantingsInput
  }

  export type PlannedPlantingUncheckedCreateWithoutContainerInput = {
    id?: number
    planId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingCreateOrConnectWithoutContainerInput = {
    where: PlannedPlantingWhereUniqueInput
    create: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput>
  }

  export type PlannedPlantingCreateManyContainerInputEnvelope = {
    data: PlannedPlantingCreateManyContainerInput | PlannedPlantingCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutContainerInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutContainerInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutContainerInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput>
  }

  export type TaskCreateManyContainerInputEnvelope = {
    data: TaskCreateManyContainerInput | TaskCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type GardenUpsertWithoutContainersInput = {
    update: XOR<GardenUpdateWithoutContainersInput, GardenUncheckedUpdateWithoutContainersInput>
    create: XOR<GardenCreateWithoutContainersInput, GardenUncheckedCreateWithoutContainersInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutContainersInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutContainersInput, GardenUncheckedUpdateWithoutContainersInput>
  }

  export type GardenUpdateWithoutContainersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutContainersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type ContainerTypeUpsertWithoutContainersInput = {
    update: XOR<ContainerTypeUpdateWithoutContainersInput, ContainerTypeUncheckedUpdateWithoutContainersInput>
    create: XOR<ContainerTypeCreateWithoutContainersInput, ContainerTypeUncheckedCreateWithoutContainersInput>
    where?: ContainerTypeWhereInput
  }

  export type ContainerTypeUpdateToOneWithWhereWithoutContainersInput = {
    where?: ContainerTypeWhereInput
    data: XOR<ContainerTypeUpdateWithoutContainersInput, ContainerTypeUncheckedUpdateWithoutContainersInput>
  }

  export type ContainerTypeUpdateWithoutContainersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerTypeUncheckedUpdateWithoutContainersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typicalDimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerPlantUpsertWithWhereUniqueWithoutContainerInput = {
    where: ContainerPlantWhereUniqueInput
    update: XOR<ContainerPlantUpdateWithoutContainerInput, ContainerPlantUncheckedUpdateWithoutContainerInput>
    create: XOR<ContainerPlantCreateWithoutContainerInput, ContainerPlantUncheckedCreateWithoutContainerInput>
  }

  export type ContainerPlantUpdateWithWhereUniqueWithoutContainerInput = {
    where: ContainerPlantWhereUniqueInput
    data: XOR<ContainerPlantUpdateWithoutContainerInput, ContainerPlantUncheckedUpdateWithoutContainerInput>
  }

  export type ContainerPlantUpdateManyWithWhereWithoutContainerInput = {
    where: ContainerPlantScalarWhereInput
    data: XOR<ContainerPlantUpdateManyMutationInput, ContainerPlantUncheckedUpdateManyWithoutContainerInput>
  }

  export type ContainerPlantScalarWhereInput = {
    AND?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
    OR?: ContainerPlantScalarWhereInput[]
    NOT?: ContainerPlantScalarWhereInput | ContainerPlantScalarWhereInput[]
    id?: IntFilter<"ContainerPlant"> | number
    containerId?: IntFilter<"ContainerPlant"> | number
    plantId?: IntFilter<"ContainerPlant"> | number
    varietyId?: IntNullableFilter<"ContainerPlant"> | number | null
    quantity?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFilter<"ContainerPlant"> | Date | string
    initialStage?: StringFilter<"ContainerPlant"> | string
    currentStage?: StringFilter<"ContainerPlant"> | string
    status?: StringFilter<"ContainerPlant"> | string
    positionX?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    positionY?: DecimalNullableFilter<"ContainerPlant"> | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: DateTimeNullableFilter<"ContainerPlant"> | Date | string | null
    notes?: StringNullableFilter<"ContainerPlant"> | string | null
    createdAt?: DateTimeFilter<"ContainerPlant"> | Date | string
    updatedAt?: DateTimeFilter<"ContainerPlant"> | Date | string
  }

  export type GardenActionUpsertWithWhereUniqueWithoutContainerInput = {
    where: GardenActionWhereUniqueInput
    update: XOR<GardenActionUpdateWithoutContainerInput, GardenActionUncheckedUpdateWithoutContainerInput>
    create: XOR<GardenActionCreateWithoutContainerInput, GardenActionUncheckedCreateWithoutContainerInput>
  }

  export type GardenActionUpdateWithWhereUniqueWithoutContainerInput = {
    where: GardenActionWhereUniqueInput
    data: XOR<GardenActionUpdateWithoutContainerInput, GardenActionUncheckedUpdateWithoutContainerInput>
  }

  export type GardenActionUpdateManyWithWhereWithoutContainerInput = {
    where: GardenActionScalarWhereInput
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyWithoutContainerInput>
  }

  export type ContainerHistoryUpsertWithWhereUniqueWithoutContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    update: XOR<ContainerHistoryUpdateWithoutContainerInput, ContainerHistoryUncheckedUpdateWithoutContainerInput>
    create: XOR<ContainerHistoryCreateWithoutContainerInput, ContainerHistoryUncheckedCreateWithoutContainerInput>
  }

  export type ContainerHistoryUpdateWithWhereUniqueWithoutContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    data: XOR<ContainerHistoryUpdateWithoutContainerInput, ContainerHistoryUncheckedUpdateWithoutContainerInput>
  }

  export type ContainerHistoryUpdateManyWithWhereWithoutContainerInput = {
    where: ContainerHistoryScalarWhereInput
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyWithoutContainerInput>
  }

  export type ContainerHistoryUpsertWithWhereUniqueWithoutPreviousContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    update: XOR<ContainerHistoryUpdateWithoutPreviousContainerInput, ContainerHistoryUncheckedUpdateWithoutPreviousContainerInput>
    create: XOR<ContainerHistoryCreateWithoutPreviousContainerInput, ContainerHistoryUncheckedCreateWithoutPreviousContainerInput>
  }

  export type ContainerHistoryUpdateWithWhereUniqueWithoutPreviousContainerInput = {
    where: ContainerHistoryWhereUniqueInput
    data: XOR<ContainerHistoryUpdateWithoutPreviousContainerInput, ContainerHistoryUncheckedUpdateWithoutPreviousContainerInput>
  }

  export type ContainerHistoryUpdateManyWithWhereWithoutPreviousContainerInput = {
    where: ContainerHistoryScalarWhereInput
    data: XOR<ContainerHistoryUpdateManyMutationInput, ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerInput>
  }

  export type PlannedPlantingUpsertWithWhereUniqueWithoutContainerInput = {
    where: PlannedPlantingWhereUniqueInput
    update: XOR<PlannedPlantingUpdateWithoutContainerInput, PlannedPlantingUncheckedUpdateWithoutContainerInput>
    create: XOR<PlannedPlantingCreateWithoutContainerInput, PlannedPlantingUncheckedCreateWithoutContainerInput>
  }

  export type PlannedPlantingUpdateWithWhereUniqueWithoutContainerInput = {
    where: PlannedPlantingWhereUniqueInput
    data: XOR<PlannedPlantingUpdateWithoutContainerInput, PlannedPlantingUncheckedUpdateWithoutContainerInput>
  }

  export type PlannedPlantingUpdateManyWithWhereWithoutContainerInput = {
    where: PlannedPlantingScalarWhereInput
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyWithoutContainerInput>
  }

  export type PlannedPlantingScalarWhereInput = {
    AND?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
    OR?: PlannedPlantingScalarWhereInput[]
    NOT?: PlannedPlantingScalarWhereInput | PlannedPlantingScalarWhereInput[]
    id?: IntFilter<"PlannedPlanting"> | number
    planId?: IntFilter<"PlannedPlanting"> | number
    containerId?: IntFilter<"PlannedPlanting"> | number
    plantId?: IntFilter<"PlannedPlanting"> | number
    varietyId?: IntNullableFilter<"PlannedPlanting"> | number | null
    plannedDate?: DateTimeNullableFilter<"PlannedPlanting"> | Date | string | null
    quantity?: DecimalNullableFilter<"PlannedPlanting"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PlannedPlanting"> | string | null
    status?: StringFilter<"PlannedPlanting"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutContainerInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutContainerInput, TaskUncheckedUpdateWithoutContainerInput>
    create: XOR<TaskCreateWithoutContainerInput, TaskUncheckedCreateWithoutContainerInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutContainerInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutContainerInput, TaskUncheckedUpdateWithoutContainerInput>
  }

  export type TaskUpdateManyWithWhereWithoutContainerInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutContainerInput>
  }

  export type PlantGrowingConditionCreateWithoutPlantInput = {
    minTemperatureF?: number | null
    maxTemperatureF?: number | null
    sunlightNeeds?: string | null
    waterNeeds?: string | null
    soilPhMin?: Decimal | DecimalJsLike | number | string | null
    soilPhMax?: Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: string | null
    fertilizerNeeds?: string | null
    spacingInches?: Decimal | DecimalJsLike | number | string | null
    containerSuitable?: boolean
    minContainerDepthInches?: Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionUncheckedCreateWithoutPlantInput = {
    id?: number
    minTemperatureF?: number | null
    maxTemperatureF?: number | null
    sunlightNeeds?: string | null
    waterNeeds?: string | null
    soilPhMin?: Decimal | DecimalJsLike | number | string | null
    soilPhMax?: Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: string | null
    fertilizerNeeds?: string | null
    spacingInches?: Decimal | DecimalJsLike | number | string | null
    containerSuitable?: boolean
    minContainerDepthInches?: Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionCreateOrConnectWithoutPlantInput = {
    where: PlantGrowingConditionWhereUniqueInput
    create: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
  }

  export type PlantClimateZoneCreateWithoutPlantInput = {
    climateZone: string
    notes?: string | null
  }

  export type PlantClimateZoneUncheckedCreateWithoutPlantInput = {
    id?: number
    climateZone: string
    notes?: string | null
  }

  export type PlantClimateZoneCreateOrConnectWithoutPlantInput = {
    where: PlantClimateZoneWhereUniqueInput
    create: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput>
  }

  export type PlantClimateZoneCreateManyPlantInputEnvelope = {
    data: PlantClimateZoneCreateManyPlantInput | PlantClimateZoneCreateManyPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlantVarietyCreateWithoutPlantInput = {
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    containerPlants?: ContainerPlantCreateNestedManyWithoutVarietyInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyUncheckedCreateWithoutPlantInput = {
    id?: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutVarietyInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyCreateOrConnectWithoutPlantInput = {
    where: PlantVarietyWhereUniqueInput
    create: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput>
  }

  export type PlantVarietyCreateManyPlantInputEnvelope = {
    data: PlantVarietyCreateManyPlantInput | PlantVarietyCreateManyPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlantCompanionCreateWithoutPlantInput = {
    relationshipType: string
    effectDescription?: string | null
    companionPlant: PlantCatalogCreateNestedOneWithoutCompanionToInput
  }

  export type PlantCompanionUncheckedCreateWithoutPlantInput = {
    id?: number
    companionPlantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type PlantCompanionCreateOrConnectWithoutPlantInput = {
    where: PlantCompanionWhereUniqueInput
    create: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput>
  }

  export type PlantCompanionCreateManyPlantInputEnvelope = {
    data: PlantCompanionCreateManyPlantInput | PlantCompanionCreateManyPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlantCompanionCreateWithoutCompanionPlantInput = {
    relationshipType: string
    effectDescription?: string | null
    plant: PlantCatalogCreateNestedOneWithoutCompanionsInput
  }

  export type PlantCompanionUncheckedCreateWithoutCompanionPlantInput = {
    id?: number
    plantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type PlantCompanionCreateOrConnectWithoutCompanionPlantInput = {
    where: PlantCompanionWhereUniqueInput
    create: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput>
  }

  export type PlantCompanionCreateManyCompanionPlantInputEnvelope = {
    data: PlantCompanionCreateManyCompanionPlantInput | PlantCompanionCreateManyCompanionPlantInput[]
    skipDuplicates?: boolean
  }

  export type ContainerPlantCreateWithoutPlantInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutPlantInput = {
    id?: number
    containerId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutPlantInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput>
  }

  export type ContainerPlantCreateManyPlantInputEnvelope = {
    data: ContainerPlantCreateManyPlantInput | ContainerPlantCreateManyPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlannedPlantingCreateWithoutPlantInput = {
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
    plan: SeasonalPlanCreateNestedOneWithoutPlantingsInput
    container: ContainerCreateNestedOneWithoutPlannedPlantingsInput
    variety?: PlantVarietyCreateNestedOneWithoutPlannedPlantingsInput
  }

  export type PlannedPlantingUncheckedCreateWithoutPlantInput = {
    id?: number
    planId: number
    containerId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingCreateOrConnectWithoutPlantInput = {
    where: PlannedPlantingWhereUniqueInput
    create: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput>
  }

  export type PlannedPlantingCreateManyPlantInputEnvelope = {
    data: PlannedPlantingCreateManyPlantInput | PlannedPlantingCreateManyPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlantGrowingConditionUpsertWithoutPlantInput = {
    update: XOR<PlantGrowingConditionUpdateWithoutPlantInput, PlantGrowingConditionUncheckedUpdateWithoutPlantInput>
    create: XOR<PlantGrowingConditionCreateWithoutPlantInput, PlantGrowingConditionUncheckedCreateWithoutPlantInput>
    where?: PlantGrowingConditionWhereInput
  }

  export type PlantGrowingConditionUpdateToOneWithWhereWithoutPlantInput = {
    where?: PlantGrowingConditionWhereInput
    data: XOR<PlantGrowingConditionUpdateWithoutPlantInput, PlantGrowingConditionUncheckedUpdateWithoutPlantInput>
  }

  export type PlantGrowingConditionUpdateWithoutPlantInput = {
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantGrowingConditionUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    minTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    maxTemperatureF?: NullableIntFieldUpdateOperationsInput | number | null
    sunlightNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    waterNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    soilPhMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilPhMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilTypePreference?: NullableStringFieldUpdateOperationsInput | string | null
    fertilizerNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    spacingInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    containerSuitable?: BoolFieldUpdateOperationsInput | boolean
    minContainerDepthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minContainerVolumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PlantClimateZoneUpsertWithWhereUniqueWithoutPlantInput = {
    where: PlantClimateZoneWhereUniqueInput
    update: XOR<PlantClimateZoneUpdateWithoutPlantInput, PlantClimateZoneUncheckedUpdateWithoutPlantInput>
    create: XOR<PlantClimateZoneCreateWithoutPlantInput, PlantClimateZoneUncheckedCreateWithoutPlantInput>
  }

  export type PlantClimateZoneUpdateWithWhereUniqueWithoutPlantInput = {
    where: PlantClimateZoneWhereUniqueInput
    data: XOR<PlantClimateZoneUpdateWithoutPlantInput, PlantClimateZoneUncheckedUpdateWithoutPlantInput>
  }

  export type PlantClimateZoneUpdateManyWithWhereWithoutPlantInput = {
    where: PlantClimateZoneScalarWhereInput
    data: XOR<PlantClimateZoneUpdateManyMutationInput, PlantClimateZoneUncheckedUpdateManyWithoutPlantInput>
  }

  export type PlantClimateZoneScalarWhereInput = {
    AND?: PlantClimateZoneScalarWhereInput | PlantClimateZoneScalarWhereInput[]
    OR?: PlantClimateZoneScalarWhereInput[]
    NOT?: PlantClimateZoneScalarWhereInput | PlantClimateZoneScalarWhereInput[]
    id?: IntFilter<"PlantClimateZone"> | number
    plantId?: IntFilter<"PlantClimateZone"> | number
    climateZone?: StringFilter<"PlantClimateZone"> | string
    notes?: StringNullableFilter<"PlantClimateZone"> | string | null
  }

  export type PlantVarietyUpsertWithWhereUniqueWithoutPlantInput = {
    where: PlantVarietyWhereUniqueInput
    update: XOR<PlantVarietyUpdateWithoutPlantInput, PlantVarietyUncheckedUpdateWithoutPlantInput>
    create: XOR<PlantVarietyCreateWithoutPlantInput, PlantVarietyUncheckedCreateWithoutPlantInput>
  }

  export type PlantVarietyUpdateWithWhereUniqueWithoutPlantInput = {
    where: PlantVarietyWhereUniqueInput
    data: XOR<PlantVarietyUpdateWithoutPlantInput, PlantVarietyUncheckedUpdateWithoutPlantInput>
  }

  export type PlantVarietyUpdateManyWithWhereWithoutPlantInput = {
    where: PlantVarietyScalarWhereInput
    data: XOR<PlantVarietyUpdateManyMutationInput, PlantVarietyUncheckedUpdateManyWithoutPlantInput>
  }

  export type PlantVarietyScalarWhereInput = {
    AND?: PlantVarietyScalarWhereInput | PlantVarietyScalarWhereInput[]
    OR?: PlantVarietyScalarWhereInput[]
    NOT?: PlantVarietyScalarWhereInput | PlantVarietyScalarWhereInput[]
    id?: IntFilter<"PlantVariety"> | number
    plantId?: IntFilter<"PlantVariety"> | number
    varietyName?: StringFilter<"PlantVariety"> | string
    description?: StringNullableFilter<"PlantVariety"> | string | null
    specificTraits?: StringNullableFilter<"PlantVariety"> | string | null
    specificCareNeeds?: StringNullableFilter<"PlantVariety"> | string | null
    imageUrl?: StringNullableFilter<"PlantVariety"> | string | null
  }

  export type PlantCompanionUpsertWithWhereUniqueWithoutPlantInput = {
    where: PlantCompanionWhereUniqueInput
    update: XOR<PlantCompanionUpdateWithoutPlantInput, PlantCompanionUncheckedUpdateWithoutPlantInput>
    create: XOR<PlantCompanionCreateWithoutPlantInput, PlantCompanionUncheckedCreateWithoutPlantInput>
  }

  export type PlantCompanionUpdateWithWhereUniqueWithoutPlantInput = {
    where: PlantCompanionWhereUniqueInput
    data: XOR<PlantCompanionUpdateWithoutPlantInput, PlantCompanionUncheckedUpdateWithoutPlantInput>
  }

  export type PlantCompanionUpdateManyWithWhereWithoutPlantInput = {
    where: PlantCompanionScalarWhereInput
    data: XOR<PlantCompanionUpdateManyMutationInput, PlantCompanionUncheckedUpdateManyWithoutPlantInput>
  }

  export type PlantCompanionScalarWhereInput = {
    AND?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
    OR?: PlantCompanionScalarWhereInput[]
    NOT?: PlantCompanionScalarWhereInput | PlantCompanionScalarWhereInput[]
    id?: IntFilter<"PlantCompanion"> | number
    plantId?: IntFilter<"PlantCompanion"> | number
    companionPlantId?: IntFilter<"PlantCompanion"> | number
    relationshipType?: StringFilter<"PlantCompanion"> | string
    effectDescription?: StringNullableFilter<"PlantCompanion"> | string | null
  }

  export type PlantCompanionUpsertWithWhereUniqueWithoutCompanionPlantInput = {
    where: PlantCompanionWhereUniqueInput
    update: XOR<PlantCompanionUpdateWithoutCompanionPlantInput, PlantCompanionUncheckedUpdateWithoutCompanionPlantInput>
    create: XOR<PlantCompanionCreateWithoutCompanionPlantInput, PlantCompanionUncheckedCreateWithoutCompanionPlantInput>
  }

  export type PlantCompanionUpdateWithWhereUniqueWithoutCompanionPlantInput = {
    where: PlantCompanionWhereUniqueInput
    data: XOR<PlantCompanionUpdateWithoutCompanionPlantInput, PlantCompanionUncheckedUpdateWithoutCompanionPlantInput>
  }

  export type PlantCompanionUpdateManyWithWhereWithoutCompanionPlantInput = {
    where: PlantCompanionScalarWhereInput
    data: XOR<PlantCompanionUpdateManyMutationInput, PlantCompanionUncheckedUpdateManyWithoutCompanionPlantInput>
  }

  export type ContainerPlantUpsertWithWhereUniqueWithoutPlantInput = {
    where: ContainerPlantWhereUniqueInput
    update: XOR<ContainerPlantUpdateWithoutPlantInput, ContainerPlantUncheckedUpdateWithoutPlantInput>
    create: XOR<ContainerPlantCreateWithoutPlantInput, ContainerPlantUncheckedCreateWithoutPlantInput>
  }

  export type ContainerPlantUpdateWithWhereUniqueWithoutPlantInput = {
    where: ContainerPlantWhereUniqueInput
    data: XOR<ContainerPlantUpdateWithoutPlantInput, ContainerPlantUncheckedUpdateWithoutPlantInput>
  }

  export type ContainerPlantUpdateManyWithWhereWithoutPlantInput = {
    where: ContainerPlantScalarWhereInput
    data: XOR<ContainerPlantUpdateManyMutationInput, ContainerPlantUncheckedUpdateManyWithoutPlantInput>
  }

  export type PlannedPlantingUpsertWithWhereUniqueWithoutPlantInput = {
    where: PlannedPlantingWhereUniqueInput
    update: XOR<PlannedPlantingUpdateWithoutPlantInput, PlannedPlantingUncheckedUpdateWithoutPlantInput>
    create: XOR<PlannedPlantingCreateWithoutPlantInput, PlannedPlantingUncheckedCreateWithoutPlantInput>
  }

  export type PlannedPlantingUpdateWithWhereUniqueWithoutPlantInput = {
    where: PlannedPlantingWhereUniqueInput
    data: XOR<PlannedPlantingUpdateWithoutPlantInput, PlannedPlantingUncheckedUpdateWithoutPlantInput>
  }

  export type PlannedPlantingUpdateManyWithWhereWithoutPlantInput = {
    where: PlannedPlantingScalarWhereInput
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyWithoutPlantInput>
  }

  export type PlantCatalogCreateWithoutGrowingConditionsInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutGrowingConditionsInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutGrowingConditionsInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutGrowingConditionsInput, PlantCatalogUncheckedCreateWithoutGrowingConditionsInput>
  }

  export type PlantCatalogUpsertWithoutGrowingConditionsInput = {
    update: XOR<PlantCatalogUpdateWithoutGrowingConditionsInput, PlantCatalogUncheckedUpdateWithoutGrowingConditionsInput>
    create: XOR<PlantCatalogCreateWithoutGrowingConditionsInput, PlantCatalogUncheckedCreateWithoutGrowingConditionsInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutGrowingConditionsInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutGrowingConditionsInput, PlantCatalogUncheckedUpdateWithoutGrowingConditionsInput>
  }

  export type PlantCatalogUpdateWithoutGrowingConditionsInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutGrowingConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogCreateWithoutClimateZonesInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutClimateZonesInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutClimateZonesInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutClimateZonesInput, PlantCatalogUncheckedCreateWithoutClimateZonesInput>
  }

  export type PlantCatalogUpsertWithoutClimateZonesInput = {
    update: XOR<PlantCatalogUpdateWithoutClimateZonesInput, PlantCatalogUncheckedUpdateWithoutClimateZonesInput>
    create: XOR<PlantCatalogCreateWithoutClimateZonesInput, PlantCatalogUncheckedCreateWithoutClimateZonesInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutClimateZonesInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutClimateZonesInput, PlantCatalogUncheckedUpdateWithoutClimateZonesInput>
  }

  export type PlantCatalogUpdateWithoutClimateZonesInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutClimateZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogCreateWithoutVarietiesInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutVarietiesInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutVarietiesInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutVarietiesInput, PlantCatalogUncheckedCreateWithoutVarietiesInput>
  }

  export type ContainerPlantCreateWithoutVarietyInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutVarietyInput = {
    id?: number
    containerId: number
    plantId: number
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutVarietyInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput>
  }

  export type ContainerPlantCreateManyVarietyInputEnvelope = {
    data: ContainerPlantCreateManyVarietyInput | ContainerPlantCreateManyVarietyInput[]
    skipDuplicates?: boolean
  }

  export type PlannedPlantingCreateWithoutVarietyInput = {
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
    plan: SeasonalPlanCreateNestedOneWithoutPlantingsInput
    container: ContainerCreateNestedOneWithoutPlannedPlantingsInput
    plant: PlantCatalogCreateNestedOneWithoutPlannedPlantingsInput
  }

  export type PlannedPlantingUncheckedCreateWithoutVarietyInput = {
    id?: number
    planId: number
    containerId: number
    plantId: number
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingCreateOrConnectWithoutVarietyInput = {
    where: PlannedPlantingWhereUniqueInput
    create: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput>
  }

  export type PlannedPlantingCreateManyVarietyInputEnvelope = {
    data: PlannedPlantingCreateManyVarietyInput | PlannedPlantingCreateManyVarietyInput[]
    skipDuplicates?: boolean
  }

  export type PlantCatalogUpsertWithoutVarietiesInput = {
    update: XOR<PlantCatalogUpdateWithoutVarietiesInput, PlantCatalogUncheckedUpdateWithoutVarietiesInput>
    create: XOR<PlantCatalogCreateWithoutVarietiesInput, PlantCatalogUncheckedCreateWithoutVarietiesInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutVarietiesInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutVarietiesInput, PlantCatalogUncheckedUpdateWithoutVarietiesInput>
  }

  export type PlantCatalogUpdateWithoutVarietiesInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutVarietiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type ContainerPlantUpsertWithWhereUniqueWithoutVarietyInput = {
    where: ContainerPlantWhereUniqueInput
    update: XOR<ContainerPlantUpdateWithoutVarietyInput, ContainerPlantUncheckedUpdateWithoutVarietyInput>
    create: XOR<ContainerPlantCreateWithoutVarietyInput, ContainerPlantUncheckedCreateWithoutVarietyInput>
  }

  export type ContainerPlantUpdateWithWhereUniqueWithoutVarietyInput = {
    where: ContainerPlantWhereUniqueInput
    data: XOR<ContainerPlantUpdateWithoutVarietyInput, ContainerPlantUncheckedUpdateWithoutVarietyInput>
  }

  export type ContainerPlantUpdateManyWithWhereWithoutVarietyInput = {
    where: ContainerPlantScalarWhereInput
    data: XOR<ContainerPlantUpdateManyMutationInput, ContainerPlantUncheckedUpdateManyWithoutVarietyInput>
  }

  export type PlannedPlantingUpsertWithWhereUniqueWithoutVarietyInput = {
    where: PlannedPlantingWhereUniqueInput
    update: XOR<PlannedPlantingUpdateWithoutVarietyInput, PlannedPlantingUncheckedUpdateWithoutVarietyInput>
    create: XOR<PlannedPlantingCreateWithoutVarietyInput, PlannedPlantingUncheckedCreateWithoutVarietyInput>
  }

  export type PlannedPlantingUpdateWithWhereUniqueWithoutVarietyInput = {
    where: PlannedPlantingWhereUniqueInput
    data: XOR<PlannedPlantingUpdateWithoutVarietyInput, PlannedPlantingUncheckedUpdateWithoutVarietyInput>
  }

  export type PlannedPlantingUpdateManyWithWhereWithoutVarietyInput = {
    where: PlannedPlantingScalarWhereInput
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyWithoutVarietyInput>
  }

  export type PlantCatalogCreateWithoutCompanionsInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutCompanionsInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutCompanionsInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutCompanionsInput, PlantCatalogUncheckedCreateWithoutCompanionsInput>
  }

  export type PlantCatalogCreateWithoutCompanionToInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutCompanionToInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutCompanionToInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutCompanionToInput, PlantCatalogUncheckedCreateWithoutCompanionToInput>
  }

  export type PlantCatalogUpsertWithoutCompanionsInput = {
    update: XOR<PlantCatalogUpdateWithoutCompanionsInput, PlantCatalogUncheckedUpdateWithoutCompanionsInput>
    create: XOR<PlantCatalogCreateWithoutCompanionsInput, PlantCatalogUncheckedCreateWithoutCompanionsInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutCompanionsInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutCompanionsInput, PlantCatalogUncheckedUpdateWithoutCompanionsInput>
  }

  export type PlantCatalogUpdateWithoutCompanionsInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutCompanionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUpsertWithoutCompanionToInput = {
    update: XOR<PlantCatalogUpdateWithoutCompanionToInput, PlantCatalogUncheckedUpdateWithoutCompanionToInput>
    create: XOR<PlantCatalogCreateWithoutCompanionToInput, PlantCatalogUncheckedCreateWithoutCompanionToInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutCompanionToInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutCompanionToInput, PlantCatalogUncheckedUpdateWithoutCompanionToInput>
  }

  export type PlantCatalogUpdateWithoutCompanionToInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutCompanionToInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type ContainerCreateWithoutContainerPlantsInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutContainerPlantsInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutContainerPlantsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutContainerPlantsInput, ContainerUncheckedCreateWithoutContainerPlantsInput>
  }

  export type PlantCatalogCreateWithoutContainerPlantsInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutContainerPlantsInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutContainerPlantsInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutContainerPlantsInput, PlantCatalogUncheckedCreateWithoutContainerPlantsInput>
  }

  export type PlantVarietyCreateWithoutContainerPlantsInput = {
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    plant: PlantCatalogCreateNestedOneWithoutVarietiesInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyUncheckedCreateWithoutContainerPlantsInput = {
    id?: number
    plantId: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyCreateOrConnectWithoutContainerPlantsInput = {
    where: PlantVarietyWhereUniqueInput
    create: XOR<PlantVarietyCreateWithoutContainerPlantsInput, PlantVarietyUncheckedCreateWithoutContainerPlantsInput>
  }

  export type PlantGrowthStageCreateWithoutContainerPlantInput = {
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type PlantGrowthStageUncheckedCreateWithoutContainerPlantInput = {
    id?: number
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type PlantGrowthStageCreateOrConnectWithoutContainerPlantInput = {
    where: PlantGrowthStageWhereUniqueInput
    create: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput>
  }

  export type PlantGrowthStageCreateManyContainerPlantInputEnvelope = {
    data: PlantGrowthStageCreateManyContainerPlantInput | PlantGrowthStageCreateManyContainerPlantInput[]
    skipDuplicates?: boolean
  }

  export type GardenActionCreateWithoutContainerPlantInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    actionType: ActionTypeCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutGardenActionsInput
    garden?: GardenCreateNestedOneWithoutGardenActionsInput
    container?: ContainerCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateWithoutContainerPlantInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionCreateOrConnectWithoutContainerPlantInput = {
    where: GardenActionWhereUniqueInput
    create: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput>
  }

  export type GardenActionCreateManyContainerPlantInputEnvelope = {
    data: GardenActionCreateManyContainerPlantInput | GardenActionCreateManyContainerPlantInput[]
    skipDuplicates?: boolean
  }

  export type HarvestCreateWithoutContainerPlantInput = {
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type HarvestUncheckedCreateWithoutContainerPlantInput = {
    id?: number
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type HarvestCreateOrConnectWithoutContainerPlantInput = {
    where: HarvestWhereUniqueInput
    create: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput>
  }

  export type HarvestCreateManyContainerPlantInputEnvelope = {
    data: HarvestCreateManyContainerPlantInput | HarvestCreateManyContainerPlantInput[]
    skipDuplicates?: boolean
  }

  export type PlantMovementHistoryCreateWithoutContainerPlantInput = {
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
  }

  export type PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput = {
    id?: number
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
  }

  export type PlantMovementHistoryCreateOrConnectWithoutContainerPlantInput = {
    where: PlantMovementHistoryWhereUniqueInput
    create: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput>
  }

  export type PlantMovementHistoryCreateManyContainerPlantInputEnvelope = {
    data: PlantMovementHistoryCreateManyContainerPlantInput | PlantMovementHistoryCreateManyContainerPlantInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutContainerPlantInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutContainerPlantInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutContainerPlantInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput>
  }

  export type TaskCreateManyContainerPlantInputEnvelope = {
    data: TaskCreateManyContainerPlantInput | TaskCreateManyContainerPlantInput[]
    skipDuplicates?: boolean
  }

  export type ContainerUpsertWithoutContainerPlantsInput = {
    update: XOR<ContainerUpdateWithoutContainerPlantsInput, ContainerUncheckedUpdateWithoutContainerPlantsInput>
    create: XOR<ContainerCreateWithoutContainerPlantsInput, ContainerUncheckedCreateWithoutContainerPlantsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutContainerPlantsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutContainerPlantsInput, ContainerUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type ContainerUpdateWithoutContainerPlantsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutContainerPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type PlantCatalogUpsertWithoutContainerPlantsInput = {
    update: XOR<PlantCatalogUpdateWithoutContainerPlantsInput, PlantCatalogUncheckedUpdateWithoutContainerPlantsInput>
    create: XOR<PlantCatalogCreateWithoutContainerPlantsInput, PlantCatalogUncheckedCreateWithoutContainerPlantsInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutContainerPlantsInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutContainerPlantsInput, PlantCatalogUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type PlantCatalogUpdateWithoutContainerPlantsInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutContainerPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantVarietyUpsertWithoutContainerPlantsInput = {
    update: XOR<PlantVarietyUpdateWithoutContainerPlantsInput, PlantVarietyUncheckedUpdateWithoutContainerPlantsInput>
    create: XOR<PlantVarietyCreateWithoutContainerPlantsInput, PlantVarietyUncheckedCreateWithoutContainerPlantsInput>
    where?: PlantVarietyWhereInput
  }

  export type PlantVarietyUpdateToOneWithWhereWithoutContainerPlantsInput = {
    where?: PlantVarietyWhereInput
    data: XOR<PlantVarietyUpdateWithoutContainerPlantsInput, PlantVarietyUncheckedUpdateWithoutContainerPlantsInput>
  }

  export type PlantVarietyUpdateWithoutContainerPlantsInput = {
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutVarietiesNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyUncheckedUpdateWithoutContainerPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutVarietyNestedInput
  }

  export type PlantGrowthStageUpsertWithWhereUniqueWithoutContainerPlantInput = {
    where: PlantGrowthStageWhereUniqueInput
    update: XOR<PlantGrowthStageUpdateWithoutContainerPlantInput, PlantGrowthStageUncheckedUpdateWithoutContainerPlantInput>
    create: XOR<PlantGrowthStageCreateWithoutContainerPlantInput, PlantGrowthStageUncheckedCreateWithoutContainerPlantInput>
  }

  export type PlantGrowthStageUpdateWithWhereUniqueWithoutContainerPlantInput = {
    where: PlantGrowthStageWhereUniqueInput
    data: XOR<PlantGrowthStageUpdateWithoutContainerPlantInput, PlantGrowthStageUncheckedUpdateWithoutContainerPlantInput>
  }

  export type PlantGrowthStageUpdateManyWithWhereWithoutContainerPlantInput = {
    where: PlantGrowthStageScalarWhereInput
    data: XOR<PlantGrowthStageUpdateManyMutationInput, PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantInput>
  }

  export type PlantGrowthStageScalarWhereInput = {
    AND?: PlantGrowthStageScalarWhereInput | PlantGrowthStageScalarWhereInput[]
    OR?: PlantGrowthStageScalarWhereInput[]
    NOT?: PlantGrowthStageScalarWhereInput | PlantGrowthStageScalarWhereInput[]
    id?: IntFilter<"PlantGrowthStage"> | number
    containerPlantId?: IntFilter<"PlantGrowthStage"> | number
    stageName?: StringFilter<"PlantGrowthStage"> | string
    startDate?: DateTimeFilter<"PlantGrowthStage"> | Date | string
    endDate?: DateTimeNullableFilter<"PlantGrowthStage"> | Date | string | null
    notes?: StringNullableFilter<"PlantGrowthStage"> | string | null
    imageUrl?: StringNullableFilter<"PlantGrowthStage"> | string | null
  }

  export type GardenActionUpsertWithWhereUniqueWithoutContainerPlantInput = {
    where: GardenActionWhereUniqueInput
    update: XOR<GardenActionUpdateWithoutContainerPlantInput, GardenActionUncheckedUpdateWithoutContainerPlantInput>
    create: XOR<GardenActionCreateWithoutContainerPlantInput, GardenActionUncheckedCreateWithoutContainerPlantInput>
  }

  export type GardenActionUpdateWithWhereUniqueWithoutContainerPlantInput = {
    where: GardenActionWhereUniqueInput
    data: XOR<GardenActionUpdateWithoutContainerPlantInput, GardenActionUncheckedUpdateWithoutContainerPlantInput>
  }

  export type GardenActionUpdateManyWithWhereWithoutContainerPlantInput = {
    where: GardenActionScalarWhereInput
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyWithoutContainerPlantInput>
  }

  export type HarvestUpsertWithWhereUniqueWithoutContainerPlantInput = {
    where: HarvestWhereUniqueInput
    update: XOR<HarvestUpdateWithoutContainerPlantInput, HarvestUncheckedUpdateWithoutContainerPlantInput>
    create: XOR<HarvestCreateWithoutContainerPlantInput, HarvestUncheckedCreateWithoutContainerPlantInput>
  }

  export type HarvestUpdateWithWhereUniqueWithoutContainerPlantInput = {
    where: HarvestWhereUniqueInput
    data: XOR<HarvestUpdateWithoutContainerPlantInput, HarvestUncheckedUpdateWithoutContainerPlantInput>
  }

  export type HarvestUpdateManyWithWhereWithoutContainerPlantInput = {
    where: HarvestScalarWhereInput
    data: XOR<HarvestUpdateManyMutationInput, HarvestUncheckedUpdateManyWithoutContainerPlantInput>
  }

  export type HarvestScalarWhereInput = {
    AND?: HarvestScalarWhereInput | HarvestScalarWhereInput[]
    OR?: HarvestScalarWhereInput[]
    NOT?: HarvestScalarWhereInput | HarvestScalarWhereInput[]
    id?: IntFilter<"Harvest"> | number
    containerPlantId?: IntFilter<"Harvest"> | number
    harvestDate?: DateTimeFilter<"Harvest"> | Date | string
    quantity?: DecimalNullableFilter<"Harvest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"Harvest"> | string | null
    qualityRating?: IntNullableFilter<"Harvest"> | number | null
    notes?: StringNullableFilter<"Harvest"> | string | null
    imageUrl?: StringNullableFilter<"Harvest"> | string | null
  }

  export type PlantMovementHistoryUpsertWithWhereUniqueWithoutContainerPlantInput = {
    where: PlantMovementHistoryWhereUniqueInput
    update: XOR<PlantMovementHistoryUpdateWithoutContainerPlantInput, PlantMovementHistoryUncheckedUpdateWithoutContainerPlantInput>
    create: XOR<PlantMovementHistoryCreateWithoutContainerPlantInput, PlantMovementHistoryUncheckedCreateWithoutContainerPlantInput>
  }

  export type PlantMovementHistoryUpdateWithWhereUniqueWithoutContainerPlantInput = {
    where: PlantMovementHistoryWhereUniqueInput
    data: XOR<PlantMovementHistoryUpdateWithoutContainerPlantInput, PlantMovementHistoryUncheckedUpdateWithoutContainerPlantInput>
  }

  export type PlantMovementHistoryUpdateManyWithWhereWithoutContainerPlantInput = {
    where: PlantMovementHistoryScalarWhereInput
    data: XOR<PlantMovementHistoryUpdateManyMutationInput, PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantInput>
  }

  export type PlantMovementHistoryScalarWhereInput = {
    AND?: PlantMovementHistoryScalarWhereInput | PlantMovementHistoryScalarWhereInput[]
    OR?: PlantMovementHistoryScalarWhereInput[]
    NOT?: PlantMovementHistoryScalarWhereInput | PlantMovementHistoryScalarWhereInput[]
    id?: IntFilter<"PlantMovementHistory"> | number
    containerPlantId?: IntFilter<"PlantMovementHistory"> | number
    previousContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    newContainerId?: IntNullableFilter<"PlantMovementHistory"> | number | null
    moveDate?: DateTimeFilter<"PlantMovementHistory"> | Date | string
    reason?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionBefore?: StringNullableFilter<"PlantMovementHistory"> | string | null
    plantConditionAfter?: StringNullableFilter<"PlantMovementHistory"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutContainerPlantInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutContainerPlantInput, TaskUncheckedUpdateWithoutContainerPlantInput>
    create: XOR<TaskCreateWithoutContainerPlantInput, TaskUncheckedCreateWithoutContainerPlantInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutContainerPlantInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutContainerPlantInput, TaskUncheckedUpdateWithoutContainerPlantInput>
  }

  export type TaskUpdateManyWithWhereWithoutContainerPlantInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutContainerPlantInput>
  }

  export type ContainerPlantCreateWithoutGrowthStagesInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutGrowthStagesInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutGrowthStagesInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutGrowthStagesInput, ContainerPlantUncheckedCreateWithoutGrowthStagesInput>
  }

  export type ContainerPlantUpsertWithoutGrowthStagesInput = {
    update: XOR<ContainerPlantUpdateWithoutGrowthStagesInput, ContainerPlantUncheckedUpdateWithoutGrowthStagesInput>
    create: XOR<ContainerPlantCreateWithoutGrowthStagesInput, ContainerPlantUncheckedCreateWithoutGrowthStagesInput>
    where?: ContainerPlantWhereInput
  }

  export type ContainerPlantUpdateToOneWithWhereWithoutGrowthStagesInput = {
    where?: ContainerPlantWhereInput
    data: XOR<ContainerPlantUpdateWithoutGrowthStagesInput, ContainerPlantUncheckedUpdateWithoutGrowthStagesInput>
  }

  export type ContainerPlantUpdateWithoutGrowthStagesInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutGrowthStagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type GardenActionCreateWithoutActionTypeInput = {
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGardenActionsInput
    garden?: GardenCreateNestedOneWithoutGardenActionsInput
    container?: ContainerCreateNestedOneWithoutGardenActionsInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutGardenActionsInput
  }

  export type GardenActionUncheckedCreateWithoutActionTypeInput = {
    id?: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionCreateOrConnectWithoutActionTypeInput = {
    where: GardenActionWhereUniqueInput
    create: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput>
  }

  export type GardenActionCreateManyActionTypeInputEnvelope = {
    data: GardenActionCreateManyActionTypeInput | GardenActionCreateManyActionTypeInput[]
    skipDuplicates?: boolean
  }

  export type GardenActionUpsertWithWhereUniqueWithoutActionTypeInput = {
    where: GardenActionWhereUniqueInput
    update: XOR<GardenActionUpdateWithoutActionTypeInput, GardenActionUncheckedUpdateWithoutActionTypeInput>
    create: XOR<GardenActionCreateWithoutActionTypeInput, GardenActionUncheckedCreateWithoutActionTypeInput>
  }

  export type GardenActionUpdateWithWhereUniqueWithoutActionTypeInput = {
    where: GardenActionWhereUniqueInput
    data: XOR<GardenActionUpdateWithoutActionTypeInput, GardenActionUncheckedUpdateWithoutActionTypeInput>
  }

  export type GardenActionUpdateManyWithWhereWithoutActionTypeInput = {
    where: GardenActionScalarWhereInput
    data: XOR<GardenActionUpdateManyMutationInput, GardenActionUncheckedUpdateManyWithoutActionTypeInput>
  }

  export type ActionTypeCreateWithoutActionsInput = {
    name: string
    description?: string | null
    category?: string | null
  }

  export type ActionTypeUncheckedCreateWithoutActionsInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
  }

  export type ActionTypeCreateOrConnectWithoutActionsInput = {
    where: ActionTypeWhereUniqueInput
    create: XOR<ActionTypeCreateWithoutActionsInput, ActionTypeUncheckedCreateWithoutActionsInput>
  }

  export type UserCreateWithoutGardenActionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGardenActionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGardenActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGardenActionsInput, UserUncheckedCreateWithoutGardenActionsInput>
  }

  export type GardenCreateWithoutGardenActionsInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutGardenActionsInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutGardenActionsInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutGardenActionsInput, GardenUncheckedCreateWithoutGardenActionsInput>
  }

  export type ContainerCreateWithoutGardenActionsInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutGardenActionsInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutGardenActionsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutGardenActionsInput, ContainerUncheckedCreateWithoutGardenActionsInput>
  }

  export type ContainerPlantCreateWithoutGardenActionsInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutGardenActionsInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutGardenActionsInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutGardenActionsInput, ContainerPlantUncheckedCreateWithoutGardenActionsInput>
  }

  export type ActionTypeUpsertWithoutActionsInput = {
    update: XOR<ActionTypeUpdateWithoutActionsInput, ActionTypeUncheckedUpdateWithoutActionsInput>
    create: XOR<ActionTypeCreateWithoutActionsInput, ActionTypeUncheckedCreateWithoutActionsInput>
    where?: ActionTypeWhereInput
  }

  export type ActionTypeUpdateToOneWithWhereWithoutActionsInput = {
    where?: ActionTypeWhereInput
    data: XOR<ActionTypeUpdateWithoutActionsInput, ActionTypeUncheckedUpdateWithoutActionsInput>
  }

  export type ActionTypeUpdateWithoutActionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActionTypeUncheckedUpdateWithoutActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutGardenActionsInput = {
    update: XOR<UserUpdateWithoutGardenActionsInput, UserUncheckedUpdateWithoutGardenActionsInput>
    create: XOR<UserCreateWithoutGardenActionsInput, UserUncheckedCreateWithoutGardenActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGardenActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGardenActionsInput, UserUncheckedUpdateWithoutGardenActionsInput>
  }

  export type UserUpdateWithoutGardenActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGardenActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GardenUpsertWithoutGardenActionsInput = {
    update: XOR<GardenUpdateWithoutGardenActionsInput, GardenUncheckedUpdateWithoutGardenActionsInput>
    create: XOR<GardenCreateWithoutGardenActionsInput, GardenUncheckedCreateWithoutGardenActionsInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutGardenActionsInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutGardenActionsInput, GardenUncheckedUpdateWithoutGardenActionsInput>
  }

  export type GardenUpdateWithoutGardenActionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutGardenActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type ContainerUpsertWithoutGardenActionsInput = {
    update: XOR<ContainerUpdateWithoutGardenActionsInput, ContainerUncheckedUpdateWithoutGardenActionsInput>
    create: XOR<ContainerCreateWithoutGardenActionsInput, ContainerUncheckedCreateWithoutGardenActionsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutGardenActionsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutGardenActionsInput, ContainerUncheckedUpdateWithoutGardenActionsInput>
  }

  export type ContainerUpdateWithoutGardenActionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutGardenActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerPlantUpsertWithoutGardenActionsInput = {
    update: XOR<ContainerPlantUpdateWithoutGardenActionsInput, ContainerPlantUncheckedUpdateWithoutGardenActionsInput>
    create: XOR<ContainerPlantCreateWithoutGardenActionsInput, ContainerPlantUncheckedCreateWithoutGardenActionsInput>
    where?: ContainerPlantWhereInput
  }

  export type ContainerPlantUpdateToOneWithWhereWithoutGardenActionsInput = {
    where?: ContainerPlantWhereInput
    data: XOR<ContainerPlantUpdateWithoutGardenActionsInput, ContainerPlantUncheckedUpdateWithoutGardenActionsInput>
  }

  export type ContainerPlantUpdateWithoutGardenActionsInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutGardenActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantCreateWithoutHarvestsInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutHarvestsInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutHarvestsInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutHarvestsInput, ContainerPlantUncheckedCreateWithoutHarvestsInput>
  }

  export type ContainerPlantUpsertWithoutHarvestsInput = {
    update: XOR<ContainerPlantUpdateWithoutHarvestsInput, ContainerPlantUncheckedUpdateWithoutHarvestsInput>
    create: XOR<ContainerPlantCreateWithoutHarvestsInput, ContainerPlantUncheckedCreateWithoutHarvestsInput>
    where?: ContainerPlantWhereInput
  }

  export type ContainerPlantUpdateToOneWithWhereWithoutHarvestsInput = {
    where?: ContainerPlantWhereInput
    data: XOR<ContainerPlantUpdateWithoutHarvestsInput, ContainerPlantUncheckedUpdateWithoutHarvestsInput>
  }

  export type ContainerPlantUpdateWithoutHarvestsInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutHarvestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerCreateWithoutContainerHistoryInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutContainerHistoryInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutContainerHistoryInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutContainerHistoryInput, ContainerUncheckedCreateWithoutContainerHistoryInput>
  }

  export type ContainerCreateWithoutPreviousContainersInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutPreviousContainersInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutPreviousContainersInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutPreviousContainersInput, ContainerUncheckedCreateWithoutPreviousContainersInput>
  }

  export type GardenCreateWithoutPreviousContainersInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutPreviousContainersInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutPreviousContainersInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutPreviousContainersInput, GardenUncheckedCreateWithoutPreviousContainersInput>
  }

  export type GardenCreateWithoutNewContainersInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutNewContainersInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutNewContainersInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutNewContainersInput, GardenUncheckedCreateWithoutNewContainersInput>
  }

  export type ContainerUpsertWithoutContainerHistoryInput = {
    update: XOR<ContainerUpdateWithoutContainerHistoryInput, ContainerUncheckedUpdateWithoutContainerHistoryInput>
    create: XOR<ContainerCreateWithoutContainerHistoryInput, ContainerUncheckedCreateWithoutContainerHistoryInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutContainerHistoryInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutContainerHistoryInput, ContainerUncheckedUpdateWithoutContainerHistoryInput>
  }

  export type ContainerUpdateWithoutContainerHistoryInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutContainerHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUpsertWithoutPreviousContainersInput = {
    update: XOR<ContainerUpdateWithoutPreviousContainersInput, ContainerUncheckedUpdateWithoutPreviousContainersInput>
    create: XOR<ContainerCreateWithoutPreviousContainersInput, ContainerUncheckedCreateWithoutPreviousContainersInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutPreviousContainersInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutPreviousContainersInput, ContainerUncheckedUpdateWithoutPreviousContainersInput>
  }

  export type ContainerUpdateWithoutPreviousContainersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutPreviousContainersInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type GardenUpsertWithoutPreviousContainersInput = {
    update: XOR<GardenUpdateWithoutPreviousContainersInput, GardenUncheckedUpdateWithoutPreviousContainersInput>
    create: XOR<GardenCreateWithoutPreviousContainersInput, GardenUncheckedCreateWithoutPreviousContainersInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutPreviousContainersInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutPreviousContainersInput, GardenUncheckedUpdateWithoutPreviousContainersInput>
  }

  export type GardenUpdateWithoutPreviousContainersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutPreviousContainersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type GardenUpsertWithoutNewContainersInput = {
    update: XOR<GardenUpdateWithoutNewContainersInput, GardenUncheckedUpdateWithoutNewContainersInput>
    create: XOR<GardenCreateWithoutNewContainersInput, GardenUncheckedCreateWithoutNewContainersInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutNewContainersInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutNewContainersInput, GardenUncheckedUpdateWithoutNewContainersInput>
  }

  export type GardenUpdateWithoutNewContainersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutNewContainersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type ContainerPlantCreateWithoutMovementHistoryInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutMovementHistoryInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutMovementHistoryInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutMovementHistoryInput, ContainerPlantUncheckedCreateWithoutMovementHistoryInput>
  }

  export type ContainerPlantUpsertWithoutMovementHistoryInput = {
    update: XOR<ContainerPlantUpdateWithoutMovementHistoryInput, ContainerPlantUncheckedUpdateWithoutMovementHistoryInput>
    create: XOR<ContainerPlantCreateWithoutMovementHistoryInput, ContainerPlantUncheckedCreateWithoutMovementHistoryInput>
    where?: ContainerPlantWhereInput
  }

  export type ContainerPlantUpdateToOneWithWhereWithoutMovementHistoryInput = {
    where?: ContainerPlantWhereInput
    data: XOR<ContainerPlantUpdateWithoutMovementHistoryInput, ContainerPlantUncheckedUpdateWithoutMovementHistoryInput>
  }

  export type ContainerPlantUpdateWithoutMovementHistoryInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutMovementHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type GardenCreateWithoutSeasonalPlansInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
    tasks?: TaskCreateNestedManyWithoutGardenInput
  }

  export type GardenUncheckedCreateWithoutSeasonalPlansInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
    tasks?: TaskUncheckedCreateNestedManyWithoutGardenInput
  }

  export type GardenCreateOrConnectWithoutSeasonalPlansInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutSeasonalPlansInput, GardenUncheckedCreateWithoutSeasonalPlansInput>
  }

  export type PlannedPlantingCreateWithoutPlanInput = {
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
    container: ContainerCreateNestedOneWithoutPlannedPlantingsInput
    plant: PlantCatalogCreateNestedOneWithoutPlannedPlantingsInput
    variety?: PlantVarietyCreateNestedOneWithoutPlannedPlantingsInput
  }

  export type PlannedPlantingUncheckedCreateWithoutPlanInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingCreateOrConnectWithoutPlanInput = {
    where: PlannedPlantingWhereUniqueInput
    create: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput>
  }

  export type PlannedPlantingCreateManyPlanInputEnvelope = {
    data: PlannedPlantingCreateManyPlanInput | PlannedPlantingCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type GardenUpsertWithoutSeasonalPlansInput = {
    update: XOR<GardenUpdateWithoutSeasonalPlansInput, GardenUncheckedUpdateWithoutSeasonalPlansInput>
    create: XOR<GardenCreateWithoutSeasonalPlansInput, GardenUncheckedCreateWithoutSeasonalPlansInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutSeasonalPlansInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutSeasonalPlansInput, GardenUncheckedUpdateWithoutSeasonalPlansInput>
  }

  export type GardenUpdateWithoutSeasonalPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutSeasonalPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type PlannedPlantingUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlannedPlantingWhereUniqueInput
    update: XOR<PlannedPlantingUpdateWithoutPlanInput, PlannedPlantingUncheckedUpdateWithoutPlanInput>
    create: XOR<PlannedPlantingCreateWithoutPlanInput, PlannedPlantingUncheckedCreateWithoutPlanInput>
  }

  export type PlannedPlantingUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlannedPlantingWhereUniqueInput
    data: XOR<PlannedPlantingUpdateWithoutPlanInput, PlannedPlantingUncheckedUpdateWithoutPlanInput>
  }

  export type PlannedPlantingUpdateManyWithWhereWithoutPlanInput = {
    where: PlannedPlantingScalarWhereInput
    data: XOR<PlannedPlantingUpdateManyMutationInput, PlannedPlantingUncheckedUpdateManyWithoutPlanInput>
  }

  export type SeasonalPlanCreateWithoutPlantingsInput = {
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutSeasonalPlansInput
  }

  export type SeasonalPlanUncheckedCreateWithoutPlantingsInput = {
    id?: number
    gardenId: number
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonalPlanCreateOrConnectWithoutPlantingsInput = {
    where: SeasonalPlanWhereUniqueInput
    create: XOR<SeasonalPlanCreateWithoutPlantingsInput, SeasonalPlanUncheckedCreateWithoutPlantingsInput>
  }

  export type ContainerCreateWithoutPlannedPlantingsInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    tasks?: TaskCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutPlannedPlantingsInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutPlannedPlantingsInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutPlannedPlantingsInput, ContainerUncheckedCreateWithoutPlannedPlantingsInput>
  }

  export type PlantCatalogCreateWithoutPlannedPlantingsInput = {
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogUncheckedCreateWithoutPlannedPlantingsInput = {
    id?: number
    commonName: string
    scientificName?: string | null
    plantType?: string | null
    lifeCycle?: string | null
    growthHabit?: string | null
    edible?: boolean
    description?: string | null
    plantingInstructions?: string | null
    careInstructions?: string | null
    daysToGerminationMin?: number | null
    daysToGerminationMax?: number | null
    daysToMaturityMin?: number | null
    daysToMaturityMax?: number | null
    harvestSeason?: string | null
    heightInchesMin?: Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growingConditions?: PlantGrowingConditionUncheckedCreateNestedOneWithoutPlantInput
    climateZones?: PlantClimateZoneUncheckedCreateNestedManyWithoutPlantInput
    varieties?: PlantVarietyUncheckedCreateNestedManyWithoutPlantInput
    companions?: PlantCompanionUncheckedCreateNestedManyWithoutPlantInput
    companionTo?: PlantCompanionUncheckedCreateNestedManyWithoutCompanionPlantInput
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCatalogCreateOrConnectWithoutPlannedPlantingsInput = {
    where: PlantCatalogWhereUniqueInput
    create: XOR<PlantCatalogCreateWithoutPlannedPlantingsInput, PlantCatalogUncheckedCreateWithoutPlannedPlantingsInput>
  }

  export type PlantVarietyCreateWithoutPlannedPlantingsInput = {
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    plant: PlantCatalogCreateNestedOneWithoutVarietiesInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyUncheckedCreateWithoutPlannedPlantingsInput = {
    id?: number
    plantId: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutVarietyInput
  }

  export type PlantVarietyCreateOrConnectWithoutPlannedPlantingsInput = {
    where: PlantVarietyWhereUniqueInput
    create: XOR<PlantVarietyCreateWithoutPlannedPlantingsInput, PlantVarietyUncheckedCreateWithoutPlannedPlantingsInput>
  }

  export type SeasonalPlanUpsertWithoutPlantingsInput = {
    update: XOR<SeasonalPlanUpdateWithoutPlantingsInput, SeasonalPlanUncheckedUpdateWithoutPlantingsInput>
    create: XOR<SeasonalPlanCreateWithoutPlantingsInput, SeasonalPlanUncheckedCreateWithoutPlantingsInput>
    where?: SeasonalPlanWhereInput
  }

  export type SeasonalPlanUpdateToOneWithWhereWithoutPlantingsInput = {
    where?: SeasonalPlanWhereInput
    data: XOR<SeasonalPlanUpdateWithoutPlantingsInput, SeasonalPlanUncheckedUpdateWithoutPlantingsInput>
  }

  export type SeasonalPlanUpdateWithoutPlantingsInput = {
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutSeasonalPlansNestedInput
  }

  export type SeasonalPlanUncheckedUpdateWithoutPlantingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUpsertWithoutPlannedPlantingsInput = {
    update: XOR<ContainerUpdateWithoutPlannedPlantingsInput, ContainerUncheckedUpdateWithoutPlannedPlantingsInput>
    create: XOR<ContainerCreateWithoutPlannedPlantingsInput, ContainerUncheckedCreateWithoutPlannedPlantingsInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutPlannedPlantingsInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutPlannedPlantingsInput, ContainerUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type ContainerUpdateWithoutPlannedPlantingsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutPlannedPlantingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type PlantCatalogUpsertWithoutPlannedPlantingsInput = {
    update: XOR<PlantCatalogUpdateWithoutPlannedPlantingsInput, PlantCatalogUncheckedUpdateWithoutPlannedPlantingsInput>
    create: XOR<PlantCatalogCreateWithoutPlannedPlantingsInput, PlantCatalogUncheckedCreateWithoutPlannedPlantingsInput>
    where?: PlantCatalogWhereInput
  }

  export type PlantCatalogUpdateToOneWithWhereWithoutPlannedPlantingsInput = {
    where?: PlantCatalogWhereInput
    data: XOR<PlantCatalogUpdateWithoutPlannedPlantingsInput, PlantCatalogUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type PlantCatalogUpdateWithoutPlannedPlantingsInput = {
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutPlantNestedInput
  }

  export type PlantCatalogUncheckedUpdateWithoutPlannedPlantingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commonName?: StringFieldUpdateOperationsInput | string
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    plantType?: NullableStringFieldUpdateOperationsInput | string | null
    lifeCycle?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    edible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plantingInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    careInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    daysToGerminationMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToGerminationMax?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMin?: NullableIntFieldUpdateOperationsInput | number | null
    daysToMaturityMax?: NullableIntFieldUpdateOperationsInput | number | null
    harvestSeason?: NullableStringFieldUpdateOperationsInput | string | null
    heightInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    widthInchesMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growingConditions?: PlantGrowingConditionUncheckedUpdateOneWithoutPlantNestedInput
    climateZones?: PlantClimateZoneUncheckedUpdateManyWithoutPlantNestedInput
    varieties?: PlantVarietyUncheckedUpdateManyWithoutPlantNestedInput
    companions?: PlantCompanionUncheckedUpdateManyWithoutPlantNestedInput
    companionTo?: PlantCompanionUncheckedUpdateManyWithoutCompanionPlantNestedInput
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantVarietyUpsertWithoutPlannedPlantingsInput = {
    update: XOR<PlantVarietyUpdateWithoutPlannedPlantingsInput, PlantVarietyUncheckedUpdateWithoutPlannedPlantingsInput>
    create: XOR<PlantVarietyCreateWithoutPlannedPlantingsInput, PlantVarietyUncheckedCreateWithoutPlannedPlantingsInput>
    where?: PlantVarietyWhereInput
  }

  export type PlantVarietyUpdateToOneWithWhereWithoutPlannedPlantingsInput = {
    where?: PlantVarietyWhereInput
    data: XOR<PlantVarietyUpdateWithoutPlannedPlantingsInput, PlantVarietyUncheckedUpdateWithoutPlannedPlantingsInput>
  }

  export type PlantVarietyUpdateWithoutPlannedPlantingsInput = {
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutVarietiesNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyUncheckedUpdateWithoutPlannedPlantingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutVarietyNestedInput
  }

  export type UserCreateWithoutTasksInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type GardenCreateWithoutTasksInput = {
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGardensInput
    conditions?: GardenConditionCreateNestedManyWithoutGardenInput
    containers?: ContainerCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryCreateNestedManyWithoutNewGardenInput
  }

  export type GardenUncheckedCreateWithoutTasksInput = {
    id?: number
    userId: string
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: GardenConditionUncheckedCreateNestedManyWithoutGardenInput
    containers?: ContainerUncheckedCreateNestedManyWithoutGardenInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutGardenInput
    seasonalPlans?: SeasonalPlanUncheckedCreateNestedManyWithoutGardenInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousGardenInput
    newContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutNewGardenInput
  }

  export type GardenCreateOrConnectWithoutTasksInput = {
    where: GardenWhereUniqueInput
    create: XOR<GardenCreateWithoutTasksInput, GardenUncheckedCreateWithoutTasksInput>
  }

  export type ContainerCreateWithoutTasksInput = {
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    garden: GardenCreateNestedOneWithoutContainersInput
    containerType: ContainerTypeCreateNestedOneWithoutContainersInput
    containerPlants?: ContainerPlantCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingCreateNestedManyWithoutContainerInput
  }

  export type ContainerUncheckedCreateWithoutTasksInput = {
    id?: number
    gardenId: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    containerPlants?: ContainerPlantUncheckedCreateNestedManyWithoutContainerInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerInput
    containerHistory?: ContainerHistoryUncheckedCreateNestedManyWithoutContainerInput
    previousContainers?: ContainerHistoryUncheckedCreateNestedManyWithoutPreviousContainerInput
    plannedPlantings?: PlannedPlantingUncheckedCreateNestedManyWithoutContainerInput
  }

  export type ContainerCreateOrConnectWithoutTasksInput = {
    where: ContainerWhereUniqueInput
    create: XOR<ContainerCreateWithoutTasksInput, ContainerUncheckedCreateWithoutTasksInput>
  }

  export type ContainerPlantCreateWithoutTasksInput = {
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    container: ContainerCreateNestedOneWithoutContainerPlantsInput
    plant: PlantCatalogCreateNestedOneWithoutContainerPlantsInput
    variety?: PlantVarietyCreateNestedOneWithoutContainerPlantsInput
    growthStages?: PlantGrowthStageCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantUncheckedCreateWithoutTasksInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    growthStages?: PlantGrowthStageUncheckedCreateNestedManyWithoutContainerPlantInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutContainerPlantInput
    harvests?: HarvestUncheckedCreateNestedManyWithoutContainerPlantInput
    movementHistory?: PlantMovementHistoryUncheckedCreateNestedManyWithoutContainerPlantInput
  }

  export type ContainerPlantCreateOrConnectWithoutTasksInput = {
    where: ContainerPlantWhereUniqueInput
    create: XOR<ContainerPlantCreateWithoutTasksInput, ContainerPlantUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutSubtasksInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSubtasksInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSubtasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
  }

  export type TaskCreateWithoutParentTaskInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutParentTaskInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput>
  }

  export type TaskCreateManyParentTaskInputEnvelope = {
    data: TaskCreateManyParentTaskInput | TaskCreateManyParentTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskNoteCreateWithoutTaskInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaskNotesInput
  }

  export type TaskNoteUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskNoteCreateOrConnectWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    create: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput>
  }

  export type TaskNoteCreateManyTaskInputEnvelope = {
    data: TaskNoteCreateManyTaskInput | TaskNoteCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCompletionLogCreateWithoutTaskInput = {
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
    user: UserCreateNestedOneWithoutTaskCompletionLogsInput
  }

  export type TaskCompletionLogUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: string
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskCompletionLogCreateOrConnectWithoutTaskInput = {
    where: TaskCompletionLogWhereUniqueInput
    create: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskCompletionLogCreateManyTaskInputEnvelope = {
    data: TaskCompletionLogCreateManyTaskInput | TaskCompletionLogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskNotificationCreateWithoutTaskInput = {
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTaskNotificationsInput
  }

  export type TaskNotificationUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskNotificationCreateOrConnectWithoutTaskInput = {
    where: TaskNotificationWhereUniqueInput
    create: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput>
  }

  export type TaskNotificationCreateManyTaskInputEnvelope = {
    data: TaskNotificationCreateManyTaskInput | TaskNotificationCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskPrerequisiteCreateWithoutTaskInput = {
    createdAt?: Date | string
    prerequisiteTask: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskPrerequisiteUncheckedCreateWithoutTaskInput = {
    id?: number
    prerequisiteTaskId: number
    createdAt?: Date | string
  }

  export type TaskPrerequisiteCreateOrConnectWithoutTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    create: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput>
  }

  export type TaskPrerequisiteCreateManyTaskInputEnvelope = {
    data: TaskPrerequisiteCreateManyTaskInput | TaskPrerequisiteCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskPrerequisiteCreateWithoutPrerequisiteTaskInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutPrerequisitesInput
  }

  export type TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type TaskPrerequisiteCreateOrConnectWithoutPrerequisiteTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    create: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput>
  }

  export type TaskPrerequisiteCreateManyPrerequisiteTaskInputEnvelope = {
    data: TaskPrerequisiteCreateManyPrerequisiteTaskInput | TaskPrerequisiteCreateManyPrerequisiteTaskInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTaskPatternCreateWithoutTaskInput = {
    frequency: string
    interval?: number
    endAfterCount?: number | null
    endByDate?: Date | string | null
    daysOfWeek?: string | null
    dayOfMonth?: number | null
    monthOfYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTaskPatternUncheckedCreateWithoutTaskInput = {
    id?: number
    frequency: string
    interval?: number
    endAfterCount?: number | null
    endByDate?: Date | string | null
    daysOfWeek?: string | null
    dayOfMonth?: number | null
    monthOfYear?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTaskPatternCreateOrConnectWithoutTaskInput = {
    where: RecurringTaskPatternWhereUniqueInput
    create: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GardenUpsertWithoutTasksInput = {
    update: XOR<GardenUpdateWithoutTasksInput, GardenUncheckedUpdateWithoutTasksInput>
    create: XOR<GardenCreateWithoutTasksInput, GardenUncheckedCreateWithoutTasksInput>
    where?: GardenWhereInput
  }

  export type GardenUpdateToOneWithWhereWithoutTasksInput = {
    where?: GardenWhereInput
    data: XOR<GardenUpdateWithoutTasksInput, GardenUncheckedUpdateWithoutTasksInput>
  }

  export type GardenUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardensNestedInput
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
  }

  export type ContainerUpsertWithoutTasksInput = {
    update: XOR<ContainerUpdateWithoutTasksInput, ContainerUncheckedUpdateWithoutTasksInput>
    create: XOR<ContainerCreateWithoutTasksInput, ContainerUncheckedCreateWithoutTasksInput>
    where?: ContainerWhereInput
  }

  export type ContainerUpdateToOneWithWhereWithoutTasksInput = {
    where?: ContainerWhereInput
    data: XOR<ContainerUpdateWithoutTasksInput, ContainerUncheckedUpdateWithoutTasksInput>
  }

  export type ContainerUpdateWithoutTasksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerPlantUpsertWithoutTasksInput = {
    update: XOR<ContainerPlantUpdateWithoutTasksInput, ContainerPlantUncheckedUpdateWithoutTasksInput>
    create: XOR<ContainerPlantCreateWithoutTasksInput, ContainerPlantUncheckedCreateWithoutTasksInput>
    where?: ContainerPlantWhereInput
  }

  export type ContainerPlantUpdateToOneWithWhereWithoutTasksInput = {
    where?: ContainerPlantWhereInput
    data: XOR<ContainerPlantUpdateWithoutTasksInput, ContainerPlantUncheckedUpdateWithoutTasksInput>
  }

  export type ContainerPlantUpdateWithoutTasksInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type TaskUpsertWithoutSubtasksInput = {
    update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TaskUpdateWithoutSubtasksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutParentTaskInput, TaskUncheckedUpdateWithoutParentTaskInput>
    create: XOR<TaskCreateWithoutParentTaskInput, TaskUncheckedCreateWithoutParentTaskInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutParentTaskInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutParentTaskInput, TaskUncheckedUpdateWithoutParentTaskInput>
  }

  export type TaskUpdateManyWithWhereWithoutParentTaskInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutParentTaskInput>
  }

  export type TaskNoteUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    update: XOR<TaskNoteUpdateWithoutTaskInput, TaskNoteUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskNoteCreateWithoutTaskInput, TaskNoteUncheckedCreateWithoutTaskInput>
  }

  export type TaskNoteUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskNoteWhereUniqueInput
    data: XOR<TaskNoteUpdateWithoutTaskInput, TaskNoteUncheckedUpdateWithoutTaskInput>
  }

  export type TaskNoteUpdateManyWithWhereWithoutTaskInput = {
    where: TaskNoteScalarWhereInput
    data: XOR<TaskNoteUpdateManyMutationInput, TaskNoteUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCompletionLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCompletionLogWhereUniqueInput
    update: XOR<TaskCompletionLogUpdateWithoutTaskInput, TaskCompletionLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCompletionLogCreateWithoutTaskInput, TaskCompletionLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskCompletionLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCompletionLogWhereUniqueInput
    data: XOR<TaskCompletionLogUpdateWithoutTaskInput, TaskCompletionLogUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCompletionLogUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCompletionLogScalarWhereInput
    data: XOR<TaskCompletionLogUpdateManyMutationInput, TaskCompletionLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskNotificationUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskNotificationWhereUniqueInput
    update: XOR<TaskNotificationUpdateWithoutTaskInput, TaskNotificationUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskNotificationCreateWithoutTaskInput, TaskNotificationUncheckedCreateWithoutTaskInput>
  }

  export type TaskNotificationUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskNotificationWhereUniqueInput
    data: XOR<TaskNotificationUpdateWithoutTaskInput, TaskNotificationUncheckedUpdateWithoutTaskInput>
  }

  export type TaskNotificationUpdateManyWithWhereWithoutTaskInput = {
    where: TaskNotificationScalarWhereInput
    data: XOR<TaskNotificationUpdateManyMutationInput, TaskNotificationUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskPrerequisiteUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    update: XOR<TaskPrerequisiteUpdateWithoutTaskInput, TaskPrerequisiteUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskPrerequisiteCreateWithoutTaskInput, TaskPrerequisiteUncheckedCreateWithoutTaskInput>
  }

  export type TaskPrerequisiteUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    data: XOR<TaskPrerequisiteUpdateWithoutTaskInput, TaskPrerequisiteUncheckedUpdateWithoutTaskInput>
  }

  export type TaskPrerequisiteUpdateManyWithWhereWithoutTaskInput = {
    where: TaskPrerequisiteScalarWhereInput
    data: XOR<TaskPrerequisiteUpdateManyMutationInput, TaskPrerequisiteUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskPrerequisiteScalarWhereInput = {
    AND?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
    OR?: TaskPrerequisiteScalarWhereInput[]
    NOT?: TaskPrerequisiteScalarWhereInput | TaskPrerequisiteScalarWhereInput[]
    id?: IntFilter<"TaskPrerequisite"> | number
    taskId?: IntFilter<"TaskPrerequisite"> | number
    prerequisiteTaskId?: IntFilter<"TaskPrerequisite"> | number
    createdAt?: DateTimeFilter<"TaskPrerequisite"> | Date | string
  }

  export type TaskPrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    update: XOR<TaskPrerequisiteUpdateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedUpdateWithoutPrerequisiteTaskInput>
    create: XOR<TaskPrerequisiteCreateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedCreateWithoutPrerequisiteTaskInput>
  }

  export type TaskPrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteTaskInput = {
    where: TaskPrerequisiteWhereUniqueInput
    data: XOR<TaskPrerequisiteUpdateWithoutPrerequisiteTaskInput, TaskPrerequisiteUncheckedUpdateWithoutPrerequisiteTaskInput>
  }

  export type TaskPrerequisiteUpdateManyWithWhereWithoutPrerequisiteTaskInput = {
    where: TaskPrerequisiteScalarWhereInput
    data: XOR<TaskPrerequisiteUpdateManyMutationInput, TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskInput>
  }

  export type RecurringTaskPatternUpsertWithoutTaskInput = {
    update: XOR<RecurringTaskPatternUpdateWithoutTaskInput, RecurringTaskPatternUncheckedUpdateWithoutTaskInput>
    create: XOR<RecurringTaskPatternCreateWithoutTaskInput, RecurringTaskPatternUncheckedCreateWithoutTaskInput>
    where?: RecurringTaskPatternWhereInput
  }

  export type RecurringTaskPatternUpdateToOneWithWhereWithoutTaskInput = {
    where?: RecurringTaskPatternWhereInput
    data: XOR<RecurringTaskPatternUpdateWithoutTaskInput, RecurringTaskPatternUncheckedUpdateWithoutTaskInput>
  }

  export type RecurringTaskPatternUpdateWithoutTaskInput = {
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTaskPatternUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    endAfterCount?: NullableIntFieldUpdateOperationsInput | number | null
    endByDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysOfWeek?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    monthOfYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateWithoutPrerequisitesInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutPrerequisitesInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutPrerequisitesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutPrerequisitesInput, TaskUncheckedCreateWithoutPrerequisitesInput>
  }

  export type TaskCreateWithoutDependentsInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutDependentsInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutDependentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
  }

  export type TaskUpsertWithoutPrerequisitesInput = {
    update: XOR<TaskUpdateWithoutPrerequisitesInput, TaskUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<TaskCreateWithoutPrerequisitesInput, TaskUncheckedCreateWithoutPrerequisitesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutPrerequisitesInput, TaskUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type TaskUpdateWithoutPrerequisitesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutPrerequisitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUpsertWithoutDependentsInput = {
    update: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskUpdateWithoutDependentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskCreateWithoutTaskNotesInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTaskNotesInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskNotesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskNotesInput, TaskUncheckedCreateWithoutTaskNotesInput>
  }

  export type UserCreateWithoutTaskNotesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskNotesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskNotesInput, UserUncheckedCreateWithoutTaskNotesInput>
  }

  export type TaskUpsertWithoutTaskNotesInput = {
    update: XOR<TaskUpdateWithoutTaskNotesInput, TaskUncheckedUpdateWithoutTaskNotesInput>
    create: XOR<TaskCreateWithoutTaskNotesInput, TaskUncheckedCreateWithoutTaskNotesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskNotesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskNotesInput, TaskUncheckedUpdateWithoutTaskNotesInput>
  }

  export type TaskUpdateWithoutTaskNotesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskNotesInput = {
    update: XOR<UserUpdateWithoutTaskNotesInput, UserUncheckedUpdateWithoutTaskNotesInput>
    create: XOR<UserCreateWithoutTaskNotesInput, UserUncheckedCreateWithoutTaskNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskNotesInput, UserUncheckedUpdateWithoutTaskNotesInput>
  }

  export type UserUpdateWithoutTaskNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskCreateWithoutTaskCompletionLogInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTaskCompletionLogInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTaskCompletionLogInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskCompletionLogInput, TaskUncheckedCreateWithoutTaskCompletionLogInput>
  }

  export type UserCreateWithoutTaskCompletionLogsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskCompletionLogsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskNotifications?: TaskNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskCompletionLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskCompletionLogsInput, UserUncheckedCreateWithoutTaskCompletionLogsInput>
  }

  export type TaskUpsertWithoutTaskCompletionLogInput = {
    update: XOR<TaskUpdateWithoutTaskCompletionLogInput, TaskUncheckedUpdateWithoutTaskCompletionLogInput>
    create: XOR<TaskCreateWithoutTaskCompletionLogInput, TaskUncheckedCreateWithoutTaskCompletionLogInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskCompletionLogInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskCompletionLogInput, TaskUncheckedUpdateWithoutTaskCompletionLogInput>
  }

  export type TaskUpdateWithoutTaskCompletionLogInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskCompletionLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskCompletionLogsInput = {
    update: XOR<UserUpdateWithoutTaskCompletionLogsInput, UserUncheckedUpdateWithoutTaskCompletionLogsInput>
    create: XOR<UserCreateWithoutTaskCompletionLogsInput, UserUncheckedCreateWithoutTaskCompletionLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskCompletionLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskCompletionLogsInput, UserUncheckedUpdateWithoutTaskCompletionLogsInput>
  }

  export type UserUpdateWithoutTaskCompletionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskCompletionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskNotifications?: TaskNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskCreateWithoutRecurringPatternInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
  }

  export type TaskUncheckedCreateWithoutRecurringPatternInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    notifications?: TaskNotificationUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
  }

  export type TaskCreateOrConnectWithoutRecurringPatternInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutRecurringPatternInput, TaskUncheckedCreateWithoutRecurringPatternInput>
  }

  export type TaskUpsertWithoutRecurringPatternInput = {
    update: XOR<TaskUpdateWithoutRecurringPatternInput, TaskUncheckedUpdateWithoutRecurringPatternInput>
    create: XOR<TaskCreateWithoutRecurringPatternInput, TaskUncheckedCreateWithoutRecurringPatternInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutRecurringPatternInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutRecurringPatternInput, TaskUncheckedUpdateWithoutRecurringPatternInput>
  }

  export type TaskUpdateWithoutRecurringPatternInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutRecurringPatternInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
  }

  export type TaskCreateWithoutNotificationsInput = {
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    user: UserCreateNestedOneWithoutTasksInput
    garden?: GardenCreateNestedOneWithoutTasksInput
    container?: ContainerCreateNestedOneWithoutTasksInput
    containerPlant?: ContainerPlantCreateNestedOneWithoutTasksInput
    parentTask?: TaskCreateNestedOneWithoutSubtasksInput
    subtasks?: TaskCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutNotificationsInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
    subtasks?: TaskUncheckedCreateNestedManyWithoutParentTaskInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutTaskInput
    taskCompletionLog?: TaskCompletionLogUncheckedCreateNestedManyWithoutTaskInput
    prerequisites?: TaskPrerequisiteUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskPrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteTaskInput
    recurringPattern?: RecurringTaskPatternUncheckedCreateNestedOneWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutNotificationsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutNotificationsInput, TaskUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutTaskNotificationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    gardens?: GardenCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaskNotificationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    gardens?: GardenUncheckedCreateNestedManyWithoutUserInput
    gardenActions?: GardenActionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    taskNotes?: TaskNoteUncheckedCreateNestedManyWithoutUserInput
    taskCompletionLogs?: TaskCompletionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaskNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskNotificationsInput, UserUncheckedCreateWithoutTaskNotificationsInput>
  }

  export type TaskUpsertWithoutNotificationsInput = {
    update: XOR<TaskUpdateWithoutNotificationsInput, TaskUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TaskCreateWithoutNotificationsInput, TaskUncheckedCreateWithoutNotificationsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutNotificationsInput, TaskUncheckedUpdateWithoutNotificationsInput>
  }

  export type TaskUpdateWithoutNotificationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTaskNotificationsInput = {
    update: XOR<UserUpdateWithoutTaskNotificationsInput, UserUncheckedUpdateWithoutTaskNotificationsInput>
    create: XOR<UserCreateWithoutTaskNotificationsInput, UserUncheckedCreateWithoutTaskNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskNotificationsInput, UserUncheckedUpdateWithoutTaskNotificationsInput>
  }

  export type UserUpdateWithoutTaskNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    gardens?: GardenUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gardens?: GardenUncheckedUpdateManyWithoutUserNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutUserNestedInput
    taskCompletionLogs?: TaskCompletionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type GardenCreateManyUserInput = {
    id?: number
    name: string
    location?: string | null
    sizeSqFeet?: Decimal | DecimalJsLike | number | string | null
    gardenType?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenActionCreateManyUserInput = {
    id?: number
    actionTypeId: number
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type TaskCreateManyUserInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
  }

  export type TaskNoteCreateManyUserInput = {
    id?: number
    taskId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCompletionLogCreateManyUserInput = {
    id?: number
    taskId: number
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskNotificationCreateManyUserInput = {
    id?: number
    taskId: number
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUpdateManyWithoutGardenNestedInput
    containers?: ContainerUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: GardenConditionUncheckedUpdateManyWithoutGardenNestedInput
    containers?: ContainerUncheckedUpdateManyWithoutGardenNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutGardenNestedInput
    seasonalPlans?: SeasonalPlanUncheckedUpdateManyWithoutGardenNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenNestedInput
    newContainers?: ContainerHistoryUncheckedUpdateManyWithoutNewGardenNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutGardenNestedInput
  }

  export type GardenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    sizeSqFeet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gardenType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUpdateWithoutUserInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: ActionTypeUpdateOneRequiredWithoutActionsNestedInput
    garden?: GardenUpdateOneWithoutGardenActionsNestedInput
    container?: ContainerUpdateOneWithoutGardenActionsNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskNoteUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTaskNotesNestedInput
  }

  export type TaskNoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionLogUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    task?: TaskUpdateOneRequiredWithoutTaskCompletionLogNestedInput
  }

  export type TaskCompletionLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCompletionLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskNotificationUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type TaskNotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionCreateManyGardenInput = {
    id?: number
    climateZone?: string | null
    sunlightExposure?: string | null
    avgTemperatureF?: Decimal | DecimalJsLike | number | string | null
    humidityPct?: number | null
    soilType?: string | null
    annualRainfall?: Decimal | DecimalJsLike | number | string | null
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerCreateManyGardenInput = {
    id?: number
    containerTypeId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenActionCreateManyGardenInput = {
    id?: number
    actionTypeId: number
    userId: string
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type SeasonalPlanCreateManyGardenInput = {
    id?: number
    season: string
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerHistoryCreateManyPreviousGardenInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateManyNewGardenInput = {
    id?: number
    containerId: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type TaskCreateManyGardenInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
  }

  export type GardenConditionUpdateWithoutGardenInput = {
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionUncheckedUpdateWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenConditionUncheckedUpdateManyWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    climateZone?: NullableStringFieldUpdateOperationsInput | string | null
    sunlightExposure?: NullableStringFieldUpdateOperationsInput | string | null
    avgTemperatureF?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    humidityPct?: NullableIntFieldUpdateOperationsInput | number | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    annualRainfall?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUpdateWithoutGardenInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerType?: ContainerTypeUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateManyWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerTypeId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUpdateWithoutGardenInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: ActionTypeUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutGardenActionsNestedInput
    container?: ContainerUpdateOneWithoutGardenActionsNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonalPlanUpdateWithoutGardenInput = {
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlannedPlantingUpdateManyWithoutPlanNestedInput
  }

  export type SeasonalPlanUncheckedUpdateWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlannedPlantingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SeasonalPlanUncheckedUpdateManyWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerHistoryUpdateWithoutPreviousGardenInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutContainerHistoryNestedInput
    previousContainer?: ContainerUpdateOneWithoutPreviousContainersNestedInput
    newGarden?: GardenUpdateOneWithoutNewContainersNestedInput
  }

  export type ContainerHistoryUncheckedUpdateWithoutPreviousGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutPreviousGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUpdateWithoutNewGardenInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutContainerHistoryNestedInput
    previousContainer?: ContainerUpdateOneWithoutPreviousContainersNestedInput
    previousGarden?: GardenUpdateOneWithoutPreviousContainersNestedInput
  }

  export type ContainerHistoryUncheckedUpdateWithoutNewGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutNewGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutGardenInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutGardenInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContainerCreateManyContainerTypeInput = {
    id?: number
    gardenId: number
    name?: string | null
    material?: string | null
    widthInches?: Decimal | DecimalJsLike | number | string | null
    lengthInches?: Decimal | DecimalJsLike | number | string | null
    heightInches?: Decimal | DecimalJsLike | number | string | null
    diameterInches?: Decimal | DecimalJsLike | number | string | null
    volumeGallons?: Decimal | DecimalJsLike | number | string | null
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    drainageQuality?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContainerUpdateWithoutContainerTypeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    garden?: GardenUpdateOneRequiredWithoutContainersNestedInput
    containerPlants?: ContainerPlantUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutContainerNestedInput
    tasks?: TaskUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateWithoutContainerTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutContainerNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerNestedInput
    containerHistory?: ContainerHistoryUncheckedUpdateManyWithoutContainerNestedInput
    previousContainers?: ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutContainerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type ContainerUncheckedUpdateManyWithoutContainerTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    gardenId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    widthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lengthInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    heightInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    diameterInches?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumeGallons?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    drainageQuality?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerPlantCreateManyContainerInput = {
    id?: number
    plantId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GardenActionCreateManyContainerInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type ContainerHistoryCreateManyContainerInput = {
    id?: number
    previousContainerId?: number | null
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type ContainerHistoryCreateManyPreviousContainerInput = {
    id?: number
    containerId: number
    previousGardenId?: number | null
    newGardenId?: number | null
    moveDate: Date | string
    reason?: string | null
  }

  export type PlannedPlantingCreateManyContainerInput = {
    id?: number
    planId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type TaskCreateManyContainerInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
  }

  export type ContainerPlantUpdateWithoutContainerInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateManyWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUpdateWithoutContainerInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: ActionTypeUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutGardenActionsNestedInput
    garden?: GardenUpdateOneWithoutGardenActionsNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerHistoryUpdateWithoutContainerInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    previousContainer?: ContainerUpdateOneWithoutPreviousContainersNestedInput
    previousGarden?: GardenUpdateOneWithoutPreviousContainersNestedInput
    newGarden?: GardenUpdateOneWithoutNewContainersNestedInput
  }

  export type ContainerHistoryUncheckedUpdateWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUpdateWithoutPreviousContainerInput = {
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    container?: ContainerUpdateOneRequiredWithoutContainerHistoryNestedInput
    previousGarden?: GardenUpdateOneWithoutPreviousContainersNestedInput
    newGarden?: GardenUpdateOneWithoutNewContainersNestedInput
  }

  export type ContainerHistoryUncheckedUpdateWithoutPreviousContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerHistoryUncheckedUpdateManyWithoutPreviousContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    previousGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    newGardenId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlannedPlantingUpdateWithoutContainerInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: SeasonalPlanUpdateOneRequiredWithoutPlantingsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    variety?: PlantVarietyUpdateOneWithoutPlannedPlantingsNestedInput
  }

  export type PlannedPlantingUncheckedUpdateWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutContainerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutContainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlantClimateZoneCreateManyPlantInput = {
    id?: number
    climateZone: string
    notes?: string | null
  }

  export type PlantVarietyCreateManyPlantInput = {
    id?: number
    varietyName: string
    description?: string | null
    specificTraits?: string | null
    specificCareNeeds?: string | null
    imageUrl?: string | null
  }

  export type PlantCompanionCreateManyPlantInput = {
    id?: number
    companionPlantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type PlantCompanionCreateManyCompanionPlantInput = {
    id?: number
    plantId: number
    relationshipType: string
    effectDescription?: string | null
  }

  export type ContainerPlantCreateManyPlantInput = {
    id?: number
    containerId: number
    varietyId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannedPlantingCreateManyPlantInput = {
    id?: number
    planId: number
    containerId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlantClimateZoneUpdateWithoutPlantInput = {
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantClimateZoneUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantClimateZoneUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    climateZone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantVarietyUpdateWithoutPlantInput = {
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlants?: ContainerPlantUpdateManyWithoutVarietyNestedInput
    plannedPlantings?: PlannedPlantingUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    containerPlants?: ContainerPlantUncheckedUpdateManyWithoutVarietyNestedInput
    plannedPlantings?: PlannedPlantingUncheckedUpdateManyWithoutVarietyNestedInput
  }

  export type PlantVarietyUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    varietyName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificTraits?: NullableStringFieldUpdateOperationsInput | string | null
    specificCareNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionUpdateWithoutPlantInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companionPlant?: PlantCatalogUpdateOneRequiredWithoutCompanionToNestedInput
  }

  export type PlantCompanionUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    companionPlantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    companionPlantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionUpdateWithoutCompanionPlantInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantCatalogUpdateOneRequiredWithoutCompanionsNestedInput
  }

  export type PlantCompanionUncheckedUpdateWithoutCompanionPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantCompanionUncheckedUpdateManyWithoutCompanionPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    effectDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContainerPlantUpdateWithoutPlantInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    variety?: PlantVarietyUpdateOneWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannedPlantingUpdateWithoutPlantInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: SeasonalPlanUpdateOneRequiredWithoutPlantingsNestedInput
    container?: ContainerUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    variety?: PlantVarietyUpdateOneWithoutPlannedPlantingsNestedInput
  }

  export type PlannedPlantingUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ContainerPlantCreateManyVarietyInput = {
    id?: number
    containerId: number
    plantId: number
    quantity?: Decimal | DecimalJsLike | number | string | null
    plantDate: Date | string
    initialStage: string
    currentStage: string
    status?: string
    positionX?: Decimal | DecimalJsLike | number | string | null
    positionY?: Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannedPlantingCreateManyVarietyInput = {
    id?: number
    planId: number
    containerId: number
    plantId: number
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type ContainerPlantUpdateWithoutVarietyInput = {
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: ContainerUpdateOneRequiredWithoutContainerPlantsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutContainerPlantsNestedInput
    growthStages?: PlantGrowthStageUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateWithoutVarietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    growthStages?: PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantNestedInput
    gardenActions?: GardenActionUncheckedUpdateManyWithoutContainerPlantNestedInput
    harvests?: HarvestUncheckedUpdateManyWithoutContainerPlantNestedInput
    movementHistory?: PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutContainerPlantNestedInput
  }

  export type ContainerPlantUncheckedUpdateManyWithoutVarietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialStage?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    positionX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedHarvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannedPlantingUpdateWithoutVarietyInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: SeasonalPlanUpdateOneRequiredWithoutPlantingsNestedInput
    container?: ContainerUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutPlannedPlantingsNestedInput
  }

  export type PlannedPlantingUncheckedUpdateWithoutVarietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutVarietyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlantGrowthStageCreateManyContainerPlantInput = {
    id?: number
    stageName: string
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type GardenActionCreateManyContainerPlantInput = {
    id?: number
    actionTypeId: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type HarvestCreateManyContainerPlantInput = {
    id?: number
    harvestDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    qualityRating?: number | null
    notes?: string | null
    imageUrl?: string | null
  }

  export type PlantMovementHistoryCreateManyContainerPlantInput = {
    id?: number
    previousContainerId?: number | null
    newContainerId?: number | null
    moveDate: Date | string
    reason?: string | null
    plantConditionBefore?: string | null
    plantConditionAfter?: string | null
  }

  export type TaskCreateManyContainerPlantInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
    parentTaskId?: number | null
  }

  export type PlantGrowthStageUpdateWithoutContainerPlantInput = {
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantGrowthStageUncheckedUpdateWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantGrowthStageUncheckedUpdateManyWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    stageName?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GardenActionUpdateWithoutContainerPlantInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: ActionTypeUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutGardenActionsNestedInput
    garden?: GardenUpdateOneWithoutGardenActionsNestedInput
    container?: ContainerUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionTypeId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarvestUpdateWithoutContainerPlantInput = {
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HarvestUncheckedUpdateWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HarvestUncheckedUpdateManyWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    harvestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    qualityRating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryUpdateWithoutContainerPlantInput = {
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryUncheckedUpdateWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantMovementHistoryUncheckedUpdateManyWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    newContainerId?: NullableIntFieldUpdateOperationsInput | number | null
    moveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    plantConditionAfter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutContainerPlantInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    parentTask?: TaskUpdateOneWithoutSubtasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutContainerPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    parentTaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GardenActionCreateManyActionTypeInput = {
    id?: number
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    actionDate: Date | string
    quantity?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    successRating?: number | null
    createdAt?: Date | string
  }

  export type GardenActionUpdateWithoutActionTypeInput = {
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGardenActionsNestedInput
    garden?: GardenUpdateOneWithoutGardenActionsNestedInput
    container?: ContainerUpdateOneWithoutGardenActionsNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutGardenActionsNestedInput
  }

  export type GardenActionUncheckedUpdateWithoutActionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GardenActionUncheckedUpdateManyWithoutActionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    successRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannedPlantingCreateManyPlanInput = {
    id?: number
    containerId: number
    plantId: number
    varietyId?: number | null
    plannedDate?: Date | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    status?: string
  }

  export type PlannedPlantingUpdateWithoutPlanInput = {
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    container?: ContainerUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    plant?: PlantCatalogUpdateOneRequiredWithoutPlannedPlantingsNestedInput
    variety?: PlantVarietyUpdateOneWithoutPlannedPlantingsNestedInput
  }

  export type PlannedPlantingUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PlannedPlantingUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    containerId?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    varietyId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyParentTaskInput = {
    id?: number
    title: string
    description: string
    status?: string
    category: string
    priority?: string
    difficulty?: string
    estimatedMinutes?: number | null
    startDate?: Date | string | null
    endDate: Date | string
    dateCompleted?: Date | string | null
    userId: string
    gardenId?: number | null
    containerId?: number | null
    containerPlantId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isRecurring?: boolean
  }

  export type TaskNoteCreateManyTaskInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCompletionLogCreateManyTaskInput = {
    id?: number
    userId: string
    status: string
    completedAt?: Date | string
    notes?: string | null
    percentDone?: number | null
    timeSpentMinutes?: number | null
  }

  export type TaskNotificationCreateManyTaskInput = {
    id?: number
    userId: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskPrerequisiteCreateManyTaskInput = {
    id?: number
    prerequisiteTaskId: number
    createdAt?: Date | string
  }

  export type TaskPrerequisiteCreateManyPrerequisiteTaskInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type TaskUpdateWithoutParentTaskInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    garden?: GardenUpdateOneWithoutTasksNestedInput
    container?: ContainerUpdateOneWithoutTasksNestedInput
    containerPlant?: ContainerPlantUpdateOneWithoutTasksNestedInput
    subtasks?: TaskUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutParentTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    subtasks?: TaskUncheckedUpdateManyWithoutParentTaskNestedInput
    taskNotes?: TaskNoteUncheckedUpdateManyWithoutTaskNestedInput
    taskCompletionLog?: TaskCompletionLogUncheckedUpdateManyWithoutTaskNestedInput
    notifications?: TaskNotificationUncheckedUpdateManyWithoutTaskNestedInput
    prerequisites?: TaskPrerequisiteUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskNestedInput
    recurringPattern?: RecurringTaskPatternUncheckedUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutParentTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    gardenId?: NullableIntFieldUpdateOperationsInput | number | null
    containerId?: NullableIntFieldUpdateOperationsInput | number | null
    containerPlantId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskNoteUpdateWithoutTaskInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskNotesNestedInput
  }

  export type TaskNoteUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNoteUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionLogUpdateWithoutTaskInput = {
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutTaskCompletionLogsNestedInput
  }

  export type TaskCompletionLogUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCompletionLogUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    percentDone?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskNotificationUpdateWithoutTaskInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskNotificationsNestedInput
  }

  export type TaskNotificationUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskNotificationUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteUpdateWithoutTaskInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTask?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskPrerequisiteUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisiteTaskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisiteTaskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteUpdateWithoutPrerequisiteTaskInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type TaskPrerequisiteUncheckedUpdateWithoutPrerequisiteTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskPrerequisiteUncheckedUpdateManyWithoutPrerequisiteTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}